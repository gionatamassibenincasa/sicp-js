= Struttura e interpretazione dei programmi del calcolatore - adattato al JavaScript
Gionata Massi <gionata.massi@savoiabenincasa.it>
v0.1.1, 2020-04-10: Prima bozza con paragrafo 1.1
:description: Struttura e interpretazione dei programmi del calcolatore adattato al JavaScript
:keywords: SICP, JS, JavaScript
:doctype: book
:sectnums:
:icons: font
:autofit-option:
:experimental:
:reproducible:
:lang: it
:toc:
:toc-title: Indice
:toclevels: 4
:part-caption: Parte
:part-label:
:part-sigref: parte
:appendix-refsig: appendice
:chapter-caption: Capitolo
:chapter-label: Capitolo
:chapter-refsig: capitolo
:sect-label: Paragrafo
:section-refsig: paragrafo
:table-caption: Tabella
:table-refsig: tabella
:figure-caption: Figura
:figure-refsig: figura
:xrefstyle: short
:imagesdir: img

Questo testo è un adattamento in italiano, realizzato con l'auito di Google Translate, del testo https://sicp.comp.nus.edu.sg/[Structure and Interpretation of Computer Programs — JavaScript Adaptation], il quale è, a sua volta, un adattamento della seconda edizione del noto libro di testo di Harold Abelson e Gerald Jay Sussman dal titolo: "Structure and Interpretation of Computer Programs".

== Costruire astrazioni con le funzioni

[quote, John Locke, Saggio sull'intelletto umano - Libro II (Delle Idee) Capitolo XII (Delle idee complesse). 1690.]
____
Gli atti con cui lo spirito esercita il suo potere sulle idee semplici
sono principalmente questi tre:

. _combinare_ varie idee semplici per formarne una complessa; così sono formate tutte le _idee complesse_
.  _mettere assieme_ due idee, semplici o complesse, e giustapporle in modo
da vederle insieme senza unirle; così lo spirito ottiene tutte le sue
_idee di relazioni_;
. _separar_ le idee _da_ tutte le altre che le
accompagnano nella loro esistenza _reale_, e questo si chiama
astrazione: in tal modo sono formate tutte le _idee generali_.
____

Stiamo per studiare il concetto di *processo di calcolo* o *processo
computazionale*. I processi computazionali sono esseri astratti che
vivono nei calcolatori, come i nostri _computer_, _tablet_,
_smartphone_, dispositivi dello _Internet of things_… I processi, mentre
evolvono, manipolano altri oggetti astratti chiamati *dati*.
L’evoluzione di un processo è diretta da uno schema di regole chiamato
*programma*. Gli uomini creano i programmi per dirigere i processi.
Quando eseguiamo un programma, in effetti, evochiamo gli spiriti del
computer con i nostri incantesimi.

Un processo computazionale è molto simile all’idea che uno stregone ha
di uno spirito. Il processo non può essere visto o toccato. Non è
composto di materia. Tuttavia è reale. Può eseguire compiti
intellettuali. Può rispondere a delle domande. Può gestire eventi del
mondo reale erogando denaro in una banca o controllando un braccio
robotico in una fabbrica. I programmi che usiamo per evocare i processi
sono come gli incantesimi di uno stregone. Sono accuratamente composti
da *espressioni simboliche* in *linguaggi di programmazione* arcani ed
esoterici che prescrivono i compiti che vogliamo far eseguire ai nostri
processi.

Un processo computazionale, in un computer che funziona correttamente,
esegue i programmi in modo preciso e accurato. Quindi i programmatori
alle prime armi, come l’apprendista stregone, devono imparare a capire e
anticipare le conseguenze della loro evocazione. Anche piccoli errori
nei programmi (di solito chiamati *bug* o _glitch_) possono avere
conseguenze complesse e impreviste.

Fortunatamente, imparare a programmare è considerevolmente meno
pericoloso dello studio della stregoneria, perché gli spiriti di cui ci
occupiamo sono confinati nel computer. La programmazione nel mondo
reale, tuttavia, richiede cura, competenza e saggezza. Un piccolo bug in
un programma di progettazione assistita da computer (Computer Aided
Design, CAD), ad esempio, può portare al catastrofico crollo di un aereo
o di una diga o all’autodistruzione di un robot industriale.

Gli ingegneri del software hanno la capacità di organizzare i programmi
in modo da essere ragionevolmente sicuri che i processi risultanti
eseguiranno i compiti previsti. Possono anticipare il comportamento dei
loro sistemi. Sanno come *strutturare i programmi* in modo tale che
problemi imprevisti non portino a conseguenze catastrofiche e quando
sorgono problemi, possono eseguire il *debug* dei loro programmi.
Sistemi computazionali ben progettati, come automobili ben progettate o
reattori nucleari, sono progettati in modo *modulare*, in modo che le
parti possano essere costruite, sostituite e messe a punto
separatamente.

*Programmazione in JavaScript*

Abbiamo bisogno di un linguaggio appropriato per descrivere i processi e
useremo a questo scopo il _linguaggio di programmazione_ *JavaScript*.
Proprio come i nostri pensieri quotidiani sono generalmente espressi nel
nostro linguaggio naturale (come italiano, inglese, francese o
giapponese) e le descrizioni dei fenomeni quantitativi sono espresse con
notazioni matematiche, il nostro linguaggio per descrivere i processi
computazionali sarà il linguaggio JavaScript.

JavaScript è stato sviluppato all’inizio degli anni ’90 come linguaggio
di programmazione per il controllo del comportamento dei browser del
World Wide Web tramite _script_ (letteralmente, copioni) incorporati
nelle pagine web. Il linguaggio è stata concepito da Brendan Eich,
originariamente sotto il nome di _Moka_, poi rinominato _LiveScript_ e
infine JavaScript. Il nome _JavaScript_ è un marchio di _Oracle
Corporation_ e il comitato di standardizzazione _ECMA_ ne descrive la
sintassi come _ECMAScript_.

Nonostante sia nato come linguaggio per il controllo dei browser,
JavaScript è un linguaggio di programmazione generico. Un interprete
JavaScript è una macchina che esegue i processi descritti nel linguaggio
JavaScript. Il primo interprete JavaScript è stato implementato da Eich
presso _Netscape Communications Corporation_, per il browser web
_Netscape Navigator_. Le caratteristiche principali di JavaScript sono
ereditate dai linguaggi *Scheme* e *Self*. _Scheme_ è un dialetto del
*Lisp* ed è stato usato come linguaggio di programmazione per la
versione originale di questo libro. Da _Scheme_, JavaScript ha ereditato
i principi di progettazione fondamentali.

JavaScript ha solo una superficiale somiglianza con il linguaggio
*Java*, da cui l’assonanza del nome; sia Java che JavaScript utilizzano
la struttura a blocchi del *linguaggio C*. Contrariamente a Java e C,
che di solito vengono _compilati_ in linguaggi di livello inferiore, i
programmi JavaScript sono stati inizialmente interpretati dai browser
web. Dopo _Netscape Navigator_, altri browser web hanno fornito
interpreti per il linguaggio, incluso _Microsoft Internet Explorer_, la
cui versione JavaScript è chiamata _JScript_. La popolarità di
JavaScript per il controllo dei browser Web ha dato origine a uno sforzo
di standardizzazione, culminato in *ECMAScript*. La prima edizione dello
standard ECMAScript è stata guidata da Guy Lewis Steele Jr. e completata
nel giugno 1997 (Ecma 1997). La sesta edizione, utilizzata in questo
libro, è stata guidata da Allen Wirfs-Brock e adottata dall’Assemblea
Generale dell’ECMA nel giugno 2015.

La pratica di incorporare programmi JavaScript in pagine Web ha
incoraggiato gli sviluppatori di browser Web a implementare interpreti
JavaScript. Man mano che questi programmi diventavano più complessi, gli
interpreti devono diventare più efficienti nell’eseguirli. Oggi essi
usano tecniche sofisticate come la compilazione Just-In-Time (JIT). La
maggior parte dei programmi JavaScript (a partire dal 2020) sono
incorporati nelle pagine Web e interpretati dai browser, ma JavaScript
viene anche utilizzato per risolvere problemi di carattere generale,
spesso usando l’interprete Node.js.

Tuttavia, è la capacità dei browser di eseguire programmi JavaScript che
lo rende un linguaggio ideale per una versione online di un libro di
testo di programmazione. L’esecuzione dei programmi facendo clic sugli
elementi di una pagina Web è naturale in JavaScript, dopo tutto quello
per cui è stato progettato JavaScript! Più fondamentalmente, JavaScript
possiede funzionalità che lo rendono un mezzo eccellente per studiare
importanti costrutti di programmazione e strutture di dati e per
metterli in relazione con le caratteristiche linguistiche che li
supportano. Le funzioni di prima classe con visibilità statica di
JavaScript forniscono accesso diretto e conciso ai meccanismi di
astrazione. La tipizzazione dinamica elimina la necessità di dichiarare
i tipi di dati manipolati dal programma. Oltre a queste considerazioni,
la programmazione in JavaScript è molto divertente.

=== Gli elementi della programmazione

Un linguaggio di programmazione è più di un semplice strumento per
istruire un computer a svolgere compiti. *Il linguaggio funge* anche *da
framework all’interno del quale organizziamo le nostre idee sui
processi*. Pertanto, quando descriviamo un linguaggio, dovremmo prestare
particolare attenzione ai costrutti esso fornisce per combinare idee
semplici e formare idee più complesse. Ogni linguaggio potente ha tre
meccanismi per raggiungere questo obiettivo:

_ *espressioni primitive*, che rappresentano le entità più semplici di
cui il linguaggio si occupa, _ *costrutti di combinazione*, mediante i
quali gli elementi più semplici si combinamo per formare gli elementi
composti, e * *costrutti di astrazione*, mediante i quali gli elementi
composti possono essere denominati e manipolati come unità.

Nella programmazione ci occupiamo di due tipi di elementi: *funzioni* e
*dati*. Più avanti scopriremo che in realtà *non sono* così *distinti*.
Informalmente, i dati sono cose che vogliamo manipolare e le funzioni
sono descrizioni delle regole per manipolare i dati. Pertanto, qualsiasi
linguaggio di programmazione dovrebbe essere in grado di descrivere dati
primitivi e funzioni primitive e dovrebbe avere metodi per combinare e
astrarre funzioni e dati.

In questo capitolo tratteremo solo semplici dati numerici in modo da
poterci concentrare sulle regole per la costruzione di funzioni. Nei
capitoli successivi vedremo che queste stesse regole ci consentono di
creare funzioni per manipolare anche i dati composti.

==== Espressioni

Un modo semplice per iniziare a programmare in JavaScript è interagire
con l’interprete JavaScript integrato nel browser che si sta utilizzando
per visualizzare questa pagina. Un *programma* JavaScript è una
*sequenza di istruzioni*.

Un tipo di istruzione è un’*istruzione espressione*, che consiste in
un’espressione, seguita da un punto e virgola. Un semplice tipo di
espressione è un numero. (Più precisamente, l’espressione è costituita
dalle cifre che rappresentano il numero in base 10.)

[source,javascript]
----
486;
----

Le espressioni che rappresentano numeri possono essere combinate con
*operatori* (come + o *) per formare un’*espressione composta* che
rappresenta l’applicazione di una funzione primitiva corrispondente a
tali numeri. Ad esempio:

[source,javascript]
----
137 + 349;
----

[source,javascript]
----
1000 - 334;
----

[source,javascript]
----
5 * 99;
----

[source,javascript]
----
10 / 5;
----

[source,javascript]
----
2.7 + 10;
----

Espressioni come queste, che contengono altre espressioni come
componenti, sono chiamate *combinazioni*. Le combinazioni che sono
formate da un simbolo di operatore tra le espressioni degli operandi
sono combinazioni mediante operatori. Il valore di una combinazione
mediante operatori si ottiene applicando la funzione specificata
dall’operatore agli argomenti, ossia ai valori degli operandi.

La convenzione di posizionare l’operatore tra gli operandi è nota come
notazione infissa. Segue la notazione matematica con cui il lettore ha
certamente familiarità. Come in matematica, le combinazioni mediante
operatori possono essere nidificate, ovvero possono prendere argomenti
che sono esse stesse combinazioni di operatori:

[source,javascript]
----
(3 * 5) + (10 - 6);
----

Come al solito, le parentesi vengono utilizzate per raggruppare le
combinazioni di operatori al fine di evitare ambiguità. JavaScript segue
anche le consuete convenzioni quando vengono omesse le parentesi; la
moltiplicazione e la divisione legano maggiormente di addizioni e
sottrazioni. Per esempio,

[source,javascript]
----
3 * 5 + 10 / 2;
----

sta per

[source,javascript]
----
(3 * 5) + (10 / 2);
----

Diciamo che `*` e `/` hanno una precedenza maggiore di `+` e `-`. Le
sequenze di addizioni e sottrazioni vengono lette da sinistra a destra,
così come le sequenze di moltiplicazioni e divisioni. Così,

[source,javascript]
----
3 / 5 * 2 - 4 + 3;
----

sta per

[source,javascript]
----
(((3 / 5) * 2) - 4) + 3;
----

Si dice che gli operatori `+`, `-`, `*` e `/` sono *associativi a
sinistra*.

In linea di principio, non c’è limite alla profindità degli annidamenti
o alla complessità delle espressioni che l’interprete JavaScript possa
valutare. Noi essere umani, invece, possiamo restare confusi anche
confrontandoci con semplici espressioni come:

[source,javascript]
----
3 * 2 * (4 + (3 - 5)) + 10 * (27 / 6);
----

che l’interprete valuta prontamente come 57. Possiamo aiutarci scrivendo
una tale espressione nella forma

[source,javascript]
----
3 * 2 * (4 + (3 - 5))
+
10 * (27/6);
----

per separare visivamente i principali componenti dell’espressione.

L’interprete opera sempre nello stesso ciclo di base: legge
un’istruzione dal browser, valuta l’istruzione e stampa il risultato.
Questa modalità operativa viene spesso espressa dicendo che l’interprete
funziona in un *ciclo di lettura-valutazione-stampa*
(read-eval-print-loop, *REPL*). Si noti in particolare che non è
necessario istruire esplicitamente l’interprete a stampare il valore
dell’istruzione.

==== Denominazione e ambiente

Un aspetto critico di un linguaggio di programmazione sono i costrutti
che prevedono l’uso di _nomi_ per fare riferimento a _oggetti
computazionali_, e i nostri primi tali costrutti sono *costanti*.
Diciamo che il nome identifica una costante il cui valore è l’oggetto.

In JavaScript, denominiamo le costanti usando le *dichiarazioni di
costante*. Digitando

[source,javascript]
----
const dimensione = 2;
----

fa sì che l’interprete associ il valore 2 al nome `dimensione`. Il
compito della dichiarazione di costante è creare questa associazione. La
specifica JavaScript richiede che il valore speciale indefinito,
`undefined` sia il risultato della valutazione di tali dichiarazioni di
costante. Una volta che il nome `dimensione` è stato associato al numero
2, possiamo fare riferimento al valore 2 per nome, come in

[source,javascript]
----
dimensione;
----

oppure

[source,javascript]
----
5 * dimensione;
----

Naturalmente, l’interprete JavaScript deve eseguire la _dichiarazione di
costante_ per `dimensione` prima che il nome `dimensione` possa essere
utilizzato in un’espressione.

Si nota qui che le istruzioni JavaScript possono essere inserite in una
sequenza. L’interprete valuta i componenti della sequenza nell’ordine
dato e considera il valore dell’ultimo componente come il valore della
sequenza.

Ecco altri esempi dell’uso di `const`:

[source,javascript]
----
const pi_greco = 3.14159;
const raggio = 10;
pi_greco * raggio * raggio;
const circonferenza =  2 * pi_greco * raggio;
circonferenza;
----

La _dichiarazione di costante_ è il costrutto di _astrazione_ più
semplice del nostro linguaggio, poiché ci consente di usare dei nomi per
fare riferimento ai risultati di operazioni composte, come la
circonferenza sopra calcolata. In generale, gli oggetti computazionali
possono avere strutture molto complesse e sarebbe estremamente scomodo
dover ricordare e ripetere i loro dettagli ogni volta che vogliamo
usarli. In effetti, programmi complessi sono costruiti generando, passo
dopo passo, oggetti computazionali di crescente complessità. Il nostro
interprete facilita questa costruzione passo-passo del programma perché
le associazioni nome-oggetto possono essere create in modo incrementale
nelle interazioni successive.

Dovrebbe essere chiarp che la possibilità di associare valori a nomi e
di recuperarli in seguito significa che l’interprete deve mantenere una
sorta di memoria che tiene traccia delle coppie (nome, oggetto). Questa
memoria è chiamata *ambiente* (più precisamente *ambiente globale*,
poiché vedremo più avanti che un calcolo può coinvolgere un numero di
ambienti diversi).

==== Valutazione delle combinazioni mediante operatori

Uno degli obiettivi do questo capitolo è quello di isolare i problemi
relativi alle descrizioni dei processi. Ad esempio, consideriamo che,
nel valutare le combinazioni mediante operatori, l’interprete proceda
come segue.

* Per valutare una combinazione mediante operatori, procedi come segue:
1.  Valuta le espressioni operando della combinazione.
2.  Applicare la funzione indicata dall’operatore agli argomenti che
sono i valori degli operandi.

Anche questa semplice regola illustra alcuni punti importanti sui
processi in generale. Innanzitutto, osserva che il primo passo impone
che per completare il processo di valutazione per un’espressione
dell’operatore dobbiamo prima eseguire il processo di valutazione su
ciascun operando della combinazione mediante operatore. Pertanto, la
regola di valutazione è di natura ricorsiva; cioè include, come uno dei
suoi passi, la necessità di invocare la regola stessa. Notate quanto in
modo conciso l’idea della ricorsione possa essere utilizzata per
esprimere ciò che, nel caso di una combinazione profondamente annidata,
verrebbe altrimenti visto come un processo piuttosto complicato. Ad
esempio, valutare

[source,javascript]
----
(2 + 4 * 6) * (3 + 12);
----

richiede che la regola di valutazione sia applicata a quattro diverse
combinazioni. Possiamo ottenere un’immagine di questo processo
rappresentando la combinazione sotto forma di un *albero*, come mostrato
nella Figura 1.1. Ogni combinazione è rappresentata da un nodo con
diramazioni corrispondenti all’operatore e agli operandi della
combinazione mediante operatori. I nodi terminali (ovvero nodi senza
rami che ne derivano) rappresentano operatori o numeri. Osservando la
valutazione in termini di struttura ad albero, possiamo immaginare che i
valori degli operandi si muovano verso l’alto, partendo dai nodi
terminali e poi combinandosi a livelli sempre più alti. In generale,
vedremo che la ricorsione è una tecnica molto potente per trattare
oggetti gerarchici come gli alberi. In effetti, il processo di
produzione e consumo di valori salendo verso l’alto che si ottiene della
regola di valutazione è un esempio di un tipo generale di processo noto
come _tree accumulation_.

image:https://sicp.comp.nus.edu.sg/chapters/img_javascript/ch1-Z-G-1.svg[Rappresentazione
dell’albero, che mostra il valore di ogni
sottoespressione.,title="Figura 1.1 Rappresentazione dell'albero, con illustrazione del valore di ogni sottoespressione."]

Successivamente, osserva che l’applicazione ripetuta del primo passaggio
ci porta al punto in cui dobbiamo valutare, non combinazioni mediante
operatori, ma *espressioni primitive* come numeri o nomi. Ci occupiamo
dei casi primitivi stabilendo che

_ i valori dei numeri sono i numeri rappresentati nella notazione
posizionale in base 10, con il punto per separatore decimale, _ i valori
dei nomi sono gli oggetti associati a quei nomi nell’ambiente.

Notare il ruolo dell’ambiente nel determinare il significato dei nomi
nelle espressioni. In JavaScript, non ha senso parlare del valore di
un’espressione come `x + 1` senza specificare alcuna informazione
sull’ambiente che fornirebbe un significato per il nome `x`.

Si noti che la regola di valutazione sopra indicata non gestisce le
dichiarazioni di costanti. Ad esempio, valutando `const x = 3;` non si
applica l’operatore `=` a due argomenti, uno dei quali è il valore del
nome `x` e l’altro è `3`, poiché lo scopo della dichiarazione costante è
proprio quello di associare `x` a un valore. (Cioè, la parte `x = 3`
nella dichiarazione di costante

[source,javascript]
----
const x = 3;
----

non è una combinazione di operatori.

La stringa `const` nella dichiarazione costante viene visualizzata in
grassetto per indicare che è una *parola chiave* in JavaScript. Le
parole chiave sono *parole riservate* che hanno un significato
particolare e quindi non possono essere utilizzate come nomi. Una parola
chiave o una combinazione di parole chiave indica all’interprete
JavaScript di trattare la rispettiva dichiarazione in modo speciale.
Ciascuna di queste forme sintattiche ha una propria regola di
valutazione. I vari tipi di dichiarazioni (ciascuna con la relativa
regola di valutazione associata) costituiscono la *sintassi* del
linguaggio di programmazione.

==== Funzioni

Abbiamo identificato in JavaScript alcuni degli elementi che devono
apparire in qualsiasi linguaggio di programmazione:

 * I numeri e le operazioni aritmetiche sono dati e funzioni primitivi.
 * L’annidamento delle combinazioni fornisce un costrutto per combinare
le operazioni.  * Le dichiarazioni di costante che associano i nomi ai
valori forniscono un costutto di astrazione.

Ora conosceremo le *dichiarazioni di funzione*, una tecnica di
astrazione molto più potente con la quale a un’operazione composta può
essere assegnato un nome e quindi considerato come un’unità.

Iniziamo esaminando come esprimere l’idea di quadratura di un numero.
Potremmo dire che, per quadrare un numero, occorre moliplicarlo per se
stesso. Questo è espresso in

[source,javascript]
----
function quadrato (x) {
    return x * x;
}
----

possiamo capirlo nel modo seguente:

[source,javascript]
----
function quadrato(    x   ) { return      x        *           x; }
//  ^       ^         ^         ^         ^        ^           ^
// Per    quadrare un numero,             lo moltiplichi per se stesso.
----

Qui abbiamo una funzione composta, a cui è stato dato il nome
`quadrato`. La funzione rappresenta l’operazione di moltiplicare
qualcosa per se stesso. Alla cosa da moltiplicare viene assegnato un
nome locale, `x`, che svolge lo stesso ruolo di un pronome nel
linguaggio naturale. La valutazione della _dichiarazione di funzione_
crea questa funzione composta e la associa al nome `quadrato`.

La nostra forma più semplice di una dichiarazione di funzione è

*function* _nome_ *(* _parametri_ *)* *\{ return* _espressione_ *; }*

Il nome è un simbolo da associare alla funzione nell’*ambiente*. I
parametri sono i nomi utilizzati nel corpo della funzione per fare
riferimento agli argomenti corrispondenti della funzione. L’espressione
dopo la parola chiave *return* è l’espressione da restituire che
produrrà il valore dell’*applicazione della funzione* quando i parametri
vengono sostituiti dagli argomenti a cui viene applicata la funzione. I
parametri sono raggruppati tra parentesi e separati da virgole, proprio
come sarebbero in una chiamata effettiva alla funzione dichiarata.

Avendo dichiarato la funzione `quadrato`, ora possiamo usarla in
un’*espressione di applicazione di funzione*, che trasformiamo in
un’istruzione usando un punto e virgola:

[source,javascript]
----
quadrato(21);
----

Il nome `quadrato` l’*espressione della funzione* dell’applicazione e 21
è l’*espressione dell’argomento*.

[source,javascript]
----
quadrato (2 + 5);
----

Qui, l’_espressione argomento_ è essa stessa un’espressione composta,
l’_espressione mediante operatore_ `2 + 5`.

[source,javascript]
----
quadrato (quadrato (3));
----

Naturalmente le _espressioni di applicazione_ possono anche servire come
espressioni di argomenti. Possiamo anche usare `quadrato` come un
mattoncino con cui definire altre funzioni. Ad esempio,
latexmath:[$x^2 + y^2$] può essere espresso come
`quadrato (x) + quadrato (y);`.

Possiamo facilmente dichiarare una funzione sum_of_squares che, dati due
numeri qualsiasi come argomenti, produce la somma dei loro quadrati:

[source,javascript]
----
function somma_di_quadrati (x, y) {
    return quadrato (x) + quadrato (y);
}
----

Ora possiamo usare `somma_di_quadrati` come mattoncino per la
costruzione di ulteriori funzioni:

[source,javascript]
----
function f (a) {
    return somma_di_quadrati (a + 1, a * 2);
}
----

L’applicazione di funzioni come `somma_di_quadrati (3, 4)` è - dopo la
combinazione mediante operatore - il secondo tipo di combinazione di
espressioni in espressioni più grandi che incontriamo. Oltre alle
funzioni composte, JavaScript fornisce una serie di funzioni primitive
integrate nell’interprete. Un esempio è la funzione `Math.log` che
calcola il logaritmo naturale del suo argomento. La valutazione
dell’espressione dell’applicazione `Math.log (1)` determina il numero 0.
Le funzioni primitive vengono utilizzate esattamente allo stesso modo
delle funzioni composte. In effetti, non si può dire guardando la
definizione di `somma_di_quadrati` sopra indicata se il quadrato sia una
funzione primitiva dell’interprete, come `Math.log`, o se sia definito
come una funzione composta.

==== Il modello di sostituzione per l’applicazione delle funzioni

Per valutare una combinazione mediante applicazione, l’interprete segue
un processo simile a quello delle combinazioni mediante operatori,
descritto sopra. Cioè, l’interprete valuta gli elementi della
combinazione e applica la funzione (che è il valore dell’espressione
della funzione) agli argomenti (che sono i valori delle espressioni
degli argomenti della combinazione dell’applicazione).

Più in dettaglio, l’interprete procede come segue quando valuta le
combinazioni di applicazioni:

* Per valutare una combinazione di applicazioni della forma
*funzione-espressione (* _argomenti-espressioni_ *)* fare quanto segue:
** Valuta l’espressione della funzione della combinazione
dell’applicazione, risultante nella funzione da applicare.
** Valuta le espressioni argomento della combinazione.
** Applica la funzione agli argomenti:
*** Se la funzione è primitiva, applichiamo semplicemente la funzione
matematica corrispondente agli argomenti.
*** Se la funzione è composta, valutiamo l’espressione da restituire
della funzione con ogni parametro sostituito dall’argomento
corrispondente.

Per illustrare questo processo, valutiamo la combinazione
dell’applicazione di funzione

[source,javascript]
----
f (5);
----

La valutazione del nome `f` restituisce il corpo della funzione. La
valutazione dell’espressione dell’argomento 5 produce il valore
dell’argomento 5. Ora, recuperiamo l’espressione da restituire di `f`:

[source,javascript]
----
somma_di_quadrati (a + 1, a * 2)
----

in cui sostituiamo il parametro `a` con l’argomento 5:

[source,javascript]
----
somma_di_quadrati (5 + 1, 5 * 2)
----

Pertanto, il problema si riduce alla valutazione di una combinazione di
applicazioni con due argomenti e un’espressione di funzione
`somma_di_quadrati`. La valutazione di questa combinazione comporta tre
sottoproblemi. Dobbiamo valutare l’espressione della funzione per
ottenere l’applicazione della funzione e dobbiamo valutare le
espressioni degli argomenti per ottenere gli argomenti. Ora 5 + 1
produce 6 e 5 * 2 produce 10, quindi dobbiamo applicare la funzione
`somma_di_quadrati` a 6 e 10. Questi valori vengono sostituiti con i
parametri `x` e `y` nell’espressione restituita da `somma_di_quadrati`,
riducendo l’espressione a

[source,javascript]
----
quadrato (6) + quadrato (10)
----

Se usiamo la dichiarazione di `quadrato` una volta, questo si riduce a

[source,javascript]
----
(6 * 6) + quadrato (10)
----

che effettuata la moltiplicazione si riduce a

[source,javascript]
----
36 + quadrato (10)
----

Una seconda applicazione di `quadrato` porta all’espressione composta
per mezzo di operatori

[source,javascript]
----
36 + (10 * 10)
----

che si riduce con la moltiplicazione a

[source,javascript]
----
36 + 100
----

e infine viene valutato l’operatore primitivo di somma applicato agli
argomenti primitivi ottenendo, finalmente

[source,javascript]
----
136
----

Il processo che abbiamo appena descritto si chiama *modello di
sostituzione per l’applicazione delle funzioni*. Può essere usato come
un modello per determinare il significato dell’applicazione delle
funzioni, per quanto riguarda le funzioni di questo capitolo. Tuttavia,
ci sono due punti che dovrebbero essere sottolineati:

* Lo scopo della sostituzione è di aiutarci a pensare all’applicazione
della funzione, non a fornire una descrizione di come funziona davvero
l’interprete. Gli interpreti tipici non valutano le applicazioni delle
funzioni manipolando il testo di una funzione per sostituire i valori
con i parametri. In pratica, la sostituzione viene eseguita utilizzando
un _ambiente locale_ per i parametri. * Ci sono modelli più elaborati di
come funzionano gli interpreti. Il modello di sostituzione è solo il
primo di questi modelli: un modo per iniziare a pensare formalmente al
processo di valutazione. In generale, quando modelliamo i fenomeni
scientifici e ingegneristici, iniziamo con modelli semplificati e
incompleti. Man mano che esaminiamo le cose in modo più dettagliato,
questi semplici modelli diventano inadeguati e devono essere sostituiti
da modelli più raffinati. Il modello di sostituzione non fa eccezione.

*Ordine di applicazione e ordine normale*

Secondo la descrizione della valutazione di cui sopra, l’interprete
valuta prima la funzione e le espressioni degli argomenti, quindi
applica la funzione risultante agli argomenti risultanti. Questo non è
l’unico modo per eseguire la valutazione. Un modello di valutazione
alternativo non valuterebbe gli operandi fino a quando non fossero
necessari i loro valori. Sostituirebbe invece le espressioni degli
argomenti con i parametri fino a quando non ottenesse un’espressione che
coinvolge solo operatori, per poi eseguire la valutazione. Se usassimo
questo metodo, la valutazione di

[source,javascript]
----
f (5)
----

procederebbe secondo la sequenza di espansioni

[source,javascript]
----
somma_di_quadrati (5 + 1, 5 * 2)
----

[source,javascript]
----
quadrato (5 + 1) + quadrato (5 * 2)
----

[source,javascript]
----
(5 + 1) * (5 + 1) + quadrato (5 * 2)
----

[source,javascript]
----
(5 + 1) * (5 + 1) + (5 * 2) * (5 * 2)
----

seguita dalle riduzioni

[source,javascript]
----
6 * (5 + 1) + (5 * 2) * (5 * 2)
----

[source,javascript]
----
6 * 6 + (5 * 2) * (5 * 2)
----

[source,javascript]
----
36 + (5 * 2) * (5 * 2)
----

[source,javascript]
----
36 + 10 * (5 * 2)
----

[source,javascript]
----
36 + 10 * 10
----

[source,javascript]
----
36 + 100
----

[source,javascript]
----
136
----

Ciò fornisce la stessa risposta del nostro modello di valutazione
precedente, ma il processo è diverso. In particolare, le valutazioni di
5 + 1 e 5 * 2 vengono eseguite due volte ciascuna qui, corrispondente
alla riduzione dell’espressione x * x con x sostituita rispettivamente
da 5 + 1 e 5 * 2. Questa alternativa si espande completamente e quindi
riduce il metodo di valutazione è noto come valutazione dell’ordine
normale, in contrasto con la valutazione degli argomenti e quindi
applica il metodo che l’interprete effettivamente utilizza, che è
chiamato valutazione dell’ordine applicativo. Si può dimostrare che, per
le applicazioni di funzioni che possono essere modellate usando la
sostituzione (comprese tutte le funzioni nei primi due capitoli di
questo libro) e che producono valori legittimi, la valutazione
dell’ordine normale e dell’ordine applicativo producono lo stesso
valore.

JavaScript utilizza la valutazione nell’ordine applicativo, in parte a
causa dell’ulteriore efficienza ottenuta dall’evitare valutazioni
multiple di espressioni come quelle illustrate sopra e, in modo più
significativo, perché la valutazione dell’ordine normale diventa molto
più complicata da affrontare quando lasciamo il regno delle procedure
che può essere modellato per sostituzione. D’altra parte, la valutazione
dell’ordine normale può essere uno strumento estremamente prezioso.

==== Epressioni condizionali e predicati

Il potere espressivo della classe di funzioni che possiamo dichiarare a
questo punto è molto limitato, perché non abbiamo modo di fare test ed
eseguire diverse operazioni a seconda del risultato di un test. Ad
esempio, non possiamo dichiarare una funzione che calcola il valore
assoluto di un numero verificando se il numero è negativo o meno e
intraprendendo azioni diverse in ciascun caso in base alla regola

latexmath:[\[|x| = \left\{ \begin{array}{rl}
                  x   & \mbox{se $x \geq 0$} \\
                  -x  & \mbox{altrimenti}
                  \end{array}
                  \right.\]]

Questo costrutto è un’analisi di casi e può essere espresso in
JavaScript usando un’espressione condizionale come segue:

[source,javascript]
----
function valore_assoluto (x) {
    return x >= 0 ? x : -x;
}
----

La forma generale di un’*espressione condizionale*
(ConditionalExpression) è

predicato ? espressione-conseguente : espressione-alternativa

Le espressioni condizionali iniziano con un predicato, ovvero
un’espressione il cui valore viene interpretato come vero o falso. Vero
e falso sono dei valori che indichiamo come valori booleani, in onore di
George Bool che ne ha studiato le proprietà con una teoria matematica.
In JavaScript i valori vero e falso sono nominati, rispettivamente,
`true` e `false`.

Si noti che le espressioni booleane primitive `true` e `false` vengono
valutate, rispettivamente, nei valori booleani `true` e `false`. Il
predicato è seguito da un punto interrogativo, l’espressione
conseguente, i due punti e infine l’espressione alternativa. Per
valutare un’espressione condizionale, l’interprete inizia valutando il
predicato dell’espressione composta. Se il predicato restituisce `true`,
l’interprete valuta l’espressione conseguente. Altrimenti valuta
l’espressione alternativa.

La parola _predicato_ viene utilizzata per funzioni che restituiscono
vero o falso, nonché per espressioni che sono valuate in vero o falso.
La funzione del valore assoluto `valore_assoluto` utilizza il predicato
primitivo `>=`. Questo predicato accetta due numeri come argomenti e
verifica se il primo numero è maggiore o uguale al secondo numero,
restituendo vero o falso di conseguenza.

JavaScript fornisce una serie di predicati primitivi che funzionano in
modo simile a `>=`, inclusi `>`, `<`, `<=` e `===`. Oltre a questi
predicati primitivi, esistono operazioni logiche di composizione che ci
consentono di costruire predicati composti. I tre più utilizzati sono
questi:

* espressione1 *&&* espressione2
** L’interprete valuta espressione1. Se viene valutato falso, il valore
dell’intera espressione è falso e expressione2 non viene valutata. Se
expressione1 restituisce vero, il valore dell’intera espressione è il
valore di expressione2.
* espressione1 *||* expression2
** L’interprete valuta expressione1. Se restituisce vero, il valore
dell’intera espressione è vero e expressione2 non viene valutata. Se
expression1 restituisce falso, il valore dell’intera espressione è il
valore di expressione2.
* *!* espressione
** Il valore dell’espressione è vero quando espressione viene valutata
falsa e falso in caso contrario.

Si noti che `&&` e `||` non vengono valutati come operatori aritmetici
come `+`, perché la loro espressione a destra non viene sempre valutata.
L’operatore `!`, D’altra parte, segue la regola di valutazione già nota.
È un operatore unario, il che significa che accetta solo un argomento,
mentre gli operatori aritmetici incontrati finora sono binari, prendendo
due argomenti. L’operatore `!` precede il suo argomento; lo chiamiamo un
_operatore prefisso_. Un altro operatore prefisso è l’operatore meno
unario, un esempio del quale è l’espressione `-x` della funzione
`valore_assoluto` all’inizio di questa sezione. Come esempio di come
vengono utilizzati questi predicati, la condizione che un numero
latexmath:[$x$] sia compreso nell’intervallo latexmath:[$5 < x < 10$]
può essere espressa come

[source,javascript]
----
x > 5 && x < 10
----

Si noti che l’operatore binario `&&` ha una precedenza inferiore
rispetto agli operatori di confronto `>` e `<`.

Come altro esempio, possiamo dichiarare un predicato per verificare se
un numero non è uguale a un altro numero.

[source,javascript]
----
function non_uguale (x, y) {
    return x > y || x < y;
}
----

oppure

[source,javascript]
----
function non_uguale (x, y) {
    return !(x <= y && x >= y);
}
----

Nota che l’operatore `! ==` quando applicato a due numeri, si comporta
come `non_uguale`.

*Esercizio 1.1* Prima di verificare con l’interprete JavaScript,
determima con le regole di valutazione che hai appreso fin ora il valore
delle seguenti espressioni in JavaScript:

[source,javascript]
----
10;
----

[source,javascript]
----
5 + 3 + 4;
----

[source,javascript]
----
9 - 1;
----

[source,javascript]
----
6 / 2;
----

[source,javascript]
----
2 * 4 + (4 - 6);
----

[source,javascript]
----
const a = 3;
----

[source,javascript]
----
const b = a + 1;
----

[source,javascript]
----
a + b + a * b;
----

[source,javascript]
----
a === b;
----

[source,javascript]
----
b > a && b < a * b 
   ? b : a;
----

[source,javascript]
----
a === 4 ? 6 : b === 4 ? 6 + 7 + a : 25;
----

[source,javascript]
----
2 + (b > a ? b : a);
----

[source,javascript]
----
(a > b
 ? a
 : a < b
   ? b
   : -1)
*
(a + 1);
----


+*In[31]:*+
[source, javascript]
----
// Soluzioni dell'esercizio 1.1
10
12
8
3
6
undefined
undefined
19
false
4
16
6
16
----


+*Out[31]:*+
----
[33m16[39m
----

*Esercizio 1.2* Traduci la seguente espressione matematica
nell’equivalente espressione JavaScript:

latexmath:[\[\frac{5+4+\left(2-\left(3-(6+\frac{4}{5})\right)\right)}{3 (6-2) (2-7)}\]]


+*In[2]:*+
[source, javascript]
----
// Soluzione dell'esercizio 1.2
(5 + 4 + (2 - (3 - (6 + 4 / 5)))) 
/
(3 * (6 - 2) * (2 - 7));
----


+*Out[2]:*+
----
[33m-0.24666666666666667[39m
----

*Esercizio 1.3* Definisci una funzione che accetta tre argomenti
numerici e restituisce la somma dei quadrati dei due numeri più grandi.


+*In[30]:*+
[source, javascript]
----
// Soluzione dell'esercizio 1.3
function esercizio_1_3 (x, y, z) {
    return quadrato (x) + quadrato (y) + quadrato (z) - quadrato ( (x < y ? x : y) < z ? (x < y ? x : y) : z );
}
----

*Esercizio 1.4* Si noti che il nostro modello di valutazione consente
combinazioni mediante applicazioni le cui espressioni di funzioni sono
espressioni composte. Utilizzare questa osservazione per descrivere il
comportamento della seguente funzione:

[source,javascript]
----
function più (a, b) { return a + b; }

function meno (a, b) { return a - b; }

function a_più_valore_assoluto_b (a, b) {
    return (b >= 0 ? più : meno) (a, b);
}
----

Si noti che nell’espressione condizionale, non possiamo usare
direttamente gli operatori + e - invece dei nomi più e meno perché nella
notazione infissa sono consentiti solo simboli operatore nel mezzo, non
espressioni composte.

// Soluzione dell’esercizio 1.4 La valutazione di un’espressione
mediante applicazione di funzione procede come segue:

1.  Valuta l’espressione della funzione della combinazione
dell’applicazione, che determina il nome nella funzione da applicare.
2.  Valuta le espressioni argomento della combinazione.
3.  Valuta l’espressione da restituire della funzione con ogni parametro
sostituito dall’argomento corrispondente.

Pertanto la valutazione dell’espressione dell’applicazione
`a_più_valore_assoluto_b  (5, -4)` valuta `a_più_valore_assoluto_b`
(passo 1), ottenendo la funzione sopra indicata e (passo 2) gli
argomenti sono già valori. Quindi dobbiamo valutare (passo 3)
l’espressione del valore da restituire della funzione, con i parametri
sostituiti dagli argomenti, quindi: `(-4 >= 0 ? più : meno) (5, -4)`.
Con le stesse regole, dobbiamo (passo 1) valutare l’espressione della
funzione, che in questo caso è l’espressione condizionale
`-4 >= 0 ? più : meno`. Poiché il predicato restituisce `false`,
l’espressione della funzione restituisce `meno`. Gli argomenti, di nuovo
(passo 2) sono già valori. Quindi finiamo per valutare (passo 3) il
corpo di `meno` con i parametri `a` e `b` sostituiti rispettivamente da
5 e -4, risultando in 5 - (-4), che infine risulterà nel valore 9.

*Esercizio 1.5* Ben Bitdiddle ha inventato un test per determinare se
l’interprete con cui affrontiamo la programmazione sta usando la
valutazione nell’ordine di applicazione o la valutazione nell’ordine
normale. Dichiara le seguenti due funzioni:

[source,javascript]
----
function p() {
    return p();
}

function test(x, y) {
    return x === 0 ? 0 : y;
}
----

Quindi scrive l’istruzione

[source,javascript]
----
test (0, p ());
----

Quale comportamento osserverà Ben con un interprete che utilizza la
valutazione nell’ordine di applicazione? Quale comportamento osserverà
con un interprete che utilizza la valutazione nell’ordine normale?
Spiega la tua risposta. (Supponiamo che la regola di valutazione per le
espressioni condizionali sia la stessa se l’interprete utilizza l’ordine
normale o applicativo: l’espressione del predicato viene valutata per
prima e il risultato determina se valutare l’espressione conseguente o
alternativa.) Confronta il risultato con la valutazione della funzione
con il tuo interprete.

// Soluzione dell’esercizio 1.5

Nella valutazione nell’ordine di applicazione per valutare l’espressione
`test (0, p ())`, che è un espressione di applicazione di funzione,
dobbiamo valutare le espressioni degli argomenti prima di poter valutare
l’espressione restituita dalla funzione `test`. La valutazione
dell’espressione argomento `p ()` non terminerà: continuerà a valutare
le espressioni di applicazione della funzione `p ()` e quindi la
valutazione di `test (0, p ())` non produrrà un valore legittimo.
Normalmente l’interprete riconosce il caso e termina la valutazione
notiicando un errore. Nella valutazione nell’ordine normale, invece
parte, il test dell’applicazione di funzione (0, p ()) valuterà
immediatamente l’espressione restituita da `test`: `x === 0 ? 0: y` dopo
aver sostituito il parametro `x` con 0 e `y` con `p ()`. Il risultato
della sostituzione sarebbe `0 === 0? 0: p ()`. La valutazione del
predicato `0 === 0` risulta vera e quindi l’espressione condizionale
restituisce 0, senza che sia necessario valutare `p ()`.

==== Esempio: radici quadrate con il metodo di Newton

Le funzioni, come introdotto sopra, sono molto simili alle normali
funzioni matematiche che si studiano nel quinto anno. Specificano un
valore determinato da uno o più parametri. Ma c’è una differenza
importante tra le funzioni matematiche e le funzioni del computer. Le
funzioni del computer devono essere _efficaci_, devono cioè fornire un
valore. Dovrebbero essere anche efficienti, cioè fornire un valore in un
tempo ragionevole.

Ad esempio, considera il problema del calcolo delle radici quadrate.
Possiamo definire la funzione radice quadrata come

latexmath:[\[\sqrt{x} = \text{ quel numero }y\text{ tale che } y \geq 0\text{ e }
                y^2 = x\]]

Questo descrive una funzione matematica perfettamente legittima.
Potremmo usare la definizione per riconoscere se un numero è la radice
quadrata di un altro o per dedurre delle proposizioni vere sulle radici
quadrate in generale. D’altra parte, la definizione non descrive una
funzione del computer. In effetti, non ci dice quasi nulla su come
trovare effettivamente la radice quadrata di un dato numero. Non aiuterà
le cose a riformulare questa definizione in pseudo-JavaScript:

[source,javascript]
----
function sqrt (x) {
    return y con y> = 0 &&
                      quadrato (y) === x;
}
----

Il contrasto tra la funzione matematica e quella del computer riflette
la distinzione generale tra la descrizione delle proprietà delle cose e
la descrizione di come fare le cose, o, come viene talvolta indicato, la
distinzione tra *conoscenza dichiarativa* e *conoscenza imperativa*. In
matematica di solito ci occupiamo di descrizioni dichiarative (cos’è),
mentre in informatica ci occupiamo di solito di descrizioni imperative
(come).

Come si calcolano le radici quadrate? Il modo più comune è usare il
metodo di Newton per approssimazioni successive, che dice che ogni volta
che abbiamo una supposizione latexmath:[$y$] per il valore della radice
quadrata di un numero latexmath:[$x$], possiamo eseguire una semplice
manipolazione per ottenere una stima migliore (più vicina alla radice
quadrata) facendo la media di latexmath:[$y$] con
latexmath:[$\frac x y$]. [2] Ad esempio, possiamo calcolare la radice
quadrata di 2 come segue. Supponiamo che la nostra ipotesi iniziale sia
1:

[width="100%",cols="^10%,^14%,^76%",options="header",]
|=======================================================================
|Stima |Quoziente |Valor medio
|latexmath:[$1$] |latexmath:[$\frac 2 1$]
|latexmath:[$\frac{1 + 2}2=\frac 3 2=1.5$]

|latexmath:[$1.5$] |latexmath:[$\frac 4 3$]
|latexmath:[$\frac 1 2\left(\frac 3 2 + \frac 4 3\right)=\frac 17 12 \approx 1.4167$]

|latexmath:[$1.4167$] |latexmath:[$\frac{24}{17}$]
|latexmath:[$\frac 1 2\left(\frac{17}{12}+\frac{24}{17}\right)=\frac{577}{408}\approx 1.4142$]

|latexmath:[$1.4142$] |latexmath:[$\cdots$] |latexmath:[$\cdots$]
|=======================================================================

Continuando questo processo, otteniamo approssimazioni sempre migliori
alla radice quadrata.

Ora formalizziamo il processo in termini di funzioni. Iniziamo con un
valore per il radicando (il numero di cui stiamo provando a calcolare la
radice quadrata) e un valore per la stima iniziale. Se la stima iniziale
è abbastanza buona per i nostri scopi, abbiamo finito; in caso
contrario, dobbiamo ripetere il processo con una stima migliore.
Scriviamo questa strategia di base come funzione:

[source,javascript]
----
function radq_iter (stima, x) {
    return suff_accurata (stima, x)
           ? stima
           : radq_iter (migliora (stima, x), x);
}
----

Una stima viene migliorata facendo una media tra il quoziente del
radicando e la vecchia stima:

[source,javascript]
----
function migliora (stima, x) {
    return valor_medio (stima, x / stima);
}
----

dove

[source,javascript]
----
function valor_medio (x, y) {
    return (x + y) / 2;
}
----

Dobbiamo anche dire cosa intendiamo con stima _sufficientemente
accurata_, che codifichiamo con il predicato `suff_accurata`. Un’idea è
quella di migliorare il risultato della nostra funzione fino a quando il
suo quadrato differisca dal radicando per una tolleranza inferiore a una
predeterminata soglia (qui 0,001):

[source,javascript]
----
function suff_accurata (stima, x) {
    return valore_assoluto (quadrato (stima) - x) < 0.001;
}
----

Infine, abbiamo bisogno di un modo per iniziare. Ad esempio, possiamo
sempre supporre che la radice quadrata di qualsiasi numero sia 1:

[source,javascript]
----
function radq (x) {
    return radq_iter (1, x);
}
----

Se scriviamo queste dichiarazioni all’interprete, possiamo usare radq
così come possiamo usare qualsiasi funzione:


+*In[2]:*+
[source, javascript]
----
function radq_iter (stima, x) {
    return suff_accurata (stima, x)
           ? stima
           : radq_iter (migliora (stima, x), x);
}

function migliora (stima, x) {
    return valor_medio (stima, x / stima);
}

function valor_medio (x, y) {
    return (x + y) / 2;
}

function suff_accurata (stima, x) {
    return valore_assoluto (quadrato (stima) - x) < 0.001;
}

function radq (x) {
    return radq_iter (1, x);
}

function valore_assoluto (x) {
    return x >= 0 ? x : -x;
}

function quadrato (x) {
    return x * x;
}
----


+*In[3]:*+
[source, javascript]
----
radq (9);
----


+*Out[3]:*+
----
[33m3.00009155413138[39m
----


+*In[4]:*+
[source, javascript]
----
radq (100 + 37);
----


+*Out[4]:*+
----
[33m11.704699917758145[39m
----


+*In[5]:*+
[source, javascript]
----
radq (radq (2) + radq (3));
----


+*Out[5]:*+
----
[33m1.7739279023207892[39m
----


+*In[6]:*+
[source, javascript]
----
quadrato (radq (1000));
----


+*Out[6]:*+
----
[33m1000.000369924366[39m
----

Il programma `radq` fornisce l’idea che anche il semplice linguaggio
funzionale che abbiamo introdotto finora sia sufficiente per scrivere
qualsiasi programma puramente numerico come quelli che si potrebbero
scrivere in altri linguaggi come il C o Pascal. Ciò potrebbe sembrare
sorprendente, dal momento che non abbiamo ancora introdotto i costrutti
iterativi (cicli o loop) che istruiscono il computer a fare qualcosa più
e più volte. La funzione `radq_iter`, d’altra parte, dimostra come
l’iterazione può essere realizzata senza ricorrere a nessun costrutto
speciale diverso dalla normale capacità di chiamare una funzione.

*Esercizio 1.6* Alyssa P. Hacker non ama la sintassi delle espressioni
condizionali, che coinvolgono i caratteri *?* e *:*. «Perché non posso
semplicemente dichiarare una normale funzione condizionale la cui
applicazione funziona esattamente come le espressioni condizionali?» lei
chiede. La sua amica Eva Lu Ator afferma che questo può davvero essere
fatto e dichiara una funzione condizionale come segue:

[source,javascript]
----
function condizionale (predicato, clausola_allora, clausola_altrimenti) {
    return predicato ? clausola_allora: clausola_altrimenti;
}
----

Eva dimostra il programma per Alyssa:

[source,javascript]
----
condizionale (2 === 3, 0, 5);
----

viene valutato come previsto, a 5, e

[source,javascript]
----
condizionale (1 === 1, 0, 5);
----

viene valutato come previsto, a 0. Felicissima, Alyssa usa il
condizionale per riscrivere il programma per il calcolo della radice
quadrata:

[source,javascript]
----
function radq_iter (stima, x) {
    return condizionale (suff_accurata (stima, x),
                       stima,
                       radq_iter (migliora (stima, x),
                                 x));
}
----

Cosa succede quando Alyssa tenta di usarlo per calcolare le radici
quadrate? Spiegarlo.

// Soluzione esercizio 1.6

Qualsiasi chiamata di `radq_iter` porta immediatamente a un ciclo
infinito. La ragione di ciò è la valutazione nell’ordine applicativo. La
valutazione dell’espressione da restituire di `radq_iter` deve prima
valutare i suoi argomenti, inclusa la chiamata ricorsiva di `radq_iter`,
indipendentemente dal fatto che il predicato sia valutato vero o falso.
Lo stesso ovviamente accade con la chiamata ricorsiva, e quindi la
funzione condizionale non viene mai effettivamente applicata.

*Esercizio 1.7* Il controllo `suff_accurata` utilizzato nel calcolo
delle radici quadrate non sarà molto efficace per trovare le radici
quadrate di numeri molto piccoli. Inoltre, nei computer reali, le
operazioni aritmetiche vengono quasi sempre eseguite con una precisione
limitata. Questo rende il nostro controllo inadeguato per numeri molto
grandi. Spiega queste affermazioni, con esempi che mostrano come il test
fallisce per numeri piccoli e grandi. Una strategia alternativa per
implementare `suff_accurata` è guardare come le stime cambiano da
un’iterazione alla successiva e fermarsi quando il cambiamento è una
frazione molto piccola della stima. Progettare una funzione per il
calcolo della radice quadrata che utilizza questo tipo di controllo di
terminazione. Funziona meglio?


+*In[ ]:*+
[source, javascript]
----
// Soluzione esercizio 1.7

/*
La tolleranza assoluta di 0,001 è troppo grande quando si calcola la radice quadrata di un valore piccolo.
Ad esempio, radq (0,0001) genera 0,03230844833048122 anziché il valore previsto 0,01 con
un errore percentuale superiore al 200%.
D'altra parte, per valori molto grandi, gli errori di arrotondamento potrebbero impedire la terminazione del processo.
Il seguente programma allevia il problema considerando l'errore relativo in sostituzione di quello assoluto.
Si verifichi se si creano soluzioni mal gestite se si prova a calcolare la radice quadrata di zero.
*/

const soglia_tolleranza = 0.01;
function radq_iter (stima, x) {
    return errore_relativo (stima, migliora (stima, x)) < soglia_tolleranza
           ? stima
           : radq_iter (migliora (stima, x), x);
}

function migliora (stima, x) {
    return valor_medio (stima, x / stima);
}

function valor_medio (x, y) {
    return (x + y) / 2;
}

function suff_accurata (stima, x) {
    return errore_relativo (stima, migliora (stima, x)) < soglia_tolleranza;
}

function errore_relativo (stima, riferimento) {
    return valore_assoluto ((stima- riferimento) / riferimento)
}

function radq (x) {
    return radq_iter (1, x);
}

function valore_assoluto (x) {
    return x >= 0 ? x : -x;
}

function quadrato (x) {
    return x * x;
}
----

*Esercizio 1.8* Il metodo di Newton per le radici dei cubi si basa sul
fatto che se latexmath:[$y$] è un’approssimazione alla radice del cubo
di latexmath:[$x$], allora una migliore approssimazione è data dal
valore

latexmath:[\[\frac{x/y^{2}+2y} {3}\]]

Si utilizzi questa formula per implementare una funzione `radc` per il
calcolo della radice cubica analoga alla funzione `radq`.


+*In[82]:*+
[source, javascript]
----
// Soluzione dell'esercizio 1.8

function suff_accurata (stima, x) {
    return valore_assoluto (cubo (stima) - x) < 0.001;
}

function migliora (stima, x) {
    return (x / quadrato (stima) + 2 * stima) / 3;
}

function radc_iter (stima, x) {
    return suff_accurata (stima, x)
               ? stima
               : radc_iter (migliora (stima, x), x);
}

function radc (x) {
    return radc_iter (1, x);
}

function cubo (x) {
    return quadrato (x) * x;
}
----

1.1.8 Functions as Black-Box Abstractions

The function sqrt is our first example of a process defined by a set of
mutually defined functions. Notice that the declaration of sqrt_iter is
recursive; that is, the function is defined in terms of itself. The idea
of being able to define a function in terms of itself may be disturbing;
it may seem unclear how such a circular definition could make sense at
all, much less specify a well-defined process to be carried out by a
computer. This will be addressed more carefully in section 1.2. But
first let’s consider some other important points illustrated by the sqrt
example.

Observe that the problem of computing square roots breaks up naturally
into a number of subproblems: how to tell whether a guess is good
enough, how to improve a guess, and so on. Each of these tasks is
accomplished by a separate function. The entire sqrt program can be
viewed as a cluster of functions (shown in Figure 1.2) that mirrors the
decomposition of the problem into subproblems.

Figure 1.2 Functional decomposition of the sqrt program.

The importance of this decomposition strategy is not simply that one is
dividing the program into parts. After all, we could take any large
program and divide it into parts—the first ten lines, the next ten
lines, the next ten lines, and so on. Rather, it is crucial that each
function accomplishes an identifiable task that can be used as a module
in defining other functions. For example, when we define the good_enough
function in terms of square, we are able to regard the square function
as a black box. We are not at that moment concerned with how the
function computes its result, only with the fact that it computes the
square. The details of how the square is computed can be suppressed, to
be considered at a later time. Indeed, as far as the good_enough
function is concerned, square is not quite a function but rather an
abstraction of a function, a so-called functional abstraction. At this
level of abstraction, any function that computes the square is equally
good.

Thus, considering only the values they return, the following two
functions squaring a number should be indistinguishable. Each takes a
numerical argument and produces the square of that number as the value.

 function square(x) \{ return x * x; } function square(x) \{ return
math_exp(double(math_log(x))); } function double(x) \{ return x + x; }

So a function should be able to suppress detail. The users of the
function may not have written the function themselves, but may have
obtained it from another programmer as a black box. A user should not
need to know how the function is implemented in order to use it.

Local names One detail of a function’s implementation that should not
matter to the user of the function is the implementer’s choice of names
for the function’s parameters. Thus, the following functions should not
be distinguishable:

 function square(x) \{ return x * x; } function square(y) \{ return y *
y; }

This principle—that the meaning of a function should be independent of
the parameter names used by its author—seems on the surface to be
self-evident, but its consequences are profound. The simplest
consequence is that the parameter names of a function must be local to
the body of the function. For example, we used square in the declaration
of good_enough in our square-root function :

 function good_enough(guess, x) \{ return abs(square(guess) - x) <
0.001; }

The intention of the author of good_enough is to determine if the square
of the first argument is within a given tolerance of the second
argument. We see that the author of good_enough used the name guess to
refer to the first argument and x to refer to the second argument. The
argument of square is guess. If the author of square used x (as above)
to refer to that argument, we see that the x in good_enough must be a
different x than the one in square. Running the function square must not
affect the value of x that is used by good_enough, because that value of
x may be needed by good_enough after square is done computing.

If the parameters were not local to the bodies of their respective
functions, then the parameter x in square could be confused with the
parameter x in good_enough, and the behavior of good_enough would depend
upon which version of square we used. Thus, square would not be the
black box we desired.

A parameter of a function has a very special role in the function
declaration, in that it doesn’t matter what name the parameter has. Such
a name is called bound, and we say that the function declaration binds
its parameters. The meaning of a function declaration is unchanged if a
bound name is consistently renamed throughout the declaration.[2] If a
name is not bound, we say that it is free. The set of expressions for
which a binding declares a name is called the scope of that name. In a
function declaration, the bound names declared as the parameters of the
function have the body of the function as their scope.

In the declaration of good_enough above, guess and x are bound names but
abs, and square are free. The meaning of good_enough should be
independent of the names we choose for guess and x so long as they are
distinct and different from abs, and square. (If we renamed guess to abs
we would have introduced a bug by capturing the name abs. It would have
changed from free to bound.) The meaning of good_enough is not
independent of the choice of its free names, however. It surely depends
upon the fact (external to this declaration) that the symbol abs names a
function for computing the absolute value of a number. The JavaScript
function good_enough will compute a different mathematical function if
we substitute math_cos (JavaScript’s cosine function) for abs in its
declaration.

Internal declarations and block structure We have one kind of name
isolation available to us so far: The parameters of a function are local
to the body of the function. The square-root program illustrates another
way in which we would like to control the use of names. The existing
program consists of separate functions :

 function sqrt(x) \{ return sqrt_iter(1.0, x); } function
sqrt_iter(guess, x) \{ return good_enough(guess, x) ? guess :
sqrt_iter(improve(guess, x), x); } function good_enough(guess, x) \{
return abs(square(guess) - x) < 0.001; } function improve(guess, x) \{
return average(guess, x / guess); }

The problem with this program is that the only function that is
important to users of sqrt is sqrt. The other functions (sqrt_iter,
good_enough, and improve) only clutter up their minds. They may not
declare any other function called good_enough as part of another program
to work together with the square-root program, because sqrt needs it.
The problem is especially severe in the construction of large systems by
many separate programmers. For example, in the construction of a large
library of numerical functions, many numerical functions are computed as
successive approximations and thus might have functions named
good_enough and improve as auxiliary functions. We would like to
localize the subfunctions, hiding them inside sqrt so that sqrt could
coexist with other successive approximations, each having its own
private good_enough function. To make this possible, we allow a function
to have internal declarations that are local to that function. For
example, in the square-root problem we can write

 function sqrt(x) \{ function good_enough(guess, x) \{ return
abs(square(guess) - x) < 0.001; } function improve(guess, x) \{ return
average(guess, x / guess); } function sqrt_iter(guess, x) \{ return
good_enough(guess, x) ? guess : sqrt_iter(improve(guess, x), x); }
return sqrt_iter(1.0, x); }

The body of a function—a statement enclosed in curly braces—is called a
block. Function declarations nested inside a block are local to that
block. This block structure is basically the right solution to the
simplest name-packaging problem. But there is a better idea lurking
here. In addition to internalizing the declarations of the auxiliary
functions, we can simplify them. Since x is bound in the declaration of
sqrt, the functions good_enough, improve, and sqrt_iter, which are
defined internally to sqrt, are in the scope of x. Thus, it is not
necessary to pass x explicitly to each of these functions. Instead, we
allow x to be a free name in the internal declarations, as shown below.
Then x gets its value from the argument with which the enclosing
function sqrt is called. This discipline is called lexical scoping.

 function sqrt(x) \{ function good_enough(guess) \{ return
abs(square(guess) - x) < 0.001; } function improve(guess) \{ return
average(guess, x / guess); } function sqrt_iter(guess) \{ return
good_enough(guess) ? guess : sqrt_iter(improve(guess)); } return
sqrt_iter(1.0); }

We will use block structure extensively to help us break up large
programs into tractable pieces.[4] The idea of block structure
originated with the programming language Algol 60. It appears in most
advanced programming languages and is an important tool for helping to
organize the construction of large programs.

==== Funzioni come astrazioni nella forma di una scatola nera

La funzione `radq` è il nostro primo esempio di un processo definito da
un insieme di funzioni che si definiscono l’una con l’altra. Si noti che
la dichiarazione di `radq_iter` è ricorsiva; la funzione cioè definita
in termini di se stessa. L’idea di poter definire una funzione in
termini di se stessa può essere inquietante; potrebbe non essere chiaro
come una definizione circolare del genere possa avere senso, tanto meno
specificare un processo ben definito che deve essere eseguito da un
computer.

Osserva che il problema del calcolo delle radici quadrate si scompone
naturalmente in una serie di sottoproblemi: come capire se una stima è
abbastanza accurata, come migliorare una stima e così via. Ognuna di
queste attività è svolta da una funzione separata. L’intero programma
`radq` può essere visualizzato come un raggruppamento di funzioni
(mostrato nella Figura 1.2) che rispecchia la decomposizione del
problema in sottoproblemi.

`radq                |            radq_iter            /       \   suff_accurata   migliora   /          /            \ quadrato valore_assoluto valor_medio`
Figura 1.2 Decomposizione funzionale del programma radq.

L’importanza di questa strategia di decomposizione non è semplicemente
quella di dividere il programma in parti. Dopotutto, potremmo prendere
qualsiasi programma di grandi dimensioni e dividerlo in parti: le prime
dieci righe, le successive dieci righe, le successive dieci righe e così
via. Piuttosto, è cruciale che ogni funzione compia un compito
identificabile che può essere usato come modulo nella definizione di
altre funzioni. Ad esempio, quando definiamo la funzione suff_accurata
in termini di quadrato, siamo in grado di considerare la funzione
quadrata come una scatola nera. In quel momento non ci occupiamo di come
la funzione calcola il suo risultato, ma solo del fatto che calcola il
quadrato. I dettagli di come viene calcolato il quadrato possono essere
soppressi, per essere considerati in un secondo momento. In effetti, per
quanto riguarda la funzione suff_accurata, il quadrato non è proprio una
funzione ma piuttosto un’astrazione di una funzione, una cosiddetta
astrazione funzionale. A questo livello di astrazione, qualsiasi
funzione che calcola il quadrato è ugualmente buona.

Pertanto, considerando solo i valori che restituiscono, le seguenti due
funzioni che quadrano un numero dovrebbero essere indistinguibili.
Ognuno accetta un argomento numerico e produce il quadrato di quel
numero come valore.

[source,javascript]
----
function quadrato (x) {
    ritorna x * x;
}

function quadrato (x) {
    return Math.exp (doppio (Math.log (x)));
}

function doppio (x) {
    return x + x;
}
----

Quindi una funzione dovrebbe essere in grado di sopprimere i dettagli.
Gli utenti della funzione potrebbero non aver scritto la funzione da
soli, ma potrebbero averla ottenuta da un altro programmatore come una
scatola nera. Un utente non dovrebbe avere bisogno di sapere come viene
implementata la funzione per poterla utilizzare.

*Nomi locali*

Un dettaglio dell’implementazione di una funzione che non dovrebbe
interessare all’utente della funzione è la scelta dei nomi da parte
dell’implementatore per i parametri della funzione. Pertanto, le
seguenti funzioni non dovrebbero essere distinguibili:

[source,javascript]
----
function quadrato (x) {
    return x * x;
}

function quadrato (y) {
    return y * y;
}
----

Questo principio - che il significato di una funzione dovrebbe essere
indipendente dai nomi dei parametri usati dal suo autore - sembra in
superficie evidente, ma le sue conseguenze sono profonde. La conseguenza
più semplice è che i nomi dei parametri di una funzione devono essere
locali al corpo della funzione. Ad esempio, abbiamo usato abbastanza
quadrato nella dichiarazione di suff_accurata nella nostra funzione
radice quadrata:

 abbastanza buono _(indovinate, x) \{     ritorno abs (quadrato
(ipotesi) - x) <0,001; }                                                
L’intenzione dell’autore del bene_ è di determinare se il quadrato del
primo argomento rientri in una determinata tolleranza del secondo
argomento. Vediamo che l’autore del bene _ha usato abbastanza il nome
ipotesi per riferirsi al primo argomento e x per riferirsi al secondo
argomento. L’argomento di quadrato è indovinare. Se l’autore di square
ha usato x (come sopra) per fare riferimento a tale argomento, vediamo
che la x in good_ abbastanza deve essere una x diversa da quella in
square. L’esecuzione del quadratino delle funzioni non deve influire sul
valore di x che viene utilizzato da _abbastanza bene, perché quel valore
di x può essere necessario da <<> bene dopo che il calcolo del quadrato
è terminato.

Se i parametri non fossero locali ai corpi delle loro rispettive
funzioni, allora il parametro x in square potrebbe essere confuso con il
parametro x in good_ abbastanza, e il comportamento di good _abbastanza
dipenderebbe da quale versione di square abbiamo usato. Pertanto,
quadrato non sarebbe la scatola nera che desideravamo.

Un parametro di una funzione ha un ruolo molto speciale nella
dichiarazione di funzione, in quanto non ha importanza il nome del
parametro. Tale nome è chiamato associato e diciamo che la dichiarazione
di funzione lega i suoi parametri. Il significato di una dichiarazione
di funzione rimane invariato se un nome associato viene costantemente
rinominato in tutta la dichiarazione. [2] Se un nome non è associato,
diciamo che è gratuito. L’insieme di espressioni per cui un’associazione
dichiara un nome è chiamato ambito di quel nome. In una dichiarazione di
funzione, i nomi associati dichiarati come parametri della funzione
hanno il corpo della funzione come ambito.

Nella dichiarazione del bene_ abbastanza sopra, indovina e x sono nomi
associati ma abs e quadrato sono liberi. Il significato del bene
_dovrebbe essere indipendente dai nomi che scegliamo per ipotesi e x
fintanto che sono distinti e diversi dagli addominali e quadrati. (Se
rinominassimo ipotesi in abs avremmo introdotto un bug catturando il
nome abs. Sarebbe cambiato da libero a limite.) Il significato di buono_
non è indipendente dalla scelta dei suoi nomi liberi, tuttavia. Dipende
sicuramente dal fatto (esterno a questa dichiarazione) che il simbolo
abs nomina una funzione per calcolare il valore assoluto di un numero.
La funzione JavaScript abbastanza buona _calcolerà una diversa funzione
matematica se sostituiamo la matematica_ cos (funzione coseno di
JavaScript) con gli addominali nella sua dichiarazione.

Dichiarazioni interne e struttura a blocchi Finora abbiamo un tipo di
isolamento del nome a nostra disposizione: i parametri di una funzione
sono locali al corpo della funzione. Il programma con radice quadrata
illustra un altro modo in cui vorremmo controllare l’uso dei nomi. Il
programma esistente è costituito da funzioni separate:

 funzione sqrt (x) \{     return sqrt _iter (1.0, x); } funzione sqrt_
iter (indovina, x) \{     restituisce abbastanza _abbastanza (indovina,
x)            ? indovina            : sqrt_ iter (migliora (indovina,
x), x); } abbastanza buono _(indovinate, x) \{     ritorno abs (quadrato
(ipotesi) - x) <0,001; } funzione migliorare (indovina, x) \{     media
di ritorno (indovina, x / indovina); }
                                                Il problema con questo
programma è che l’unica funzione importante per gli utenti di sqrt è
sqrt. Le altre funzioni (sqrt_ iter, good _abbastanza e migliorano)
ingombrano solo le loro menti. Non possono dichiarare qualsiasi altra
funzione chiamata abbastanza bene_ come parte di un altro programma per
collaborare con il programma radice quadrata, perché sqrt ne ha bisogno.
Il problema è particolarmente grave nella costruzione di grandi sistemi
da parte di molti programmatori separati. Ad esempio, nella costruzione
di una vasta libreria di funzioni numeriche, molte funzioni numeriche
vengono calcolate come approssimazioni successive e quindi potrebbero
avere funzioni nominate abbastanza buone _e migliorare come funzioni
ausiliarie. Vorremmo localizzare le sottofunzioni, nascondendole
all’interno di sqrt in modo che sqrt possa coesistere con altre
approssimazioni successive, ognuna con il proprio bene privato_ funzione
sufficiente. Per renderlo possibile, consentiamo a una funzione di avere
dichiarazioni interne locali a tale funzione. Ad esempio, nel problema
della radice quadrata possiamo scrivere

 funzione sqrt (x) \{     abbastanza buono _(indovinate, x) \{
        ritorno abs (quadrato (ipotesi) - x) <0,001;     }     funzione
migliorare (indovina, x) \{         media di ritorno (indovina, x /
indovina);     }     funzione sqrt_ iter (indovina, x) \{
        restituisce abbastanza _abbastanza (indovina, x)
                   ? indovina                    : sqrt_ iter (migliora
(indovina, x), x);     }    return sqrt _iter (1.0, x); }
                                                    Il corpo di una
funzione - un’istruzione racchiusa tra parentesi graffe - è chiamato
blocco. Le dichiarazioni di funzione nidificate all’interno di un blocco
sono locali per quel blocco. Questa struttura a blocchi è
sostanzialmente la giusta soluzione al più semplice problema di
impacchettamento del nome. Ma c’è un’idea migliore in agguato qui. Oltre
a internalizzare le dichiarazioni delle funzioni ausiliarie, possiamo
semplificarle. Poiché x è associato nella dichiarazione di sqrt, le
funzioni_ abbastanza buone, migliorate e sqrt _iter, che sono definite
internamente a sqrt, rientrano nell’ambito di x. Pertanto, non è
necessario passare x in modo esplicito a ciascuna di queste funzioni.
Invece, consentiamo a x di essere un nome libero nelle dichiarazioni
interne, come mostrato di seguito. Quindi x ottiene il suo valore
dall’argomento con cui viene chiamata la funzione che racchiude sqrt.
Questa disciplina si chiama scoping lessicale.      funzione sqrt (x) \{
    abbastanza buono_ (indovina) \{         ritorno abs (quadrato
(ipotesi) - x) <0,001;     }     funzione migliorare (indovinare) \{
        media di ritorno (indovina, x / indovina);     }     function
sqrt _iter (indovina) \{         restituisce abbastanza_ abbastanza
(indovina)                ? indovina                : sqrt <_> iter
(migliora (indovina));    }    return sqrt_iter (1.0); }
                                                    Useremo ampiamente
la struttura a blocchi per aiutarci a suddividere grandi programmi in
pezzi trattabili. [4] L’idea della struttura a blocchi è nata con il
linguaggio di programmazione Algol 60. Appare nella maggior parte dei
linguaggi di programmazione avanzati ed è uno strumento importante per
aiutare a organizzare la costruzione di programmi di grandi dimensioni.
