[[building-abstractions-with-data]]
== Costruire astrazioni con i dati

[quote, Hermann Weyl, The Mathematical Way of Thinking. 1940.]
____
Veniamo ora al passaggio decisivo dell'astrazione matematica: dimentichiamo il significato dei simboli. ... [Il matematico] non deve essere inattivo; sono molte le operazioni che può compiere con questi simboli, senza mai dover guardare le cose che rappresentano.
____
//We now come to the decisive step of mathematical abstraction: we forget about what the symbols stand for. … [The mathematician] need not be idle; there are many operations which he may carry out with these symbols, without ever having to look at the things they stand for.


//We concentrated in chapter 1 on computational processes and on the role of functions in program design. We saw how to use primitive data (numbers) and primitive operations (arithmetic operations), how to combine functions to form compound functions through composition, conditionals, and the use of parameters, and how to abstract processes by using function declarations. We saw that a function can be regarded as a pattern for the local evolution of a process, and we classified, reasoned about, and performed simple algorithmic analyses of some common patterns for processes as embodied in functions. We also saw that higher-order functions enhance the power of our language by enabling us to manipulate, and thereby to reason in terms of, general methods of computation. This is much of the essence of programming.
Ci siamo concentrati nel capitolo 1 sui processi computazionali e sul ruolo delle funzioni nella progettazione di programmi. Abbiamo visto come usare dati primitivi (numeri) e operazioni primitive (operazioni aritmetiche), come combinare funzioni per formare funzioni composte attraverso composizione, condizionali e l'uso di parametri e come astrarre processi usando dichiarazioni di funzione. Abbiamo visto che una funzione può essere considerata come un modello per l'evoluzione locale di un processo e abbiamo classificato, ragionato ed eseguito semplici analisi algoritmiche di alcuni modelli comuni per processi incorporati nelle funzioni. Abbiamo anche visto che le funzioni di ordine superiore aumentano la potenza del nostro linguaggio permettendoci di manipolare, e quindi di ragionare in termini di metodi generali di calcolo. Questa è gran parte dell'essenza della programmazione.

//In this chapter we are going to look at more complex data. All the functions in chapter 1 operate on simple numerical data, and simple data are not sufficient for many of the problems we wish to address using computation. Programs are typically designed to model complex phenomena, and more often than not one must construct computational objects that have several parts in order to model real-world phenomena that have several aspects. Thus, whereas our focus in chapter 1 was on building abstractions by combining functions to form compound functions, we turn in this chapter to another key aspect of any programming language: the means it provides for building abstractions by combining data objects to form _compound data_.
In questo capitolo esamineremo dati più complessi. Tutte le funzioni del capitolo 1 operano su dati numerici semplici e dati semplici non sono sufficienti per molti dei problemi che desideriamo affrontare utilizzando il calcolo. I programmi sono tipicamente progettati per modellare fenomeni complessi e il più delle volte si devono costruire oggetti computazionali che hanno più parti per modellare fenomeni del mondo reale che hanno diversi aspetti. Pertanto, mentre il nostro focus nel capitolo 1 era sulla costruzione di astrazioni combinando funzioni per formare funzioni composte, in questo capitolo ci rivolgiamo a un altro aspetto chiave di qualsiasi linguaggio di programmazione: i mezzi che fornisce per costruire astrazioni combinando oggetti dati per formare _dati composti_.

//Why do we want compound data in a programming language? For the same reasons that we want compound functions: to elevate the conceptual level at which we can design our programs, to increase the modularity of our designs, and to enhance the expressive power of our language. Just as the ability to declare functions enables us to deal with processes at a higher conceptual level than that of the primitive operations of the language, the ability to construct compound data objects enables us to deal with data at a higher conceptual level than that of the primitive data objects of the language.
Perché vogliamo dati composti in un linguaggio di programmazione? Per gli stessi motivi per cui vogliamo funzioni composte: elevare il livello concettuale al quale possiamo progettare i nostri programmi, aumentare la modularità dei nostri progetti e migliorare la potenza espressiva del nostro linguaggio. Proprio come la capacità di dichiarare funzioni ci consente di trattare i processi a un livello concettuale più alto di quello delle operazioni primitive del linguaggio, la capacità di costruire oggetti di dati composti ci permette di trattare i dati a un livello concettuale più alto di quello oggetti dati primitivi del linguaggio.

//Consider the task of designing a system to perform arithmetic with rational numbers. We could imagine an operation `add_rat` that takes two rational numbers and produces their sum. In terms of simple data, a rational number can be thought of as two integers: a numerator and a denominator. Thus, we could design a program in which each rational number would be represented by two integers (a numerator and a denominator) and where `add_rat` would be implemented by two functions (one producing the numerator of the sum and one producing the denominator). But this would be awkward, because we would then need to explicitly keep track of which numerators corresponded to which denominators. In a system intended to perform many operations on many rational numbers, such bookkeeping details would clutter the programs substantially, to say nothing of what they would do to our minds. It would be much better if we could ``glue together'' a numerator and denominator to form a pair—a _compound data object_—that our programs could manipulate in a way that would be consistent with regarding a rational number as a single conceptual unit.
Considera il compito di progettare un sistema per eseguire operazioni aritmetiche con numeri razionali. Potremmo immaginare un'operazione `add_rat` che prende due numeri razionali e produce la loro somma. In termini di dati semplici, un numero razionale può essere pensato come due numeri interi: un numeratore e un denominatore. Quindi, potremmo progettare un programma in cui ogni numero razionale sarebbe rappresentato da due numeri interi (un numeratore e un denominatore) e dove `add_rat` sarebbe implementato da due funzioni (una che produce il numeratore della somma e una che produce il denominatore) . Ma questo sarebbe imbarazzante, perché avremmo quindi bisogno di tenere esplicitamente traccia di quali numeratori corrispondevano a quali denominatori. In un sistema inteso a eseguire molte operazioni su molti numeri razionali, tali dettagli contabili ingombrerebbero sostanzialmente i programmi, per non parlare di ciò che farebbero alla nostra mente. Sarebbe molto meglio se potessimo "incollare" un numeratore e un denominatore per formare una coppia - un _oggetto dati composto_ - che i nostri programmi potrebbero manipolare in un modo coerente con il considerare un numero razionale come una singola unità concettuale .

//The use of compound data also enables us to increase the modularity of our programs. If we can manipulate rational numbers directly as objects in their own right, then we can separate the part of our program that deals with rational numbers per se from the details of how rational numbers may be represented as pairs of integers. The general technique of isolating the parts of a program that deal with how data objects are represented from the parts of a program that deal with how data objects are used is a powerful design methodology called . We will see how data abstraction makes programs much easier to design, maintain, and modify.
L'utilizzo di dati composti ci consente inoltre di aumentare la modularità dei nostri programmi. Se possiamo manipolare i numeri razionali direttamente come oggetti a sé stanti, allora possiamo separare la parte del nostro programma che tratta i numeri razionali di per sé dai dettagli di come i numeri razionali possono essere rappresentati come coppie di interi. La tecnica generale per isolare le parti di un programma che si occupano del modo in cui vengono rappresentati gli oggetti di dati dalle parti di un programma che si occupano del modo in cui vengono utilizzati gli oggetti di dati è una potente metodologia di progettazione chiamata. Vedremo come l'astrazione dei dati renda i programmi molto più facili da progettare, mantenere e modificare.

//The use of compound data leads to a real increase in the expressive power of our programming language. Consider the idea of forming a ``linear combination'' latexmath:[$ax+by$]. We might like to write a function that would accept latexmath:[$a$], latexmath:[$b$], latexmath:[$x$], and latexmath:[$y$] as arguments and return the value of latexmath:[$ax+by$]. This presents no difficulty if the arguments are to be numbers, because we can readily declare the function
L'utilizzo di dati composti porta ad un reale aumento della potenza espressiva del nostro linguaggio di programmazione. Considera l'idea di formare una "combinazione lineare" latexmath:[ax + by]. Potremmo scrivere una funzione che accetti latexmath:[a], latexmath:[b], latexmath:[x] e latexmath:[y] come argomenti e restituisca il valore di latexmath:[ax + bx]. Questo non presenta difficoltà se gli argomenti devono essere numeri, perché possiamo dichiarare prontamente la funzione

[source,javascript]
----
function linear_combination(a, b, x, y) {
    return a * x + b * y;
}
----

//But suppose we are not concerned only with numbers. Suppose we would like to describe a process that forms linear combinations whenever addition and multiplication are defined—for rational numbers, complex numbers, polynomials, or whatever. We could express this as a function of the form
Ma supponiamo che non ci occupiamo solo dei numeri. Supponiamo di voler descrivere un processo che forma combinazioni lineari ogni volta che vengono definite addizioni e moltiplicazioni, per numeri razionali, numeri complessi, polinomi o qualsiasi altra cosa. Potremmo esprimerlo in funzione della forma

[source,javascript]
----
function linear_combination(a, b, x, y) {
    return add(mul(a, x), mul(b, y));
}
----

//where `add` and `mul` are not the primitive functions `+` and `*` but rather more complex things that will perform the appropriate operations for whatever kinds of data we pass in as the arguments `a`, `b`, `x`, and `y`. The key point is that the only thing `linear_combination` should need to know about `a`, `b`, `x`, and `y` is that the functions `add` and `mul` will perform the appropriate manipulations. From the perspective of the function `linear_combination`, it is irrelevant what `a`, `b`, `x`, and `y` are and even more irrelevant how they might happen to be represented in terms of more primitive data. This same example shows why it is important that our programming language provide the ability to manipulate compound objects directly: Without this, there is no way for a function such as `linear_combination` to pass its arguments along to `add` and `mul` without having to know their detailed structure.footnote:[The ability to directly manipulate functions provides an analogous increase in the expressive power of a programming language. For example, in section [sec:procedures-as-parameters] we introduced the `sum` function, which takes a function `term` as an argument and computes the sum of the values of `term` over some specified interval. In order to define `sum`, it is crucial that we be able to speak of a function such as `term` as an entity in its own right, without regard for how `term` might be expressed with more primitive operations. Indeed, if we did not have the notion of ``a function'', it is doubtful that we would ever even think of the possibility of defining an operation such as `sum`. Moreover, insofar as performing the summation is concerned, the details of how `term` may be constructed from more primitive operations are irrelevant.]
dove `add` e` mul` non sono le funzioni primitive `+` e `*` ma piuttosto cose più complesse che eseguiranno le operazioni appropriate per qualunque tipo di dati passiamo come argomenti `a`,` b`, "x" e "y". Il punto chiave è che l'unica cosa che `linear_combination` dovrebbe avere bisogno di sapere su` a`, `b`,` x` e `y` è che le funzioni` add` e `mul` eseguiranno le manipolazioni appropriate. Dal punto di vista della funzione `linear_combination`, è irrilevante cosa siano` a`, `b`,` x` e `y` e ancora più irrilevante come potrebbero essere rappresentati in termini di dati più primitivi. Questo stesso esempio mostra perché è importante che il nostro linguaggio di programmazione fornisca la possibilità di manipolare direttamente oggetti composti: senza questo, non c'è modo per una funzione come `linear_combination` di passare i suoi argomenti a `add` e `mul` senza dover conoscere la loro struttura dettagliata. footnote:[La capacità di manipolare direttamente le funzioni fornisce un analogo aumento della potenza espressiva di un linguaggio di programmazione. Ad esempio, nella sezione <<sec:procedures-as-parameters>> abbiamo introdotto la funzione `sum`, che accetta una funzione `term` come argomento e calcola la somma dei valori di `term` su un intervallo specificato. Per definire "sum", è cruciale poter parlare di una funzione come "term" come un'entità a sé stante, senza riguardo a come "termine" potrebbe essere espresso con operazioni più primitive. Infatti, se non avessimo la nozione di `` una funzione '', è dubbio che penseremmo mai alla possibilità di definire un'operazione come "somma". Inoltre, per quanto riguarda l'esecuzione della sommatoria, i dettagli di come "termine" può essere costruito da operazioni più primitive sono irrilevanti.]

//We begin this chapter by implementing the rational-number arithmetic system mentioned above. This will form the background for our discussion of compound data and data abstraction. As with compound functions, the main issue to be addressed is that of abstraction as a technique for coping with complexity, and we will see how data abstraction enables us to erect suitable between different parts of a program.
Iniziamo questo capitolo implementando il sistema aritmetico dei numeri razionali menzionato sopra. Questo costituirà lo sfondo per la nostra discussione sui dati composti e sull'astrazione dei dati. Come per le funzioni composte, il problema principale da affrontare è quello dell'astrazione come tecnica per affrontare la complessità, e vedremo come l'astrazione dei dati ci consente di erigere adatto tra le diverse parti di un programma.

//We will see that the key to forming compound data is that a programming language should provide some kind of ``glue'' so that data objects can be combined to form more complex data objects. There are many possible kinds of glue. Indeed, we will discover how to form compound data using no special ``data'' operations at all, only functions. This will further blur the distinction between `` function'' and ``data,'' which was already becoming tenuous toward the end of chapter 1. We will also explore some conventional techniques for representing sequences and trees. One key idea in dealing with compound data is the notion of —that the glue we use for combining data objects should allow us to combine not only primitive data objects, but compound data objects as well. Another key idea is that compound data objects can serve as for combining program modules in mix-and-match ways. We illustrate some of these ideas by presenting a simple graphics language that exploits closure.
Vedremo che la chiave per formare dati composti è che un linguaggio di programmazione dovrebbe fornire una sorta di "colla" in modo che gli oggetti dati possano essere combinati per formare oggetti dati più complessi. Ci sono molti possibili tipi di colla. In effetti, scopriremo come formare dati composti senza utilizzare alcuna operazione speciale sui "dati", ma solo funzioni. Questo offuscherà ulteriormente la distinzione tra "funzione" e "dati", che stava già diventando tenue verso la fine del capitolo 1. Esploreremo anche alcune tecniche convenzionali per rappresentare sequenze e alberi. Un'idea chiave nel trattare i dati composti è la nozione di —che il collante che usiamo per combinare oggetti di dati dovrebbe permetterci di combinare non solo oggetti di dati primitivi, ma anche oggetti di dati composti. Un'altra idea chiave è che gli oggetti di dati composti possono servire per combinare i moduli del programma in modi combinati. Illustriamo alcune di queste idee presentando un semplice linguaggio grafico che sfrutta la chiusura.

//We will then augment the representational power of our language by introducing —data whose elementary parts can be arbitrary symbols rather than only numbers. We explore various alternatives for representing sets of objects. We will find that, just as a given numerical function can be computed by many different computational processes, there are many ways in which a given data structure can be represented in terms of simpler objects, and the choice of representation can have significant impact on the time and space requirements of processes that manipulate the data. We will investigate these ideas in the context of symbolic differentiation, the representation of sets, and the encoding of information.
Aumenteremo quindi il potere rappresentativo del nostro linguaggio introducendo dati le cui parti elementari possono essere simboli arbitrari anziché solo numeri. Esploriamo varie alternative per rappresentare insiemi di oggetti. Scopriremo che, proprio come una data funzione numerica può essere calcolata da molti differenti processi computazionali, ci sono molti modi in cui una data struttura dati può essere rappresentata in termini di oggetti più semplici, e la scelta della rappresentazione può avere un impatto significativo sul requisiti di tempo e spazio dei processi che manipolano i dati. Investigheremo queste idee nel contesto della differenziazione simbolica, della rappresentazione degli insiemi e della codifica delle informazioni.

//Next we will take up the problem of working with data that may be represented differently by different parts of a program. This leads to the need to implement , which must handle many different types of data. Maintaining modularity in the presence of generic operations requires more powerful abstraction barriers than can be erected with simple data abstraction alone. In particular, we introduce _data-directed programming_ as a technique that allows individual data representations to be designed in isolation and then combined (i.e., without modification). To illustrate the power of this approach to system design, we close the chapter by applying what we have learned to the implementation of a package for performing symbolic arithmetic on polynomials, in which the coefficients of the polynomials can be integers, rational numbers, complex numbers, and even other polynomials.
Successivamente affronteremo il problema di lavorare con dati che possono essere rappresentati in modo diverso da parti diverse di un programma. Questo porta alla necessità di implementare, che deve gestire molti diversi tipi di dati. Il mantenimento della modularità in presenza di operazioni generiche richiede barriere di astrazione più potenti di quelle che possono essere erette con la semplice astrazione dei dati. In particolare, introduciamo la _programmazione diretta ai dati_ come tecnica che consente di progettare singole rappresentazioni di dati isolatamente e quindi combinarle (cioè senza modifiche). Per illustrare la potenza di questo approccio alla progettazione del sistema, chiudiamo il capitolo applicando quanto appreso all'implementazione di un pacchetto per eseguire aritmetica simbolica su polinomi, in cui i coefficienti dei polinomi possono essere interi, numeri razionali, numeri complessi e anche altri polinomi.

include::p1_intro_astrazione_dati.adoc[]
