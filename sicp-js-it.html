<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<meta name="description" content="Struttura e interpretazione dei programmi del calcolatore adattato al JavaScript">
<meta name="keywords" content="SICP, JS, JavaScript">
<meta name="author" content="Gionata Massi">
<title>Struttura e interpretazione dei programmi del calcolatore - adattato al JavaScript</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="./asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Struttura e interpretazione dei programmi del calcolatore - adattato al JavaScript</h1>
<div class="details">
<span id="author" class="author">Gionata Massi</span><br>
<span id="email" class="email"><a href="mailto:gionata.massi@savoiabenincasa.it">gionata.massi@savoiabenincasa.it</a></span><br>
<span id="revnumber">versione 0.1.1,</span>
<span id="revdate">2020-04-10</span>
<br><span id="revremark">Prima bozza con paragrafo 1.1</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Indice</div>
<ul class="sectlevel1">
<li><a href="#_costruire_astrazioni_con_le_funzioni">1. Costruire astrazioni con le funzioni</a>
<ul class="sectlevel2">
<li><a href="#_gli_elementi_della_programmazione">1.1. Gli elementi della programmazione</a>
<ul class="sectlevel3">
<li><a href="#_espressioni">1.1.1. Espressioni</a></li>
<li><a href="#_denominazione_e_ambiente">1.1.2. Denominazione e ambiente</a></li>
<li><a href="#sp_combinazione_operatori">1.1.3. Valutazione delle combinazioni mediante operatori</a></li>
<li><a href="#sp_funzioni_composte">1.1.4. Funzioni composte</a></li>
<li><a href="#sp_modello_sostituzione">1.1.5. Il modello di sostituzione per l&#8217;applicazione delle funzioni</a>
<ul class="sectlevel4">
<li><a href="#_ordine_di_applicazione_e_ordine_normale">Ordine di applicazione e ordine normale</a></li>
</ul>
</li>
<li><a href="#_epressioni_condizionali_e_predicati">1.1.6. Epressioni condizionali e predicati</a></li>
<li><a href="#sec:sqrt">1.1.7. Esempio: radici quadrate con il metodo di Newton</a></li>
<li><a href="#sec:black-box">1.1.8. Funzioni come astrazioni nella forma di una scatola nera</a>
<ul class="sectlevel4">
<li><a href="#_nomi_locali">Nomi locali</a></li>
<li><a href="#_dichiarazioni_interne_e_struttura_a_blocchi">Dichiarazioni interne e struttura a blocchi</a></li>
</ul>
</li>
<li><a href="#_esercizi_aggiuntivi">1.1.9. Esercizi aggiuntivi</a></li>
</ul>
</li>
<li><a href="#s_funzioni_e_processi">1.2. Le funzioni e i processi da esse generati</a>
<ul class="sectlevel3">
<li><a href="#sp_ricorsione_iterazione">1.2.1. Ricorsione e iterazione lineari</a></li>
<li><a href="#sp_ricorsione_ad_albero">1.2.2. Ricorsione ad albero</a>
<ul class="sectlevel4">
<li><a href="#_esempio_contare_il_numero_di_cambi">Esempio: Contare il numero di cambi</a></li>
</ul>
</li>
<li><a href="#sp_tassi_di_crescita">1.2.3. Tassi di crescita</a></li>
<li><a href="#sp_elevamento_a_potenza">1.2.4. Elevamento a potenza</a></li>
<li><a href="#sec:gcd">1.2.5. Massimo Comun Divisore</a></li>
<li><a href="#sp_test_di_primalita">1.2.6. Esempio: Test di primalità</a>
<ul class="sectlevel4">
<li><a href="#ricerca_divisori">La ricerca dei divisori</a></li>
<li><a href="#the-fermat-test">Il test di Fermat</a></li>
<li><a href="#sp_metodi_probabilistici">Metodi probabilistici</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec:higher-order-procedures">1.3. Formulare astrazioni con funzioni di ordine superiore</a>
<ul class="sectlevel3">
<li><a href="#sec:procedures-as-parameters">1.3.1. Funzioni come Parametri</a></li>
<li><a href="#sec:lambda">1.3.2. Costruire le funzioni utilizzando le espressioni Lambda</a>
<ul class="sectlevel4">
<li><a href="#using-const-to-create-local-names">Uso di <code>const</code> per creare nomi locali</a></li>
<li><a href="#conditional-statements">Istruzioni condizionali</a></li>
</ul>
</li>
<li><a href="#sec:proc-general-methods">1.3.3. Funzioni come metodi generali</a>
<ul class="sectlevel4">
<li><a href="#finding-roots-of-equations-by-the-half-interval-method">Trovare le radici delle equazioni con il metodo della bisezione</a></li>
<li><a href="#finding-fixed-points-of-functions">Trovare i punti fissi delle funzioni</a></li>
</ul>
</li>
<li><a href="#sec:proc-returned-values">1.3.4. Funzioni come valori restituiti</a>
<ul class="sectlevel4">
<li><a href="#newtons-method">Metodo di Newton</a></li>
<li><a href="#abstractions-and-first-class-functions">Astrazioni e funzioni di prima classe</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Questo testo è un adattamento in italiano, realizzato con l&#8217;auito di Google Translate, del testo <a href="https://sicp.comp.nus.edu.sg/">Structure and Interpretation of Computer Programs — JavaScript Adaptation</a>, il quale, a sua volta, è un adattamento della seconda edizione del noto libro di testo di Harold Abelson e Gerald Jay Sussman dal titolo: "Structure and Interpretation of Computer Programs".
Il testo ritiene è integrato con ulteriori esercizi in quanto per imparare l&#8217;arte della programmazione è necessario leggere del buon codice, ragionare su problemi, modelli e algoritmi, ed esercitarsi scrivendo programmi.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_costruire_astrazioni_con_le_funzioni"><a class="anchor" href="#_costruire_astrazioni_con_le_funzioni"></a>1. Costruire astrazioni con le funzioni</h2>
<div class="sectionbody">
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Gli atti con cui lo spirito esercita il suo potere sulle idee semplici
sono principalmente questi tre:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><em>combinare</em> varie idee semplici per formarne una complessa; così sono formate tutte le <em>idee complesse</em>;</p>
</li>
<li>
<p><em>mettere assieme</em> due idee, semplici o complesse, e giustapporle in modo
da vederle insieme senza unirle; così lo spirito ottiene tutte le sue
<em>idee di relazioni</em>;</p>
</li>
<li>
<p><em>separar</em> le idee <em>da</em> tutte le altre che le
accompagnano nella loro esistenza <em>reale</em>, e questo si chiama
astrazione: in tal modo sono formate tutte le <em>idee generali</em>.</p>
</li>
</ol>
</div>
</blockquote>
<div class="attribution">
&#8212; John Locke<br>
<cite>Saggio sull'intelletto umano - Libro II (Delle Idee) Capitolo XII (Delle idee complesse). 1690.</cite>
</div>
</div>
<div class="paragraph">
<p>Stiamo per studiare il concetto di <strong>processo di calcolo</strong>  o <em>processo
computazionale</em>. I processi computazionali sono esseri astratti che
vivono nei calcolatori, come <em>notebook</em>, <em>tablet</em>,
<em>smartphone</em>, <em>navigatori GPS</em>, dispositivi dello <em>Internet of things</em> e altri dispositivi con microcontrollori. I processi, mentre evolvono, manipolano altri oggetti astratti chiamati <strong>dati</strong>.
L&#8217;evoluzione di un processo è diretta da uno schema di regole chiamato
<strong>programma</strong>. Gli uomini creano i programmi per dirigere i processi.
Quando eseguiamo un programma, in effetti, evochiamo gli spiriti del
computer con i nostri incantesimi.</p>
</div>
<div class="paragraph">
<p>Un processo computazionale è molto simile all&#8217;idea che uno stregone ha
di uno spirito. Il processo non può essere visto né toccato. Non è
composto di materia. Tuttavia è reale. Può eseguire lavori
intellettuali. Può rispondere ad alcune domande. Può gestire eventi del
mondo reale erogando denaro in una banca o controllando un braccio
robotico in una fabbrica. I programmi che usiamo per evocare i processi
sono come gli incantesimi di uno stregone. Sono meticolosamente composti
da <strong>espressioni simboliche</strong> in <strong>linguaggi di programmazione</strong>  arcani ed
esoterici che prescrivono i compiti che vogliamo far eseguire ai nostri
processi.</p>
</div>
<div class="paragraph">
<p>Un processo computazionale, in un computer che funziona correttamente,
esegue i programmi in modo preciso e accurato. Quindi i programmatori
alle prime armi, così come l&#8217;apprendista stregone, devono imparare a capire e
anticipare le conseguenze delle loro parole magiche. Anche piccoli errori
nei programmi (di solito chiamati <strong>bug</strong> o <em>glitch</em>)  possono avere
conseguenze complesse e impreviste.</p>
</div>
<div class="paragraph">
<p>Fortunatamente, imparare a programmare è considerevolmente meno
pericoloso dello studio della stregoneria, perché gli spiriti di cui ci
occupiamo sono confinati nel calcolatore. La programmazione nel mondo
reale, tuttavia, richiede cura, competenza e saggezza. Un piccolo <em>bug</em> in
un programma di progettazione assistita dal computer (Computer Aided
Design, CAD), ad esempio, può portare al catastrofico schianto di un aereo
o al crollo di una diga o all&#8217;autodistruzione di un robot industriale.</p>
</div>
<div class="paragraph">
<p>Gli <strong>ingegneri del software</strong> hanno la capacità di organizzare i programmi
in modo da essere ragionevolmente sicuri che i processi risultanti
eseguiranno i compiti nel modo previsto. Possono anticipare il comportamento dei
loro sistemi. Sanno come <strong>strutturare i programmi</strong> in modo tale che
problemi imprevisti non portino a conseguenze catastrofiche e quando
sorgono problemi, possono eseguire il <strong>debug</strong>, ossia la rimozione degli errori,
 dei loro programmi.
Sistemi computazionali ben progettati, come automobili ben progettate o
reattori nucleari, sono progettati in modo <strong>modulare</strong>, in modo che le
parti possano essere costruite, sostituite e messe a punto
separatamente.</p>
</div>
<h3 id="_programmazione_in_javascript" class="discrete">Programmazione in JavaScript</h3>
<div class="paragraph">
<p>Abbiamo bisogno di un linguaggio appropriato per descrivere i processi e
useremo a questo scopo il <em>linguaggio di programmazione</em> <strong>JavaScript</strong>.
Proprio come i nostri pensieri quotidiani sono generalmente espressi nel
nostro linguaggio naturale (come l&#8217;italiano, l&#8217;inglese, il francese o
il giapponese) e le descrizioni dei fenomeni quantitativi sono espresse con
notazioni matematiche, il nostro linguaggio per descrivere i processi
computazionali sarà il linguaggio JavaScript.</p>
</div>
<div class="paragraph">
<p>JavaScript  è stato sviluppato all&#8217;inizio degli anni '90 come linguaggio
di programmazione per il controllo del comportamento dei browser del
World Wide Web tramite <em>script</em> (uno script, letteralmente, un copione,
è una descrizione del comportamento da tenere) incorporati
nelle pagine web. Il linguaggio è stata concepito da Brendan Eich,
originariamente sotto il nome di <em>Moka</em>, poi rinominato <em>LiveScript</em> e
infine <em>JavaScript</em>. Il nome <em>JavaScript</em> è un marchio registrato da <em>Oracle
Corporation</em>.</p>
</div>
<div class="paragraph">
<p>Nonostante JavaScript sia nato come linguaggio per il controllo dei browser,
esso è un linguaggio di programmazione generico. Un <strong>interprete</strong>
JavaScript è una <strong>macchina che esegue i processi</strong> descritti nel linguaggio
JavaScript. Il primo interprete JavaScript è stato implementato da Eich
presso <em>Netscape Communications Corporation</em>, per il browser web
<em>Netscape Navigator</em>. Le caratteristiche principali di JavaScript sono
ereditate dai linguaggi <strong>Scheme</strong> e <strong>Self</strong>. <em>Scheme</em> è un dialetto del
<strong>Lisp</strong> ed è stato usato come linguaggio di programmazione per la
versione originale del libro che ispira questa rivisitazione.
Da <em>Scheme</em>, <em>JavaScript</em> ha ereditato alcuni principi di progettazione
fondamentali ed è pertanto possibile adattare il modo di ragionare sui problemi
indotto dal <em>Scheme</em> in <em>JavaScript</em>.</p>
</div>
<div class="paragraph">
<p><em>JavaScript</em> ha anche una superficiale somiglianza con il linguaggio
<strong>Java</strong>, nonostante l&#8217;assonanza del nome; sia <em>Java</em> che <em>JavaScript</em> utilizzano
la struttura a blocchi del <strong>linguaggio C</strong>. Contrariamente a <em>Java</em> e <em>C</em>,
che di solito vengono <em>compilati</em> in linguaggi di livello inferiore, i
programmi <em>JavaScript</em> sono stati inizialmente interpretati dai browser
web. Dopo <em>Netscape Navigator</em>, altri browser web hanno fornito
interpreti per il linguaggio, incluso <em>Microsoft Internet Explorer</em>, la
cui versione JavaScript è chiamata <em>JScript</em>. La popolarità di
<em>JavaScript</em> per il controllo dei browser Web ha dato origine a uno sforzo
di standardizzazione, culminato in <strong>ECMAScript</strong>. La prima edizione dello
standard <strong>ECMAScript</strong> è stata guidata da Guy Lewis Steele Jr. e completata
nel giugno 1997 (Ecma 1997). La sesta edizione, utilizzata in questo
libro, è stata guidata da Allen Wirfs-Brock e adottata dall&#8217;Assemblea
Generale dell&#8217;ECMA nel giugno 2015.</p>
</div>
<div class="paragraph">
<p>La pratica di incorporare programmi JavaScript in pagine Web ha
incoraggiato gli sviluppatori di browser Web a implementare interpreti
<em>JavaScript</em>. Man mano che questi programmi diventavano più complessi, gli
interpreti devono diventare più efficienti nell&#8217;eseguirli. Oggi essi
usano tecniche sofisticate come la compilazione <em>Just-In-Time</em> (JIT). La
maggior parte dei programmi JavaScript (a partire dal 2020) sono
incorporati nelle pagine Web e interpretati dai browser, ma <em>JavaScript</em>
viene anche utilizzato per risolvere problemi di carattere generale,
spesso usando l&#8217;interprete <strong>Node.js</strong>.</p>
</div>
<div class="paragraph">
<p>Tuttavia, è la capacità dei browser di eseguire programmi <em>JavaScript</em> che
lo rende un linguaggio ideale per una versione online di un libro di
testo di programmazione. L&#8217;esecuzione dei programmi facendo clic sugli
elementi di una pagina Web è naturale in <em>JavaScript</em>, dopo tutto quello
per cui è stato progettato <em>JavaScript</em>! <em>JavaScript</em>
possiede funzionalità che lo rendono un mezzo eccellente per studiare
importanti costrutti di programmazione e strutture di dati e per
metterli in relazione con le caratteristiche linguistiche che li
supportano. Le funzioni di prima classe con visibilità statica,
caratteristica anche del JavaScript, forniscono accesso diretto e conciso ai meccanismi di
astrazione. La tipizzazione dinamica elimina la necessità di dichiarare
i tipi di dati manipolati dal programma. Oltre a queste considerazioni,
la programmazione in <em>JavaScript</em> è molto divertente.</p>
</div>
<div class="paragraph">
<p>Puoi provare gli esempi anche sfruttando anche alcune applicazioni web,
che offrono limitati servizi gratuiti.</p>
</div>
<div id="elenco_interpreti" class="ulist">
<div class="title">Alcune applicazioni web con cui invocare i processi nel linguaggio JavaScript</div>
<ul>
<li>
<p><a href="https://sourceacademy.nus.edu.sg/playground">	Source Academy playground!</a></p>
</li>
<li>
<p><a href="https://repljs.com/">REPL JS</a></p>
</li>
<li>
<p><a href="https://repl.it/languages/javascript">repl.it</a></p>
</li>
<li>
<p><a href="https://jsconsole.com/">jsconsole</a></p>
</li>
<li>
<p><a href="https://www.jdoodle.com/execute-nodejs-online/">JDoodle Online NodeJS IDE</a></p>
</li>
<li>
<p><a href="https://codesandbox.io/">CodeSandox</a></p>
</li>
<li>
<p><a href="http://neilff.github.io/immutable-repl/">Immutable REPL</a></p>
</li>
<li>
<p><a href="https://ramdajs.com/repl/">Ramda REPL</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_gli_elementi_della_programmazione"><a class="anchor" href="#_gli_elementi_della_programmazione"></a>1.1. Gli elementi della programmazione</h3>
<div class="paragraph">
<p>Un linguaggio di programmazione è più di un semplice strumento per
istruire un computer a svolgere compiti. Il linguaggio funge anche da
impianto all&#8217;interno del quale organizziamo le nostre idee sui
processi. Pertanto, quando descriviamo un linguaggio, dovremmo prestare
particolare attenzione ai costrutti esso fornisce per combinare idee
semplici e formare idee più complesse. Ogni linguaggio potente ha tre
meccanismi per raggiungere questo obiettivo:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">espressioni primitive</dt>
<dd>
<p>che rappresentano le entità più semplici di
cui il linguaggio si occupa,</p>
</dd>
<dt class="hdlist1">costrutti di combinazione</dt>
<dd>
<p>mediante i
quali gli elementi più semplici si combinamo per formare gli elementi
composti, e</p>
</dd>
<dt class="hdlist1">costrutti di astrazione</dt>
<dd>
<p>mediante i quali dare un nome agli elementi
composti e manipolarli come unità.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Nella programmazione ci occupiamo di due tipi di elementi: <strong>funzioni</strong> e
<strong>dati</strong>. Più avanti scopriremo che in realtà non sono così distinti.
Informalmente, i dati sono "cose" che vogliamo manipolare e le funzioni
sono descrizioni delle regole per manipolare i dati. Pertanto, qualsiasi
linguaggio di programmazione dovrebbe essere in grado di descrivere dati
primitivi e funzioni primitive e dovrebbe avere metodi per combinare e
astrarre funzioni e dati.</p>
</div>
<div class="paragraph">
<p>In questo capitolo tratteremo solo semplici dati numerici in modo da
poterci concentrare sulle regole per la costruzione di funzioni. Nei
capitoli successivi vedremo che queste stesse regole ci consentono di
creare funzioni per manipolare anche i dati composti.</p>
</div>
<div class="sect3">
<h4 id="_espressioni"><a class="anchor" href="#_espressioni"></a>1.1.1. Espressioni</h4>
<div class="paragraph">
<p>Un modo semplice per iniziare a programmare in <em>JavaScript</em> è attraverso uno degli interpreti indicati nell'<a href="#elenco_interpreti">elenco delle webapp che realizzano interpreti JavaScript</a>, oppure  interagire
con l&#8217;interprete JavaScript integrato nel browser che si sta utilizzando
per visualizzare questa pagina.
Per trovare l&#8217;interprete, in genere, basta digitare il tasto <kbd>F12</kbd> e selezionare la scheda "Console".</p>
</div>
<div class="paragraph">
<p>Un <strong>programma</strong> JavaScript è una <strong>sequenza di istruzioni</strong>.</p>
</div>
<div class="paragraph">
<p>Un tipo di istruzione è una <strong>istruzione espressione</strong>, che consiste in
una <strong>espressione</strong><sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup>, seguita da un punto e virgola. Un semplice tipo di espressione è un numero. (Più precisamente, l&#8217;espressione è detta <strong>numerale</strong> ed costituita dalle cifre che rappresentano il numero nella rappresentazione posizionale in base 10.)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">486;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Le espressioni che rappresentano numeri (un tipo di espressioni semplici) possono essere combinate con
<strong>operatori</strong> (come <code>+</code> o <code>*</code>) per formare una <strong>espressione composta mediante operatori</strong> che
rappresenta l&#8217;applicazione di una funzione primitiva corrispondente a
tali numeri. Ad esempio:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">137 + 349;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">1000 - 334;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">5 * 99;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">10 / 5;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">2.7 + 10;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Le espressioni come queste, che contengono altre espressioni come
componenti, sono chiamate <strong>combinazioni</strong> o <em>espressioni composte</em>. Le combinazioni che sono formate da un simbolo di operatore scritto in mezzo alle espressioni degli operandi sono dette <strong>combinazioni mediante operatori</strong>. Il valore di una combinazione mediante operatori si ottiene applicando la funzione (una procedura) specificata dall&#8217;operatore agli <strong>argomenti</strong>, ossia ai valori degli <strong>operandi</strong>.</p>
</div>
<div class="paragraph">
<p>La convenzione di posizionare l&#8217;operatore tra gli operandi è nota come
<strong>notazione infissa</strong>. Segue la notazione matematica con cui il lettore ha
certamente familiarità. Come in matematica, le combinazioni mediante
operatori possono essere <strong>nidificate</strong>, ovvero possono prendere argomenti
che sono esse stesse combinazioni di operatori:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">(3 * 5) + (10 - 6);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Come al solito, le parentesi vengono utilizzate per raggruppare le
combinazioni di operatori al fine di evitare ambiguità. <em>JavaScript</em> segue
anche le consuete convenzioni quando vengono omesse le parentesi; la
moltiplicazione e la divisione legano maggiormente di addizioni e
sottrazioni. Per esempio,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">3 * 5 + 10 / 2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>sta per</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">(3 * 5) + (10 / 2);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Diciamo che <code>*</code> e <code>/</code> hanno una <strong>precedenza maggiore</strong> di <code>+</code> e <code>-</code>. Le
sequenze di addizioni e sottrazioni vengono lette da sinistra a destra,
così come le sequenze di moltiplicazioni e divisioni. Così,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">3 / 5 * 2 - 4 + 3;</code></pre>
</div>
</div>
<div class="paragraph">
<p>sta per</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">(((3 / 5) * 2) - 4) + 3;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Si dice che gli operatori <code>+</code>, <code>-</code>, <code>*</code> e <code>/</code> sono <strong>associativi a
sinistra</strong>.</p>
</div>
<div class="paragraph">
<p>In linea di principio, non c&#8217;è limite alla profondità degli annidamenti
o alla complessità delle espressioni che l&#8217;interprete <em>JavaScript</em> possa
valutare. Noi essere umani, invece, possiamo restare confusi anche
valutando con semplici espressioni come:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">3 * 2 * (4 + (3 - 5)) + 10 * (27 / 6);</code></pre>
</div>
</div>
<div class="paragraph">
<p>che l&#8217;interprete, invece, valuta rapidamente producendo il numero 57.
Possiamo aiutarci scrivendo una tale espressione nella forma</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">3 * 2 * (4 + (3 - 5))
+
10 * (27 / 6);</code></pre>
</div>
</div>
<div class="paragraph">
<p>per separare visivamente i principali componenti dell&#8217;espressione.</p>
</div>
<div class="paragraph">
<p>L&#8217;interprete opera sempre nello stesso ciclo di base: legge
un&#8217;istruzione dal browser, valuta l&#8217;istruzione e stampa il risultato.
Questa modalità operativa viene spesso espressa dicendo che l&#8217;interprete
funziona in un <strong>ciclo di lettura-valutazione-stampa</strong>
(<em>read-eval-print-loop</em>, <strong>REPL</strong>). Si noti in particolare che non è
necessario istruire esplicitamente l&#8217;interprete a stampare il valore
dell&#8217;istruzione (<em>print</em>, stampa).</p>
</div>
</div>
<div class="sect3">
<h4 id="_denominazione_e_ambiente"><a class="anchor" href="#_denominazione_e_ambiente"></a>1.1.2. Denominazione e ambiente</h4>
<div class="paragraph">
<p>Un aspetto cruciale di un linguaggio di programmazione è la facoltà di
usare dei <em>nomi</em> per fare riferimento agli <em>oggetti
computazionali</em>.
Un <strong>costrutto</strong> del linguaggio che consente di <em>dare un nome</em> agli oggetti è quello della <strong>dichiarazione di valori costanti</strong>.
Diciamo che il nome identifica una costante il cui valore è l&#8217;oggetto.</p>
</div>
<div class="paragraph">
<p>In JavaScript, diamo un nome con la <strong>dichiarazione di costante</strong>. Ad esempio, scrivere</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">const dimensione = 2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>fa sì che l&#8217;interprete associ il valore 2 al nome <code>dimensione</code>. Il
compito della dichiarazione di costante è creare questa associazione.
Il valore che l&#8217;interprete JavaScript stampa dopo aver definito la costante
è <code>undefined</code>, un valore speciale <em>indefinito</em>, perché la specifica del linguaggio richiede che questo sia il risultato della valutazione delle dichiarazioni di costante. Una volta che il nome <code>dimensione</code> è stato associato al numero 2, possiamo fare riferimento al valore 2 per nome, come in</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">dimensione;</code></pre>
</div>
</div>
<div class="paragraph">
<p>oppure</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">5 * dimensione;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Naturalmente, l&#8217;interprete JavaScript deve eseguire la <em>dichiarazione di
costante</em> per <code>dimensione</code> prima che il nome <code>dimensione</code> possa essere
utilizzato in un&#8217;espressione.</p>
</div>
<div class="paragraph">
<p>Si nota qui che le istruzioni JavaScript possono essere inserite in una
<strong>sequenza</strong>. L&#8217;interprete valuta i componenti della sequenza nell&#8217;ordine
dato e considera il valore dell&#8217;ultimo componente come il valore della
sequenza.</p>
</div>
<div class="paragraph">
<p>Ecco altri esempi dell&#8217;uso di <code>const</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">const pi_greco = 3.14159;
const raggio = 10;
pi_greco * raggio * raggio;
const circonferenza =  2 * pi_greco * raggio;
circonferenza;</code></pre>
</div>
</div>
<div class="paragraph">
<p>La <em>dichiarazione di costante</em> è il costrutto di <em>astrazione</em><sup class="footnote">[<a id="_footnoteref_2" class="footnote" href="#_footnotedef_2" title="View footnote.">2</a>]</sup> più
semplice del nostro linguaggio, poiché ci consente di usare dei nomi per
fare riferimento ai risultati di operazioni composte, come la
circonferenza sopra calcolata. In generale, gli oggetti computazionali
possono avere strutture molto complesse e sarebbe estremamente scomodo
dover ricordare e ripetere i loro dettagli ogni volta che vogliamo
usarli. In effetti, programmi complessi sono costruiti generando, passo
dopo passo, oggetti computazionali di crescente complessità. Il nostro
interprete facilita questa costruzione passo-passo del programma perché
le associazioni nome-oggetto possono essere create in modo incrementale
nelle interazioni successive. Questa caratteristica favorisce lo sviluppo e il collaudo incrementale dei programmi ed è in buona parte responsabile del fatto che, di solito, i programmi JavaScript sono realizzati con un numero elevato di <em>funzioni</em> relativamente semplici.</p>
</div>
<div class="paragraph">
<p>Dovrebbe essere chiaro che la possibilità di associare valori a nomi e
di recuperarli in seguito significa che l&#8217;interprete deve mantenere una
sorta di memoria che tiene traccia delle coppie (nome, oggetto). Questa
memoria è chiamata <strong>ambiente</strong> (più precisamente <strong>ambiente globale</strong> o <strong>ambiente del programma</strong>,
poiché vedremo più avanti che un calcolo può coinvolgere un numero di
ambienti diversi).<sup class="footnote">[<a id="_footnoteref_3" class="footnote" href="#_footnotedef_3" title="View footnote.">3</a>]</sup></p>
</div>
</div>
<div class="sect3">
<h4 id="sp_combinazione_operatori"><a class="anchor" href="#sp_combinazione_operatori"></a>1.1.3. Valutazione delle combinazioni mediante operatori</h4>
<div class="paragraph">
<p>Uno degli obiettivi di questo capitolo è quello di isolare i problemi
relativi alle descrizioni dei processi. Ad esempio, consideriamo che,
nel valutare le combinazioni mediante operatori, l&#8217;interprete proceda
come segue.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Per valutare una combinazione mediante operatori, procedi come segue:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Valuta le espressioni degli operandi della combinazione.</p>
</li>
<li>
<p>Applica la funzione indicata dall&#8217;operatore agli argomenti che
sono i valori degli operandi.</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Anche questa semplice regola illustra alcuni punti importanti sui
processi in generale. Innanzitutto, osserva che il primo passo impone
che per completare il processo di valutazione di una combinazione
mediante operatori dobbiamo prima eseguire il processo di valutazione su
ciascun operando della combinazione mediante operatore. Pertanto, la
regola di valutazione è di natura <em>ricorsiva</em>; cioè include, come uno dei
suoi passi, la necessità di invocare la regola stessa. Notate quanto in
modo conciso l&#8217;idea della ricorsione possa essere utilizzata per
esprimere ciò che, nel caso di una combinazione profondamente annidata,
verrebbe altrimenti visto come un processo piuttosto complicato. Ad
esempio, valutare</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">(2 + 4 * 6) * (3 + 12);</code></pre>
</div>
</div>
<div class="paragraph">
<p>richiede che la regola di valutazione sia applicata a quattro diverse
combinazioni. Possiamo ottenere un&#8217;immagine di questo processo
rappresentando la combinazione sotto forma di un <strong>albero</strong>, come mostrato
nella <a href="#fig1_1">Figura 1</a>. Ogni combinazione è rappresentata da un nodo con
diramazioni corrispondenti all&#8217;operatore e agli operandi della
combinazione mediante operatori. I nodi terminali (ovvero nodi senza
rami che ne derivano) rappresentano operatori o numeri. Osservando la
valutazione in termini di struttura ad albero, possiamo immaginare che i
valori degli operandi si muovano verso l&#8217;alto, partendo dai nodi
terminali e poi combinandosi a livelli sempre più alti. In generale,
vedremo che la ricorsione è una tecnica molto potente per trattare
oggetti gerarchici come gli alberi. In effetti, il processo di
produzione e consumo di valori salendo verso l&#8217;alto che si ottiene della
regola di valutazione è un esempio di un tipo generale di processo noto
come <em>costruzione dell&#8217;albero</em> (<em>tree accumulation</em>, in inglese).</p>
</div>
<div id="fig1_1" class="imageblock">
<div class="content">
<img src="img/ca_fig1_1.svg" alt="ca fig1 1" width="1792" height="360">
</div>
<div class="title">Figura 1. Rappresentazione dell&#8217;albero, con illustrazione del valore di ogni sottoespressione</div>
</div>
<div class="paragraph">
<p>Successivamente, osserva che l&#8217;applicazione ripetuta del primo passaggio
ci porta al punto in cui dobbiamo valutare <strong>espressioni primitive</strong>, come numeri o nomi, non più combinazioni mediante
operatori.</p>
</div>
<div class="paragraph">
<p>Ci occupiamo dei casi primitivi stabilendo che</p>
</div>
<div class="ulist">
<ul>
<li>
<p>i valori dei numeri sono i numeri rappresentati nella notazione
posizionale in base 10, con il punto per separatore decimale,</p>
</li>
<li>
<p>i valori dei nomi sono gli oggetti associati a quei nomi nell&#8217;ambiente.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>nelle espressioni. In JavaScript, non ha senso parlare del valore di
È importante notare il ruolo dell&#8217;ambiente nel determinare il significato dei nomi.
In un linguaggio interattivo come il JavaScript non ha senso parlare del valore di un&#8217;espressione come <code>x + 1</code> senza specificare informazione alcuna
sull&#8217;ambiente che fornirebbe un significato per il nome <code>x</code>.</p>
</div>
<div class="paragraph">
<p>Si noti che la regola di valutazione sopra indicata non gestisce le
dichiarazioni di costanti. Ad esempio, valutando <code>const&#160;x&#160;=&#160;3;</code> non si
applica l&#8217;operatore <code>=</code> a due argomenti, uno dei quali è il valore del
nome <code>x</code> e l&#8217;altro è <code>3</code>, poiché lo scopo della dichiarazione costante è
proprio quello di associare <code>x</code> a un valore. Cioè, la parte <code>x = 3</code>
nella dichiarazione di costante</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">const x = 3;</code></pre>
</div>
</div>
<div class="paragraph">
<p>non è una combinazione di operatori.</p>
</div>
<div class="paragraph">
<p>La <em>stringa</em><sup class="footnote">[<a id="_footnoteref_4" class="footnote" href="#_footnotedef_4" title="View footnote.">4</a>]</sup> <code>const</code> nella dichiarazione costante è una <strong>parola chiave</strong> del JavaScript. Le parole chiave sono <strong>parole riservate</strong> che hanno un significato
particolare e quindi non possono essere utilizzate come nomi di costante.
Una parola chiave o una combinazione di parole chiave indica all&#8217;interprete
JavaScript di trattare la rispettiva dichiarazione in modo speciale.
Ciascuna di queste forme sintattiche ha una propria regola di
valutazione. I vari tipi di dichiarazioni (ciascuna con la relativa
regola di valutazione associata) costituiscono la <strong>sintassi</strong> del
linguaggio di programmazione.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Forma della dichiarazione di una costante</div>
<div class="paragraph">
<p><strong>const</strong> <em>nome</em> = <em>espressione</em></p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sp_funzioni_composte"><a class="anchor" href="#sp_funzioni_composte"></a>1.1.4. Funzioni composte</h4>
<div class="paragraph">
<p>Abbiamo identificato in JavaScript alcuni degli elementi che devono
apparire in qualsiasi linguaggio di programmazione:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>I numeri e le operazioni aritmetiche sono dati e funzioni primitivi.</p>
</li>
<li>
<p>L&#8217;annidamento delle combinazioni fornisce un costrutto per combinare
le operazioni.</p>
</li>
<li>
<p>Le dichiarazioni di costante che associano i nomi ai
valori forniscono un costutto di astrazione.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Ora conosceremo le <strong>dichiarazioni di funzione</strong>, una tecnica di
astrazione molto più potente con la quale a un&#8217;operazione composta può
essere assegnato un nome, così da considerarla come un&#8217;unità di calcolo.</p>
</div>
<div class="paragraph">
<p>Iniziamo esaminando come esprimere l&#8217;idea di quadratura di un numero.
Potremmo dire che, per quadrare un numero, occorre moliplicarlo per se
stesso. Questo è espresso in JavaScript come</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function quadrato (x) {
	return x * x;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>possiamo aiutarci nel modo seguente:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function quadrato(	x   ) { return	  x		*		   x; }
//  ^	   ^		 ^		 ^		 ^		^		   ^
// Per	quadrare un numero,			 lo moltiplichi per se stesso.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Qui abbiamo una <strong>funzione composta</strong>, a cui è stato dato il nome
<code>quadrato</code>. La funzione rappresenta l&#8217;operazione di moltiplicare
qualcosa per se stesso. Alla cosa da moltiplicare viene assegnato un
nome locale, <code>x</code>, che svolge lo stesso ruolo di un pronome nel
linguaggio naturale. La valutazione della <em>dichiarazione di funzione</em></p>
</div>
<div class="paragraph">
<p>crea questa funzione composta e la associa al nome <code>quadrato</code>.<sup class="footnote">[<a id="_footnoteref_5" class="footnote" href="#_footnotedef_5" title="View footnote.">5</a>]</sup>
La nostra forma più semplice di una dichiarazione di funzione è</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Forma (ristretta) della dichiarazione di una funzione</div>
<div class="paragraph">
<p><strong>function</strong> <em>nome</em> <strong>(</strong> <em>parametri</em> <strong>) { return</strong> <em>espressione</em> <strong>; }</strong></p>
</div>
</div>
</div>
<div class="paragraph">
<p>Il <em>nome</em> è un simbolo da associare alla funzione nell'<strong>ambiente</strong>. I
<em>parametri</em> sono i nomi utilizzati nel corpo della funzione per fare
riferimento agli argomenti corrispondenti della funzione. Essi sono raggruppati dentro le parentesi tonde, come si indicano nell&#8217;applicazione della funzione che si sta dichiarando. Nella forma più semplice, il <strong>corpo</strong> della dichiarazione di funzione è una singola <strong>istruzione di restituzione del controllo</strong> che consiste nella parola chiave <strong>return</strong> seguita dall&#8217;espressione che
produrrà il valore dell'<strong>applicazione della funzione</strong> quando i parametri formali
vengono sostituiti dagli argomenti a cui viene applicata la funzione.<sup class="footnote">[<a id="_footnoteref_6" class="footnote" href="#_footnotedef_6" title="View footnote.">6</a>]</sup></p>
</div>
<div class="paragraph">
<p>Avendo dichiarato la funzione <code>quadrato</code>, ora possiamo usarla in
un'<strong>espressione di applicazione di una funzione</strong>, che trasformiamo in
un&#8217;istruzione usando un punto e virgola:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">quadrato (21);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Il nome <code>quadrato</code> è l'<strong>espressione della funzione</strong> dell&#8217;applicazione e numerale 21
è l'<strong>espressione dell&#8217;argomento</strong>.</p>
</div>
<div class="paragraph">
<p>Le applicazioni di funzioni sono, dopo le combinazioni mediante operatori, un altro tipo di combinazione di espressioni all&#8217;interno di espressioni più grandi.</p>
</div>
<div class="paragraph">
<p>La forma generale di un&#8217;applicazione di una funzione è:</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Forma generale di applicazione di una funzione</div>
<div class="paragraph">
<p><em>espressione-della-funzione</em> <strong>(</strong> <em>espressioni-degli-argomenti</em> <strong>)</strong></p>
</div>
</div>
</div>
<div class="paragraph">
<p>dove l'<em>espressione-della-funzione</em> dell&#8217;applicazione specifica quale funzione deve essere applicata alla sequenza di <em>espressioni-degli-argomenti</em>, che sono separati da virgole.</p>
</div>
<div class="paragraph">
<p>Per valutare l&#8217;appplicazione di una funzione, l&#8217;interprete esegue una procedura abbastanza simile a quella per le combinazioni mediante operatore.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Per valutare un&#8217;applicazione di una funzione, procedi come segue:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Valuta le espressioni dell&#8217;applicazione di una funzione.</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Valuta l'<em>espressione della funzione</em></p>
</li>
<li>
<p>Valuta le <em>espressioni degli argomenti</em></p>
</li>
</ol>
</div>
</li>
<li>
<p>Applica la funzione indicata dal valore dell&#8217;espressione della funzione ai valori delle espressioni degli argomenti.</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">quadrato (2 + 5);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Qui, l'<em>espressione argomento</em> è essa stessa un&#8217;espressione composta,
l'<em>espressione mediante operatore</em> <code>2 + 5</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">quadrato (quadrato (3));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Naturalmente le <em>espressioni di applicazione</em> possono anche servire come
espressioni di argomenti. Possiamo anche usare <code>quadrato</code> come un
mattoncino con cui definire altre funzioni. Ad esempio,
\(x^2 + y^2\) può essere espresso come</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">quadrato (x) + quadrato (y);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Possiamo facilmente dichiarare una funzione <code>somma_di_quadrati</code> che, dati due
numeri qualsiasi come argomenti, produce la somma dei loro quadrati:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function somma_di_quadrati (x, y) {
	return quadrato (x) + quadrato (y);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ora possiamo usare <code>somma_di_quadrati</code> come mattoncino per la
costruzione di ulteriori funzioni:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function f (a) {
	return somma_di_quadrati (a + 1, a * 2);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Oltre alle funzioni composte, JavaScript fornisce una serie di <strong>funzioni primitive</strong>
integrate nell&#8217;interprete. Un esempio è la funzione <code>Math.log</code> che
calcola il logaritmo naturale del suo argomento. La valutazione
dell&#8217;espressione dell&#8217;applicazione <code>Math.log (1)</code> produce il numero 0.
Le funzioni primitive vengono utilizzate esattamente allo stesso modo
delle funzioni composte. In effetti, non si può dire guardando la
definizione di <code>somma_di_quadrati</code> sopra indicata se il quadrato sia una
funzione primitiva dell&#8217;interprete, come <code>Math.log</code>, o se sia definito
come una funzione composta.</p>
</div>
</div>
<div class="sect3">
<h4 id="sp_modello_sostituzione"><a class="anchor" href="#sp_modello_sostituzione"></a>1.1.5. Il modello di sostituzione per l&#8217;applicazione delle funzioni</h4>
<div class="paragraph">
<p>Per valutare una combinazione mediante applicazione, l&#8217;interprete segue
un processo simile a quello delle combinazioni mediante operatori,
descritto sopra. Cioè, l&#8217;interprete valuta gli elementi della
combinazione e applica la funzione (che è il valore dell&#8217;espressione
della funzione) agli argomenti (che sono i valori delle espressioni
degli argomenti della combinazione dell&#8217;applicazione).</p>
</div>
<div class="paragraph">
<p>Più in dettaglio, l&#8217;interprete procede come segue quando valuta le
combinazioni di applicazioni:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Per valutare una combinazione di applicazioni della forma <em>espressione-della-funzione</em> <strong>(</strong>&#160;<em>espressioni-degli-argomenti</em>&#160;<strong>)</strong> fare quanto segue:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Valuta l&#8217;espressione della funzione della combinazione
dell&#8217;applicazione, risultante nella funzione da applicare.</p>
</li>
<li>
<p>Valuta le espressioni degli argomenti della combinazione.</p>
</li>
<li>
<p>Applica la funzione agli argomenti:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Se la funzione è primitiva, applichiamo semplicemente la funzione
matematica corrispondente agli argomenti.</p>
</li>
<li>
<p>Se la funzione è composta, valutiamo l&#8217;espressione da restituire
della funzione con ogni parametro sostituito dall&#8217;argomento corrispondente.</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Per illustrare questo processo, valutiamo la combinazione
dell&#8217;applicazione di una funzione</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">f (5);</code></pre>
</div>
</div>
<div class="paragraph">
<p>dove <code>f</code> è la funzione definita in <a href="#sp_funzioni_composte">paragrafo 1.1.4</a>.
La valutazione del nome <code>f</code> restituisce il corpo della funzione. La
valutazione dell&#8217;espressione dell&#8217;argomento 5 produce il valore
dell&#8217;argomento 5. Ora, recuperiamo l&#8217;espressione da restituire di <code>f</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">somma_di_quadrati (a + 1, a * 2)</code></pre>
</div>
</div>
<div class="paragraph">
<p>in cui sostituiamo il parametro <code>a</code> con l&#8217;argomento 5:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">somma_di_quadrati (5 + 1, 5 * 2)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Pertanto, il problema si riduce alla valutazione di una combinazione di
applicazioni con due argomenti e un&#8217;espressione di funzione
<code>somma_di_quadrati</code>. La valutazione di questa combinazione comporta tre
sottoproblemi. Dobbiamo valutare l&#8217;espressione della funzione per
ottenere l&#8217;applicazione della funzione e dobbiamo valutare le
espressioni degli argomenti per ottenere gli argomenti. Ora <code>5 + 1</code>
produce 6 e <code>5 * 2</code> produce 10, quindi dobbiamo applicare la funzione
<code>somma_di_quadrati</code> a 6 e 10. Questi valori vengono sostituiti con i
parametri <code>x</code> e <code>y</code> nell&#8217;espressione restituita da <code>somma_di_quadrati</code>,
riducendo l&#8217;espressione a</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">quadrato (6) + quadrato (10)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Se usiamo la dichiarazione di <code>quadrato</code> una volta, questo si riduce a</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">(6 * 6) + quadrato (10)</code></pre>
</div>
</div>
<div class="paragraph">
<p>che effettuata la moltiplicazione si riduce a</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">36 + quadrato (10)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Una seconda applicazione di <code>quadrato</code> porta all&#8217;espressione composta
per mezzo di operatori</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">36 + (10 * 10)</code></pre>
</div>
</div>
<div class="paragraph">
<p>che si riduce con la moltiplicazione a</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">36 + 100</code></pre>
</div>
</div>
<div class="paragraph">
<p>e infine viene valutato l&#8217;operatore primitivo di somma applicato agli
argomenti primitivi ottenendo, finalmente</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">136</code></pre>
</div>
</div>
<div class="paragraph">
<p>Il processo che abbiamo appena descritto si chiama <strong>modello di
sostituzione per l&#8217;applicazione delle funzioni</strong>. Può essere usato come
un modello per determinare il significato dell&#8217;applicazione delle
funzioni, per quanto riguarda le funzioni di questo capitolo. Tuttavia,
ci sono due punti che dovrebbero essere sottolineati:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Lo scopo della sostituzione è di aiutarci a pensare all&#8217;applicazione
della funzione, non a fornire una descrizione di come funziona davvero
l&#8217;interprete. Gli interpreti tipici non valutano le applicazioni delle
funzioni manipolando il testo di una funzione per sostituire i valori
con i parametri. In pratica, la sostituzione viene eseguita utilizzando
un <em>ambiente locale</em> per i parametri.</p>
</li>
<li>
<p>Ci sono modelli più elaborati di come funzionano gli interpreti.
Il modello di sostituzione è solo il
primo di questi modelli: un modo per iniziare a pensare formalmente al
processo di valutazione. In generale, quando modelliamo i fenomeni
scientifici e ingegneristici, iniziamo con modelli semplificati e
incompleti. Man mano che esaminiamo le cose in modo più dettagliato,
questi semplici modelli diventano inadeguati e devono essere sostituiti
da modelli più raffinati. Il modello di sostituzione non fa eccezione.</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_ordine_di_applicazione_e_ordine_normale"><a class="anchor" href="#_ordine_di_applicazione_e_ordine_normale"></a>Ordine di applicazione e ordine normale</h5>
<div class="paragraph">
<p>Secondo la descrizione della valutazione di cui sopra, l&#8217;interprete
valuta prima la funzione e le espressioni degli argomenti, quindi
applica la funzione risultante agli argomenti risultanti. Questo non è
l&#8217;unico modo per eseguire la valutazione. Un modello di valutazione
alternativo non valuterebbe gli operandi fino a quando non fossero
necessari i loro valori. Sostituirebbe invece le espressioni degli
argomenti con i parametri fino a quando non ottenesse un&#8217;espressione che
coinvolge solo operatori, per poi eseguire la valutazione. Se usassimo
questo metodo, la valutazione di</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">f (5)</code></pre>
</div>
</div>
<div class="paragraph">
<p>procederebbe secondo la sequenza di espansioni</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">somma_di_quadrati (5 + 1, 5 * 2)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">quadrato (5 + 1) + quadrato (5 * 2)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">(5 + 1) * (5 + 1) + quadrato (5 * 2)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">(5 + 1) * (5 + 1) + (5 * 2) * (5 * 2)</code></pre>
</div>
</div>
<div class="paragraph">
<p>seguita dalle riduzioni</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">6 * (5 + 1) + (5 * 2) * (5 * 2)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">6 * 6 + (5 * 2) * (5 * 2)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">36 + (5 * 2) * (5 * 2)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">36 + 10 * (5 * 2)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">36 + 10 * 10</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">36 + 100</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">136</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ciò fornisce la stessa risposta del nostro modello di valutazione
precedente, ma il processo è diverso. In particolare, le valutazioni di
<code>5 + 1</code> e <code>5 * 2</code> vengono eseguite due volte ciascuna qui, corrispondente
alla riduzione dell&#8217;espressione x * x con x sostituita rispettivamente
da <code>5 + 1</code> e <code>5 * 2</code>. Questa alternativa si espande completamente e quindi
riduce il metodo di valutazione è noto come valutazione dell&#8217;ordine
normale, in contrasto con la valutazione degli argomenti e quindi
applica il metodo che l&#8217;interprete effettivamente utilizza, che è
chiamato valutazione dell&#8217;ordine applicativo. Si può dimostrare che, per
le applicazioni di funzioni che possono essere modellate usando la
sostituzione (comprese tutte le funzioni nei primi due capitoli di
questo libro) e che producono valori legittimi, la valutazione
dell&#8217;ordine normale e dell&#8217;ordine applicativo producono lo stesso
valore.</p>
</div>
<div class="paragraph">
<p>JavaScript utilizza la valutazione nell&#8217;ordine applicativo, in parte a
causa dell&#8217;ulteriore efficienza ottenuta dall&#8217;evitare valutazioni
multiple di espressioni come quelle illustrate sopra e, in modo più
significativo, perché la valutazione dell&#8217;ordine normale diventa molto
più complicata da affrontare quando lasciamo il regno delle procedure
che può essere modellizzato per sostituzione. D&#8217;altra parte, la valutazione
dell&#8217;ordine normale può essere uno strumento estremamente prezioso.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_epressioni_condizionali_e_predicati"><a class="anchor" href="#_epressioni_condizionali_e_predicati"></a>1.1.6. Epressioni condizionali e predicati</h4>
<div class="paragraph">
<p>Il potere espressivo della classe di funzioni che possiamo dichiarare a
questo punto è molto limitato, perché non abbiamo modo di fare test ed
eseguire diverse operazioni a seconda del risultato di un test. Ad
esempio, non possiamo dichiarare una funzione che calcola il valore
assoluto di un numero verificando se il numero è negativo o meno e
intraprendendo azioni diverse in ciascun caso in base alla regola</p>
</div>
<div class="paragraph">
<p>\(|x| = \begin{cases} \phantom{-}x &amp; \text{se } x \geq 0\\ -x &amp; \text{altrimenti}\end{cases}\)</p>
</div>
<div class="paragraph">
<p>Questo costrutto è un&#8217;analisi di casi e può essere espresso in
JavaScript usando un&#8217;espressione condizionale come segue:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function valore_assoluto (x) {
	return x &gt;= 0 ? x : -x;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>La forma generale di un'<strong>espressione condizionale</strong> è</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Forma di un&#8217;espressione condizionale</div>
<div class="paragraph">
<p><em>predicato</em> <strong>?</strong> <em>espressione-conseguente</em> <strong>:</strong> <em>espressione-alternativa</em></p>
</div>
</div>
</div>
<div class="paragraph">
<p>Le espressioni condizionali iniziano con un predicato, ovvero
un&#8217;espressione il cui valore viene interpretato come vero o falso. Vero
e falso sono dei valori che indichiamo come valori booleani, in onore di
George Boole che ne ha studiato le proprietà con una teoria matematica.
In JavaScript i valori vero e falso sono nominati, rispettivamente,
<code>true</code> e <code>false</code>.</p>
</div>
<div class="paragraph">
<p>Si noti che le espressioni booleane primitive <code>true</code> e <code>false</code> vengono
valutate, rispettivamente, nei valori booleani <code>true</code> (vero) e <code>false</code> (falso).
Il predicato è seguito da un punto interrogativo, l&#8217;espressione
conseguente, i due punti e infine l&#8217;espressione alternativa. Per
valutare un&#8217;espressione condizionale, l&#8217;interprete inizia valutando il
predicato dell&#8217;espressione composta. Se il predicato restituisce <code>true</code>,
l&#8217;interprete valuta l&#8217;espressione conseguente. Altrimenti valuta
l&#8217;espressione alternativa.</p>
</div>
<div class="paragraph">
<p>La parola <em>predicato</em> viene utilizzata per funzioni che restituiscono
vero o falso, nonché per espressioni che sono valuate in vero o falso.
La funzione del valore assoluto <code>valore_assoluto</code> utilizza il predicato
primitivo <code>&gt;=</code>. Questo predicato accetta due numeri come argomenti e
verifica se il primo numero è maggiore o uguale al secondo numero,
restituendo vero o falso di conseguenza.</p>
</div>
<div class="paragraph">
<p>JavaScript fornisce una serie di predicati primitivi che funzionano in
modo simile a <code>&gt;=</code>, inclusi <code>&gt;</code>, <code>&lt;</code>, <code>`&lt;=</code>` e <code>===</code>. Oltre a questi
predicati primitivi, esistono operazioni logiche di composizione che ci
consentono di costruire predicati composti. I tre più utilizzati sono
questi:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>espressione1</em> <code>&amp;&amp;</code> <em>espressione2</em> </dt>
<dd>
<p>L&#8217;interprete valuta espressione1. Se viene valutato falso, il valore
dell&#8217;intera espressione è falso e espressione2 non viene valutata. Se
espressione1 restituisce vero, il valore dell&#8217;intera espressione è il
valore di espressione2.</p>
</dd>
<dt class="hdlist1"><em>espressione1</em> <code>||</code> <em>espressione2</em> </dt>
<dd>
<p>L&#8217;interprete valuta espressione1. Se restituisce vero, il valore
dell&#8217;intera espressione è vero e expressione2 non viene valutata. Se
espressione1 restituisce falso, il valore dell&#8217;intera espressione è il
valore di espressione2.</p>
</dd>
<dt class="hdlist1"><code>!</code> <em>espressione</em> </dt>
<dd>
<p>Il valore dell&#8217;espressione è vero quando espressione viene valutata falsa e falso in caso contrario.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Si noti che <code>&amp;&amp;</code> e <code>||</code> non vengono valutati come operatori aritmetici
come <code>+</code>, perché la loro espressione di destra non viene sempre valutata.
L&#8217;operatore <code>!</code>, d&#8217;altra parte, segue la regola di valutazione già nota.
È un operatore unario, il che significa che accetta solo un argomento,
mentre gli operatori aritmetici incontrati finora sono binari, prendendo
due argomenti. L&#8217;operatore <code>!</code> precede il suo argomento; lo chiamiamo un
<strong>operatore prefisso</strong>. Un altro operatore prefisso è l&#8217;operatore meno
unario, un esempio del quale è l&#8217;espressione <code>-x</code> della funzione
<code>valore_assoluto</code> all&#8217;inizio di questa sezione. Come esempio di come
vengono utilizzati questi predicati, la condizione che un numero
\(x\) sia compreso nell&#8217;intervallo \(5 &lt; x &lt; 10\)
può essere espressa come</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">x &gt; 5 &amp;&amp; x &lt; 10</code></pre>
</div>
</div>
<div class="paragraph">
<p>Si noti che l&#8217;operatore binario <code>&amp;&amp;</code> ha una precedenza inferiore
rispetto agli operatori di confronto <code>&gt;</code> e <code>&lt;</code>.</p>
</div>
<div class="paragraph">
<p>Come altro esempio, possiamo dichiarare un predicato per verificare se
un numero diverso a un altro numero.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function diverso (x, y) {
	return x &gt; y || x &lt; y;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>oppure</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function diverso (x, y) {
	return !(x &lt;= y &amp;&amp; x &gt;= y);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Nota che l&#8217;operatore <code>!==</code> quando applicato a due numeri, si comporta
come <code>diverso</code>.</p>
</div>
<div class="exampleblock">
<div class="title">Esercizio 1.1. Saper simulare il processo indotto dal programma</div>
<div class="content">
<div class="paragraph">
<p>Prima di verificare con l&#8217;interprete JavaScript,
determima con le regole di valutazione che hai appreso fin ora il valore
delle seguenti espressioni in JavaScript:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">10;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">5 + 3 + 4;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">9 - 1;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">6 / 2;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">2 * 4 + (4 - 6);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">const a = 3;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">const b = a + 1;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">a + b + a * b;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">a === b;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">b &gt; a &amp;&amp; b &lt; a * b
   ? b : a;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">a === 4 ? 6 : b === 4 ? 6 + 7 + a : 25;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">2 + (b &gt; a ? b : a);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">(a &gt; b
 ? a
 : a &lt; b
   ? b
   : -1)
*
(a + 1);</code></pre>
</div>
</div>
</div>
</div>
<details>
<summary class="title">Click per vedere le soluzioni dell&#8217;esercizio</summary>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">10

12

8

3

6

undefined

undefined

19

false

4

16

6

16</code></pre>
</div>
</div>
</div>
</details>
<div class="exampleblock">
<div class="title">Esercizio 1.2. Saper scrivere espressioni composte (combinazioni mediante operatore)</div>
<div class="content">
<div class="paragraph">
<p>Traduci la seguente espressione matematica
nell&#8217;equivalente espressione JavaScript:</p>
</div>
<div class="paragraph">
<p>\(\frac{5+4+\left(2-\left(3-(6+\frac{4}{5})\right)\right)}{3 (6-2) (2-7)}\)</p>
</div>
</div>
</div>
<details>
<summary class="title">Click per vedere le soluzioni dell&#8217;esercizio</summary>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">// Soluzione dell'esercizio 1.2
(5 + 4 + (2 - (3 - (6 + 4 / 5))))
/
(3 * (6 - 2) * (2 - 7));</code></pre>
</div>
</div>
</div>
</details>
<div class="exampleblock">
<div class="title">Esercizio 1.3. Saper scrivere semplici funzioni composte</div>
<div class="content">
<div class="paragraph">
<p>Definisci una funzione che accetta tre argomenti
numerici e restituisce la somma dei quadrati dei due numeri più grandi.</p>
</div>
</div>
</div>
<details>
<summary class="title">Click per vedere le soluzioni dell&#8217;esercizio</summary>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">// Soluzione dell'esercizio 1.3
function esercizio_1_3 (x, y, z) {
	return quadrato (x) + quadrato (y) + quadrato (z) -
	 quadrato ( (x &lt; y ? x : y) &lt; z ? (x &lt; y ? x : y) : z );
}</code></pre>
</div>
</div>
</div>
</details>
<div id="ex:a-plus-abs-b" class="exampleblock">
<div class="title">Esercizio 1.4. Riconoscere nel nome di funzione la valutazione dell&#8217;espressione</div>
<div class="content">
<div class="paragraph">
<p>Si noti che il nostro modello di valutazione consente
combinazioni mediante applicazioni le cui espressioni di funzioni sono
espressioni composte. Utilizzare questa osservazione per descrivere il
comportamento della seguente funzione:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function piu (a, b) { return a + b; }

function meno (a, b) { return a - b; }

function a_piu_valore_assoluto_b (a, b) {
	return (b &gt;= 0 ? piu : meno) (a, b);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Si noti che nell&#8217;espressione condizionale, non possiamo usare
direttamente gli operatori + e - invece dei nomi <code>piu</code> e <code>meno</code> perché nella
notazione infissa sono consentiti solo simboli di operatore nel mezzo, non
espressioni composte.</p>
</div>
</div>
</div>
<details>
<summary class="title">Click per vedere le soluzioni dell&#8217;esercizio</summary>
<div class="content">
<div class="paragraph">
<p>mediante applicazione di funzione procede come segue:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Valuta l&#8217;espressione della funzione della combinazione
dell&#8217;applicazione, che determina il nome nella funzione da applicare.</p>
</li>
<li>
<p>Valuta le espressioni argomento della combinazione.</p>
</li>
<li>
<p>Valuta l&#8217;espressione da restituire della funzione con ogni parametro
sostituito dall&#8217;argomento corrispondente.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Pertanto la valutazione dell&#8217;espressione dell&#8217;applicazione
<code>a_piu_valore_assoluto_b  (5, -4)</code> valuta <code>a_piu_valore_assoluto_b</code>
(passo 1), ottenendo la funzione sopra indicata e (passo 2) gli
argomenti sono già valori. Quindi dobbiamo valutare (passo 3)
l&#8217;espressione del valore da restituire della funzione, con i parametri
sostituiti dagli argomenti, quindi: <code>(-4 &gt;= 0 ? piu : meno) (5, -4)</code>.
Con le stesse regole, dobbiamo (passo 1) valutare l&#8217;espressione della
funzione, che in questo caso è l&#8217;espressione condizionale
<code>-4 &gt;= 0 ? piu : meno</code>. Poiché il predicato restituisce <code>false</code>,
l&#8217;espressione della funzione restituisce <code>meno</code>. Gli argomenti, di nuovo
(passo 2) sono già valori. Quindi finiamo per valutare (passo 3) il
corpo di <code>meno</code> con i parametri <code>a</code> e <code>b</code> sostituiti rispettivamente da
5 e -4, risultando in 5 - (-4), che infine risulterà nel valore 9.</p>
</div>
</div>
</details>
<div id="es_test-ordine-normale-vs-ordine-appl" class="exampleblock">
<div class="title">Esercizio 1.5. Riflettere sulle conseguenze dell&#8217;ordine di valutazione</div>
<div class="content">
<div class="paragraph">
<p>Ben Bitdiddle ha inventato un test per determinare se
l&#8217;interprete con cui affrontiamo la programmazione sta usando la
valutazione nell&#8217;ordine di applicazione o la valutazione nell&#8217;ordine
normale. Dichiara le seguenti due funzioni:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function p() {
	return p();
}

function test(x, y) {
	return x === 0 ? 0 : y;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Quindi scrive l&#8217;istruzione</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">test (0, p ());</code></pre>
</div>
</div>
<div class="paragraph">
<p>Quale comportamento osserverà Ben con un interprete che utilizza la
valutazione nell&#8217;ordine di applicazione? Quale comportamento osserverà
con un interprete che utilizza la valutazione nell&#8217;ordine normale?
Spiega la tua risposta. (Supponiamo che la regola di valutazione per le
espressioni condizionali sia la stessa se l&#8217;interprete utilizza l&#8217;ordine
normale o applicativo: l&#8217;espressione del predicato viene valutata per
prima e il risultato determina se valutare l&#8217;espressione conseguente o
alternativa.) Confronta il risultato con la valutazione della funzione
con il tuo interprete.</p>
</div>
</div>
</div>
<details>
<summary class="title">Click per vedere le soluzioni dell&#8217;esercizio</summary>
<div class="content">
<div class="paragraph">
<p>Nella valutazione nell&#8217;ordine di applicazione per valutare l&#8217;espressione
<code>test (0, p ())</code>, che è un espressione di applicazione di funzione,
dobbiamo valutare le espressioni degli argomenti prima di poter valutare
l&#8217;espressione restituita dalla funzione <code>test</code>. La valutazione
dell&#8217;espressione argomento <code>p ()</code> non terminerà: continuerà a valutare
le espressioni di applicazione della funzione <code>p ()</code> e quindi la
valutazione di <code>test (0, p ())</code> non produrrà un valore legittimo.
Normalmente l&#8217;interprete riconosce il caso e termina la valutazione
notiicando un errore. Nella valutazione nell&#8217;ordine normale, invece
parte, il test dell&#8217;applicazione di funzione (0, p ()) valuterà
immediatamente l&#8217;espressione restituita da <code>test</code>: <code>x === 0 ? 0: y</code> dopo
aver sostituito il parametro <code>x</code> con 0 e <code>y</code> con <code>p ()</code>. Il risultato
della sostituzione sarebbe <code>0 === 0? 0: p ()</code>. La valutazione del
predicato <code>0 === 0</code> risulta vera e quindi l&#8217;espressione condizionale
restituisce 0, senza che sia necessario valutare <code>p ()</code>.</p>
</div>
</div>
</details>
</div>
<div class="sect3">
<h4 id="sec:sqrt"><a class="anchor" href="#sec:sqrt"></a>1.1.7. Esempio: radici quadrate con il metodo di Newton</h4>
<div class="paragraph">
<p>Le funzioni, come introdotto sopra, sono molto simili alle normali
funzioni matematiche che si studiano nel quinto anno. Specificano un
valore determinato da uno o più parametri. Ma c&#8217;è una differenza
importante tra le funzioni matematiche e le funzioni del computer. Le
funzioni del computer devono essere <em>efficaci</em>, devono cioè fornire un
valore. Dovrebbero essere anche <em>efficienti</em>, cioè fornire un valore in un
tempo ragionevole.</p>
</div>
<div class="paragraph">
<p>Ad esempio, considera il problema del calcolo delle radici quadrate.
Possiamo definire la funzione radice quadrata come</p>
</div>
<div class="paragraph">
<p>\(\sqrt{x} = \text{ quel numero }y\text{ tale che } y \geq 0\text{ e }
				y^2 = x\)</p>
</div>
<div class="paragraph">
<p>Questo descrive una funzione matematica perfettamente legittima.
Potremmo usare la definizione per riconoscere se un numero è la radice
quadrata di un altro o per dedurre delle proposizioni vere sulle radici
quadrate in generale. D&#8217;altra parte, la definizione non descrive una
funzione del computer. In effetti, non ci dice quasi nulla su come
trovare effettivamente la radice quadrata di un dato numero. Non aiuterà
le cose a riformulare questa definizione in pseudo-JavaScript:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function radice_quadrata (x) {
	return y con y&gt; = 0 &amp;&amp;
		quadrato (y) === x;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Il contrasto tra la funzione matematica e quella del computer riflette
la distinzione generale tra la descrizione delle proprietà delle cose e
la descrizione di come fare le cose, o, come viene talvolta indicato, la
distinzione tra <strong>conoscenza dichiarativa</strong> e <strong>conoscenza imperativa</strong>. In
matematica di solito ci occupiamo di descrizioni dichiarative (cos&#8217;è),
mentre in informatica ci occupiamo di solito di descrizioni imperative
(come).</p>
</div>
<div class="paragraph">
<p>Come si calcolano le radici quadrate? Il modo più comune è usare il
metodo di Newton per approssimazioni successive, che dice che ogni volta
che abbiamo una supposizione \(y\) per il valore della radice
quadrata di un numero \(x\), possiamo eseguire una semplice
manipolazione per ottenere una stima migliore (più vicina alla radice
quadrata) facendo la media di \(y\) con
\(\frac x y\). Ad esempio, possiamo calcolare la radice
quadrata di 2 come segue. Supponiamo che la nostra ipotesi iniziale sia
1:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Stima</th>
<th class="tableblock halign-center valign-top">Quoziente</th>
<th class="tableblock halign-center valign-top">Valor medio</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><div class="content"><div class="paragraph">
<p>\(1\)</p>
</div></div></td>
<td class="tableblock halign-center valign-top"><div class="content"><div class="paragraph">
<p>\(\frac 2 1\)</p>
</div></div></td>
<td class="tableblock halign-center valign-top"><div class="content"><div class="paragraph">
<p>\(\frac{1 + 2}2=\frac 3 2=1.5\)</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><div class="content"><div class="paragraph">
<p>\(1.5\)</p>
</div></div></td>
<td class="tableblock halign-center valign-top"><div class="content"><div class="paragraph">
<p>\(\frac 4 3\)</p>
</div></div></td>
<td class="tableblock halign-center valign-top"><div class="content"><div class="paragraph">
<p>\(\frac 1 2\left(\frac 3 2 + \frac 4 3\right)=\frac 17 12 \approx 1.4167\)</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><div class="content"><div class="paragraph">
<p>\(1.4167\)</p>
</div></div></td>
<td class="tableblock halign-center valign-top"><div class="content"><div class="paragraph">
<p>\(\frac{24}{17}\)</p>
</div></div></td>
<td class="tableblock halign-center valign-top"><div class="content"><div class="paragraph">
<p>\(\frac 1 2\left(\frac{17}{12}+\frac{24}{17}\right)=\frac{577}{408}\approx 1.4142\)</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><div class="content"><div class="paragraph">
<p>\(1.4142\)</p>
</div></div></td>
<td class="tableblock halign-center valign-top"><div class="content"><div class="paragraph">
<p>\(\cdots\)</p>
</div></div></td>
<td class="tableblock halign-center valign-top"><div class="content"><div class="paragraph">
<p>\(\cdots\)</p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Continuando questo processo, otteniamo approssimazioni sempre migliori
alla radice quadrata.</p>
</div>
<div class="paragraph">
<p>Ora formalizziamo il processo in termini di funzioni. Iniziamo con un
valore per il radicando (il numero di cui stiamo provando a calcolare la
radice quadrata) e un valore per la stima iniziale. Se la stima iniziale
è abbastanza buona per i nostri scopi, abbiamo finito; in caso
contrario, dobbiamo ripetere il processo con una stima migliore.
Scriviamo questa strategia di base come funzione:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function radice_quadrata_iter (stima, x) {
	return suff_accurata (stima, x)
		? stima
		: radice_quadrata_iter (migliora (stima, x), x);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Una stima viene migliorata facendo una media tra il quoziente del
radicando e la vecchia stima:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function migliora (stima, x) {
	return valor_medio (stima, x / stima);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>dove</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function valor_medio (x, y)
	return (x + y) / 2;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Dobbiamo anche dire cosa intendiamo con stima <em>sufficientemente
accurata</em>, che codifichiamo con il predicato <code>suff_accurata</code>. Un&#8217;idea è
quella di migliorare il risultato della nostra funzione fino a quando il
suo quadrato differisca dal radicando per una tolleranza inferiore a una
predeterminata soglia (qui 0,001):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function suff_accurata (stima, x) {
	return valore_assoluto (quadrato (stima) - x) &lt; 0.001;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Infine, abbiamo bisogno di un modo per iniziare. Ad esempio, possiamo
sempre supporre che la radice quadrata di qualsiasi numero sia 1:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function radice_quadrata (x) {
	return radice_quadrata_iter (1, x);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Se scriviamo queste dichiarazioni all&#8217;interprete, possiamo usare radice_quadrata
così come possiamo usare qualsiasi funzione.</p>
</div>
<div id="radq1" class="listingblock">
<div class="title">Elenco 1. Programma per il calcolo della radice quadrata e funzioni da cui dipende</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function radice_quadrata_iter (stima, x) {
	return suff_accurata (stima, x)
		? stima
		: radice_quadrata_iter (migliora (stima, x), x);
}

function migliora (stima, x) {
	return valor_medio (stima, x / stima);
}

function valor_medio (x, y) {
	return (x + y) / 2;
}

function suff_accurata (stima, x) {
	return valore_assoluto (quadrato (stima) - x) &lt; 0.001;
}

function radice_quadrata (x) {
	return radice_quadrata_iter (1, x);
}

function valore_assoluto (x) {
	return x &gt;= 0 ? x : -x;
}

function quadrato (x) {
	return x * x;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alcuni esempi di applicazione della nostra nuova funzione composta:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">radice_quadrata (9);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">radice_quadrata (100 + 37);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">radice_quadrata (radice_quadrata (2) + radice_quadrata (3));</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">quadrato (radice_quadrata (1000));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Il programma <code>radice_quadrata</code> fornisce l&#8217;idea che anche il semplice linguaggio
funzionale che abbiamo introdotto finora sia sufficiente per scrivere
qualsiasi programma puramente numerico come quelli che si potrebbero
scrivere in altri linguaggi come il C o Pascal. Ciò potrebbe sembrare
sorprendente, dal momento che non abbiamo ancora introdotto i costrutti
iterativi (cicli o loop) che istruiscono il computer a fare qualcosa più
e più volte. La funzione <code>radice_quadrata_iter</code>, d&#8217;altra parte, dimostra come
l&#8217;iterazione può essere realizzata senza ricorrere a nessun costrutto
speciale diverso dalla normale capacità di chiamare una funzione.</p>
</div>
<div class="exampleblock">
<div class="title">Esercizio 1.6. Comprendere la necessità delle forme speciali</div>
<div class="content">
<div class="paragraph">
<p>Alyssa P. Hacker non ama la sintassi delle espressioni
condizionali, che coinvolgono i caratteri <strong>?</strong> e <strong>:</strong>. «Perché non posso
semplicemente dichiarare una normale funzione condizionale la cui
applicazione funziona esattamente come le espressioni condizionali?» lei
chiede. La sua amica Eva Lu Ator afferma che questo può davvero essere
fatto e dichiara una funzione condizionale come segue:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function condizionale (predicato, clausola_allora, clausola_altrimenti) {
	return predicato ? clausola_allora: clausola_altrimenti;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Eva dimostra ad Alyssa che il programma:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">condizionale (2 === 3, 0, 5);</code></pre>
</div>
</div>
<div class="paragraph">
<p>viene valutato come previsto, a 5, e</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">condizionale (1 === 1, 0, 5);</code></pre>
</div>
</div>
<div class="paragraph">
<p>viene valutato come previsto, a 0. Felicissima, Alyssa usa il
condizionale per riscrivere il programma per il calcolo della radice
quadrata:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function radice_quadrata_iter (stima, x) {
	return condizionale (suff_accurata (stima, x),
		stima,
		radice_quadrata_iter (migliora (stima, x),
		x));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Cosa succede quando Alyssa tenta di usarlo per calcolare le radici
quadrate? Spiegarlo.</p>
</div>
</div>
</div>
<details>
<summary class="title">Click per vedere le soluzioni dell&#8217;esercizio</summary>
<div class="content">
<div class="paragraph">
<p>Qualsiasi chiamata di <code>radice_quadrata_iter</code> porta immediatamente a un ciclo
infinito. La ragione di ciò è la valutazione nell&#8217;ordine applicativo. La
valutazione dell&#8217;espressione da restituire di <code>radice_quadrata_iter</code> deve prima
valutare i suoi argomenti, inclusa la chiamata ricorsiva di <code>radice_quadrata_iter</code>,
indipendentemente dal fatto che il predicato sia valutato vero o falso.
Lo stesso ovviamente accade con la chiamata ricorsiva, e quindi la
funzione condizionale non viene mai effettivamente applicata.</p>
</div>
</div>
</details>
<div class="exampleblock">
<div class="title">Esercizio 1.7. Comprensione del concetto di criterio di terminazione</div>
<div class="content">
<div class="paragraph">
<p>Il controllo <code>suff_accurata</code> utilizzato nel calcolo
delle radici quadrate non sarà molto efficace per trovare le radici
quadrate di numeri molto piccoli. Inoltre, nei computer reali, le
operazioni aritmetiche vengono quasi sempre eseguite con una precisione
limitata. Questo rende il nostro controllo inadeguato per numeri molto
grandi. Spiega queste affermazioni, con esempi che mostrano come il test
fallisce per numeri piccoli e grandi. Una strategia alternativa per
implementare <code>suff_accurata</code> è guardare come le stime cambiano da
un&#8217;iterazione alla successiva e fermarsi quando il cambiamento è una
frazione molto piccola della stima. Progettare una funzione per il
calcolo della radice quadrata che utilizza questo tipo di controllo di
terminazione. Funziona meglio?</p>
</div>
</div>
</div>
<details>
<summary class="title">Click per vedere le soluzioni dell&#8217;esercizio</summary>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">// Soluzione esercizio 1.7

/*
La tolleranza assoluta di 0,001 è troppo grande quando si calcola la radice quadrata di un valore piccolo.
Ad esempio, radice_quadrata (0,0001) genera 0,03230844833048122 anziché il valore previsto 0,01 con
un errore percentuale superiore al 200%.
D'altra parte, per valori molto grandi, gli errori di arrotondamento potrebbero impedire la terminazione del processo.
Il seguente programma allevia il problema considerando l'errore relativo in sostituzione di quello assoluto.
Si verifichi se si creano soluzioni mal gestite se si prova a calcolare la radice quadrata di zero.
*/

const soglia_tolleranza = 0.01;
function radice_quadrata_iter (stima, x) {
	return errore_relativo (stima, migliora (stima, x)) &lt; soglia_tolleranza
		? stima
		: radice_quadrata_iter (migliora (stima, x), x);
}

function migliora (stima, x) {
	return valor_medio (stima, x / stima);
}

function valor_medio (x, y) {
	return (x + y) / 2;
}

function suff_accurata (stima, x) {
	return errore_relativo (stima, migliora (stima, x)) &lt; soglia_tolleranza;
}

function errore_relativo (stima, riferimento) {
	return valore_assoluto ((stima- riferimento) / riferimento)
}

function radice_quadrata (x) {
	return radice_quadrata_iter (1, x);
}

function valore_assoluto (x) {
	return x &gt;= 0 ? x : -x;
}

function quadrato (x) {
	return x * x;
}</code></pre>
</div>
</div>
</div>
</details>
<div class="exampleblock">
<div class="title">Esercizio 1.8. Riscrivere alcune funzioni, verso il concetto di scatola nera</div>
<div class="content">
<div class="paragraph">
<p>Il metodo di Newton per le radici dei cubi si basa sul
fatto che se \(y\) è un&#8217;approssimazione alla radice del cubo
di \(x\), allora una migliore approssimazione è data dal
valore</p>
</div>
<div class="paragraph">
<p>\(\frac{x/y^{2}+2y} {3}\)</p>
</div>
<div class="paragraph">
<p>Si utilizzi questa formula per implementare una funzione <code>radice_cubica</code> per il
calcolo della radice cubica analoga alla funzione <code>radice_quadrata</code>.</p>
</div>
</div>
</div>
<details>
<summary class="title">Click per vedere le soluzioni dell&#8217;esercizio</summary>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">// Soluzione dell'esercizio 1.8

function suff_accurata (stima, x) {
	return valore_assoluto (cubo (stima) - x) &lt; 0.001;
}

function migliora (stima, x) {
	return (x / quadrato (stima) + 2 * stima) / 3;
}

function radc_iter (stima, x) {
	return suff_accurata (stima, x)
		? stima
		: radice_cubica_iter (migliora (stima, x), x);
}

function radice_cubica (x) {
	return radice_cubica_iter (1, x);
}

function cubo (x) {
	return quadrato (x) * x;
}</code></pre>
</div>
</div>
</div>
</details>
</div>
<div class="sect3">
<h4 id="sec:black-box"><a class="anchor" href="#sec:black-box"></a>1.1.8. Funzioni come astrazioni nella forma di una scatola nera</h4>
<div class="paragraph">
<p>La funzione <code>radice_quadrata</code> è il nostro primo esempio di un processo definito da
un insieme di funzioni che si definiscono l&#8217;una con l&#8217;altra. Si noti che
la dichiarazione di <code>radice_quadrata_iter</code> è ricorsiva; la funzione è cioè definita
in termini di se stessa. L&#8217;idea di poter definire una funzione in
termini di se stessa può essere inquietante; potrebbe non essere chiaro
come una definizione circolare del genere possa avere senso, tanto meno
specificare un processo ben definito che deve essere eseguito da un
computer.</p>
</div>
<div class="paragraph">
<p>Osserva che il problema del calcolo delle radici quadrate si scompone
naturalmente in una serie di sottoproblemi: come capire se una stima è
abbastanza accurata, come migliorare una stima e così via. Ognuna di
queste attività è svolta da una funzione separata. L&#8217;intero programma
<code>radice_quadrata</code> può essere visualizzato come un raggruppamento di funzioni
(mostrato nella Figura 1.2) che rispecchia la decomposizione del
problema in sottoproblemi.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/ca_fig1_2.svg" alt="ca fig1 2" width="832" height="280">
</div>
<div class="title">Figura 2. Decomposizione funzionale del programma radice_quadrata</div>
</div>
<div class="paragraph">
<p>L&#8217;importanza di questa strategia di decomposizione non è semplicemente
quella di dividere il programma in parti. Dopotutto, potremmo prendere
qualsiasi programma di grandi dimensioni e dividerlo in parti: le prime
dieci righe, le successive dieci righe, le successive dieci righe e così
via. Piuttosto, è cruciale che ogni funzione compia un compito
identificabile che può essere usato come modulo nella definizione di
altre funzioni. Ad esempio, quando definiamo la funzione <code>suff_accurata</code>
in termini di <code>quadrato</code>, siamo in grado di considerare la funzione
<code>quadrato</code> come una scatola nera. In quel momento non ci occupiamo di come
la funzione calcola il suo risultato, ma solo del fatto che calcola il
quadrato. I dettagli di come viene calcolato il quadrato possono essere
soppressi, per essere considerati in un secondo momento. In effetti, per
quanto riguarda la funzione <code>suff_accurata</code>, il <em>quadrato</em> non è proprio una
funzione ma piuttosto un&#8217;astrazione di una funzione, una cosiddetta
<strong>astrazione funzionale</strong>. A questo livello di astrazione, qualsiasi
funzione che calcola il quadrato è ugualmente buona.</p>
</div>
<div class="paragraph">
<p>Pertanto, considerando solo i valori che restituiscono, le seguenti due
funzioni che quadrano un numero dovrebbero essere indistinguibili.
Ognuno accetta un argomento numerico e produce il quadrato di quel
numero come valore.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function quadrato (x) {
	return x * x;
}

function quadrato (x) {
	return Math.exp (doppio (Math.log (x)));
}

function doppio (x) {
	return x + x;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Quindi una funzione dovrebbe essere in grado di sopprimere i dettagli.
Gli utenti della funzione potrebbero non aver scritto la funzione da
soli, ma potrebbero averla ottenuta da un altro programmatore come una
scatola nera. Un utente non dovrebbe avere bisogno di sapere come viene
implementata la funzione per poterla utilizzare.</p>
</div>
<div class="sect4">
<h5 id="_nomi_locali"><a class="anchor" href="#_nomi_locali"></a>Nomi locali</h5>
<div class="paragraph">
<p>Un dettaglio dell&#8217;implementazione di una funzione che non dovrebbe
interessare all&#8217;utente della funzione è la scelta dei nomi da parte
dell&#8217;implementatore per i parametri della funzione. Pertanto, le
seguenti funzioni non dovrebbero essere distinguibili:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function quadrato (x) {
	return x * x;
}

function quadrato (y) {
	return y * y;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Questo principio - che il significato di una funzione dovrebbe essere
indipendente dai nomi dei parametri usati dal suo autore - sembra evidente
ma ha conseguenze profonde.
La conseguenza
più semplice è che i nomi dei parametri di una funzione devono essere
locali al corpo della funzione. Ad esempio, abbiamo usato
<code>quadrato</code> nella dichiarazione di <code>suff_accurata</code> nella nostra funzione
<code>radice_quadrata</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function suff_accurata(stima, x) {
	return valore_assoluto ( quadrato (stima) - x) &lt; 0.001;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>L&#8217;intenzione dell&#8217;autore di <code>suff_accurata</code> è di determinare se il quadrato del
primo argomento rientri in un determinato intorno del secondo
argomento. Vediamo che l&#8217;autore di <code>suff_accurata</code> ha usato il nome
<code>stima</code> per riferirsi al primo argomento e <code>x</code> per riferirsi al secondo
argomento. L&#8217;argomento di quadrato è <code>stima</code>. Se l&#8217;autore di <code>quadrato</code>
ha usato <code>x</code> per fare riferimento al secondo argomento, vediamo
che la <code>x</code> in <code>suff_accurata</code> deve essere una <code>x</code> diversa da quella usata in
<code>quadrato</code>. L&#8217;esecuzione della funzione <code>quadrato</code> non deve influire sul
valore di <code>x</code> che viene utilizzato da <code>suff_accurata</code>, perché quel valore
di <code>x</code> può essere necessario per <code>suff_accurata</code> dopo che il calcolo del <code>quadrato</code>
è terminato.</p>
</div>
<div class="paragraph">
<p>Se i parametri non fossero locali ai corpi delle loro rispettive
funzioni, allora il parametro <code>x</code> in <code>quadrato</code> potrebbe essere confuso con il
parametro <code>x</code> in <code>suff_accurata</code>, e il comportamento di <code>suff_accurata</code>
dipenderebbe da quale versione di <code>quadrato</code> abbiamo usato. Pertanto,
<code>quadrato</code> non sarebbe la scatola nera che desideravamo.</p>
</div>
<div class="paragraph">
<p>Un parametro di una funzione ha un ruolo molto speciale nella
dichiarazione di funzione, in quanto non ha importanza il nome del
parametro. Tale nome è chiamato <strong>legame</strong> o <em>associazione</em>, <em>binding</em> in inglese,
e diciamo che la dichiarazione
di funzione associa i suoi parametri. Il significato di una dichiarazione
di funzione rimane invariato se un nome associato viene costantemente
rinominato in tutta la dichiarazione. Se un nome non è associato,
diciamo che è libero. L&#8217;insieme di espressioni per cui un&#8217;associazione
dichiara un nome è chiamato <strong>visibilità</strong>, <em>scope</em> in inglese, di quel nome. In una dichiarazione di
funzione, i nomi associati dichiarati come parametri della funzione
hanno il corpo della funzione come visibilità.</p>
</div>
<div class="paragraph">
<p>Nella dichiarazione di <code>suff_accurata</code> sopra, <code>stima</code> e <code>x</code> sono nomi
associati ma <code>valore_assoluto</code> e <code>quadrato</code> sono liberi. Il significato
di <code>suff_accurata</code> dovrebbe essere indipendente dai nomi che scegliamo per <code>stima</code> e <code>x</code>
fintanto che sono distinti e diversi da <code>valore_assoluto</code> e <code>quadrato</code>. (Se
rinominassimo <code>stima</code> in <code>valore_assoluto</code> avremmo introdotto un bug catturando il
nome <code>valore_assoluto</code>. Sarebbe cambiato da libero a legato.) Il significato di <code>suff_accurata</code>
non è indipendente dalla scelta dei suoi nomi liberi. Dipende
sicuramente dal fatto (esterno a questa dichiarazione) che il simbolo
<code>valore_assoluto</code> denota una funzione per calcolare il valore assoluto di un numero.
La funzione JavaScript <code>valore_assoluto</code> calcolerà una diversa funzione
matematica se sostituiamo <code>Math.cos</code> (funzione coseno di
JavaScript) con <code>valore_assoluto</code> nella sua dichiarazione.</p>
</div>
</div>
<div class="sect4">
<h5 id="_dichiarazioni_interne_e_struttura_a_blocchi"><a class="anchor" href="#_dichiarazioni_interne_e_struttura_a_blocchi"></a>Dichiarazioni interne e struttura a blocchi</h5>
<div class="paragraph">
<p>Finora abbiamo un tipo di isolamento del nome a nostra disposizione: i parametri di una funzione
sono locali al corpo della funzione.
Il programma per il calcolo della radice quadrata
illustra un altro modo in cui vorremmo controllare l&#8217;uso dei nomi. Il
programma <a href="#radq1">Elenco 1</a> è costituito da funzioni separate.</p>
</div>
<div class="paragraph">
<p>Il problema di questo programma è che l&#8217;unica funzione importante per gli utenti è
<code>radice_quadrata</code>. Le altre funzioni (<code>radice_quatrata_iter</code>, <code>suff_accurata</code> e <code>migliora</code>)
ingombrano solo le loro menti. Non possono dichiarare qualsiasi altra
funzione chiamata <code>suff_accurata</code> come parte di un altro programma che opera
insieme con il programma per la radice quadrata, perché la funzione <code>radice_quadrata</code> ne ha bisogno.
Il problema è particolarmente grave nella costruzione di grandi sistemi
da parte di molti programmatori separati. Ad esempio, nella costruzione
di una libreria di funzioni numeriche, molte funzioni numeriche
vengono calcolate come approssimazioni successive e quindi potrebbero
avere funzioni gli stessi nomi come funzioni
ausiliarie. Vorremmo localizzare le sottofunzioni, nascondendole
all&#8217;interno di <code>radice_quadrata</code> in modo che <code>radice_quadrata</code> possa coesistere con altre
funzioni basate sulle approssimazioni successive, ognuna con la propria funzione <code>suff_accurata</code>.
Per renderlo possibile, consentiamo a una funzione di avere
dichiarazioni interne locali a tale funzione. Ad esempio, nel problema
della radice quadrata possiamo scrivere</p>
</div>
<div id="radq2" class="listingblock">
<div class="title">Elenco 2. Programma per il calcolo della radice quadrata con funzioni annidate</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function radice_quadrata (x) {
	function radice_quadrata_iter (stima, x) {
		return suff_accurata (stima, x)
			? stima
			: radice_quadrata_iter (migliora (stima, x), x);
	}

	function migliora (stima, x) {
		return valor_medio (stima, x / stima);
	}

	function valor_medio (x, y) {
		return (x + y) / 2;
	}

	function suff_accurata (stima, x) {
		return valore_assoluto (quadrato (stima) - x) &lt; 0.001;
	}

	function valore_assoluto (x) {
		return x &gt;= 0 ? x : -x;
	}

	function quadrato (x) {
		return x * x;
	}

	return radice_quadrata_iter (1, x);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Il corpo di una funzione - un&#8217;istruzione racchiusa tra parentesi graffe - è chiamato
<strong>blocco</strong>. Le dichiarazioni di funzione nidificate all&#8217;interno di un blocco
sono locali per quel blocco. Questa struttura a blocchi è una soluzione al problema di
avere esposti troppi nomi. Ma c&#8217;è un&#8217;idea migliore. Oltre
a internalizzare le dichiarazioni delle funzioni ausiliarie, possiamo
semplificarle. Poiché <code>x</code> è associato nella dichiarazione di <code>radice_quadrata</code>, le
funzioni <code>suff_accurata</code>, <code>migliora</code> e <code>radice_quadrata_iter</code>, che sono definite
internamente a <code>radice_quadrata</code>, rientrano nell&#8217;ambito di visibilità di <code>x</code>. Pertanto, non è
necessario passare <code>x</code> in modo esplicito a ciascuna di queste funzioni.
Invece, consentiamo a <code>x</code> di essere un nome libero nelle dichiarazioni
interne, come mostrato di seguito. Quindi <code>x</code> ottiene il suo valore
dall&#8217;argomento con cui viene chamata la funzione <code>radice_quadrata</code>
che racchiude le funzioni interne.
Questa disciplina si chiama visibilità lessicale, o visibilità statica (static scoping).</p>
</div>
<div id="radq3" class="listingblock">
<div class="title">Elenco 3. Programma per il calcolo della radice quadrata che sfrutta la visibilià statica</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function radice_quadrata (x) {
	function radice_quadrata_iter (stima) {
		return suff_accurata (stima)
			? stima
			: radice_quadrata_iter (migliora (stima));
	}

	function migliora (stima) {
		return valor_medio (stima, x / stima);
	}

	function valor_medio (x, y) {
		return (x + y) / 2;
	}

	function suff_accurata (stima) {
		return valore_assoluto (quadrato (stima) - x) &lt; 0.001;
	}

	function valore_assoluto (x) {
		return x &gt;= 0 ? x : -x;
	}

	function quadrato (x) {
		return x * x;
	}

   return radice_quadrata_iter (1, x);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Useremo ampiamente la struttura a blocchi per aiutarci a suddividere
grandi programmi in parti trattabili.
L&#8217;idea della struttura a blocchi è nata con il
linguaggio di programmazione Algol 60. Appare nella maggior parte dei
linguaggi di programmazione avanzati ed è uno strumento importante per
aiutare a organizzare la costruzione di programmi di grandi dimensioni.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_esercizi_aggiuntivi"><a class="anchor" href="#_esercizi_aggiuntivi"></a>1.1.9. Esercizi aggiuntivi</h4>
<div class="exampleblock">
<div class="title">Esercizio A-1.1.1</div>
<div class="content">
<div class="paragraph">
<p>Costruire un glossario dei termini in cui raccogliere le definizioni
che si trovano in questo sotto-paragrafo.</p>
</div>
<div class="paragraph">
<p>Il glossario ha la forma:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Termine</th>
<th class="tableblock halign-left valign-top">Sinonimi</th>
<th class="tableblock halign-left valign-top">Descrizione</th>
<th class="tableblock halign-left valign-top">Termini collegati</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="exampleblock">
<div class="title">Esercizio A-1.1.2</div>
<div class="content">
<div class="paragraph">
<p>Costruire una mappa mentale che includa i termini definiti nell&#8217;esercizio
precedente.</p>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Esercizio A-1.1.3</div>
<div class="content">
<div class="paragraph">
<p>Scrivere un esercizio di programmazione significativo che possa essere
risolto con le conoscenze apprese in questo sotto-paragrafo.
Esibire il codice che dimostra che l&#8217;esercizio può essere effettivamente
risolto.</p>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Esercizio A-1.1.4</div>
<div class="content">
<div class="paragraph">
<p>Scrivere tre espressioni semplici e tre espressioni composte mediante operatori che usano gli stessi numerali.</p>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Esercizio A-1.1.5</div>
<div class="content">
<div class="paragraph">
<p>Aggiungere le parentesi alle espressioni sottostanti per indicare l&#8217;ordine di valutazione usato dall&#8217;interprete <em>JavaScript</em>.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>1 + 2 - 3 * 4 / 5</p>
</li>
<li>
<p>1 * 2 + 3 * 4 - 5</p>
</li>
<li>
<p>1 / 2 + 3 * 4 - 5</p>
</li>
<li>
<p>1 + 2 * 3 * 4 - 5</p>
</li>
</ol>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Esercizio A-1.1.6</div>
<div class="content">
<div class="paragraph">
<p>Aggiungere le parentesi alle espressioni sottostanti per indicare l&#8217;ordine di valutazione usato dall&#8217;interprete <em>JavaScript</em>.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>100000 * 200000 * 400000 / 3 * 10</p>
</li>
<li>
<p>100000 / 3 * 200000 * 400000 * 10</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Il valore restituito dall&#8217;interprete <em>JavaScript</em> è quello denotato dall&#8217;espressione matematica (\(\frac{8}{3} \cdot 10^{16} = 2,\bar{6}\cdot 10^{16}\))? È lo stesso per entrambe le espressioni? Se no, sai spiegarti il perché?</p>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Esercizio A-1.1.7</div>
<div class="content">
<div class="paragraph">
<p>Aggiungere le parentesi alle espressioni sottostanti per indicare l&#8217;ordine di valutazione usato dall&#8217;interprete <em>JavaScript</em>.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>100000 * 200000 * 400000 / 3 * 10 + 1</p>
</li>
<li>
<p>100000 * 200000 * 400000 / 3 * 10 + 1 + 1</p>
</li>
<li>
<p>100000 * 200000 * 400000 / 3 * 10 + 1 + 1 + 1</p>
</li>
<li>
<p>100000 * 200000 * 400000 / 3 * 10 + 1 + 1 + 1 + 1</p>
</li>
<li>
<p>100000 * 200000 * 400000 / 3 * 10 + 1 + 1 + 1 + 1 + 1</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Il valore restituito dall&#8217;interprete <em>JavaScript</em> è quello denotato dall&#8217;espressione matematica? Se no, sai spiegarti il perché?</p>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Esercizio A-1.1.8</div>
<div class="content">
<div class="paragraph">
<p>Dichiarare i valori costanti della tabella seguente:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Nome</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Valore</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">raggio</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>1</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">pi_greco</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>3.141592653589793</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">diametro</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>\(2 \cdot \text{raggio}\)</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">perimetro</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>\(\text{pi\_greco} \cdot \text{diametro}\)</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">area</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>\(\text{pi\_greco} \cdot \text{raggio}^2\)</p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Verificare che abbiano il valore atteso.</p>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Esercizio A-1.1.9</div>
<div class="content">
<div class="paragraph">
<p>Dichiara una costante <code>E</code> di valore 2.718281828459045.
Quale valore viene restituito dalla dichiarazione? Quale valore è prodotto dalla valutazione di <code>E</code>?</p>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Esercizio A-1.1.10</div>
<div class="content">
<div class="paragraph">
<p>Quale valore viene restituito dalla seguente sequenza di istruzioni?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">1 + 2;
3;
4 * 5;</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Esercizio A-1.1.11</div>
<div class="content">
<div class="paragraph">
<p>Disegna l&#8217;albero di valutazione per la seguente espressione?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">2 * 10 - 19.62 * 7;</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Esercizio A-1.1.12</div>
<div class="content">
<div class="paragraph">
<p>Si scriva una funzione <code>perimetro_triangolo</code> che calcola il perimetro di un triangolo
e che ha tre argomenti che si riferiscono alle misure dei lati;</p>
</div>
<div class="paragraph">
<p>La si applichi per conoscere il perimetri di un triangolo di lati 3, 4 e 5 m.</p>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Esercizio A-1.1.13</div>
<div class="content">
<div class="paragraph">
<p>Si scriva una funzione <code>perimetro_trapezio_rettangolo</code> che calcola il perimetro di un trapezio
rettangolo dati tre argomenti che si riferiscono alle misure dei lati
perpendicolari tra loro, nell&#8217;ordine <em>base minore</em>, <em>base maggiore</em> e
altezza.</p>
</div>
<div class="paragraph">
<p>Si applici la procedura su almeno tre trapezi per evitare che la funzione sia palesemente errata.</p>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Esercizio A-1.1.14</div>
<div class="content">
<div class="paragraph">
<p>Si considereri la generica equazione di secondo grado
\(a x^2 + b x + c = 0\) di cui vuoi calcolare il valore
\(x_1=\frac{-b-\sqrt{b^2-4 a c}}{2 a}\) supponendo
che il discriminante sia un numero non negativo.</p>
</div>
<div class="paragraph">
<p>Scrivi la funzione <code>risolvi_eq2</code> che ha come argomenti i
coefficienti <code>a</code> e <code>b</code> e il termine noto <code>c</code>.</p>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Esercizio A-1.1.15</div>
<div class="content">
<div class="paragraph">
<p>Si vuole determinare il valore assunto dal polinomio
\(a x^3 + b x^2 + c x + d\) quando assegnamo
un valore ad \(x\).</p>
</div>
<div class="paragraph">
<p>Si scriva la funzione <code>valuta_polinomio3</code> che ha per
argomenti i numeri <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code> e <code>x</code>, sfruttando
l&#8217;idea che</p>
</div>
<div class="paragraph">
<p>\(p(x) = a x^3 + b x^2 + c x + d = (((a x + b) x + c) x + d)\)</p>
</div>
<div class="paragraph">
<p>e che tale riscrittura ha come sotto-problema comune il
calcolo di \(a^\prime x + b^\prime\).</p>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Esercizio A-1.1.16</div>
<div class="content">
<div class="paragraph">
<p>Si scriva la funzione <code>minimo</code> che restituisce il minimo tra
i valori dei due argomenti.</p>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Esercizio A-1.1.17</div>
<div class="content">
<div class="paragraph">
<p>Si scriva la funzione <code>massimo3</code> che restituisce il massimo tra
i valori dei suoi 3 argomenti. Per calcolarlo usa la funzione
<code>massimo</code> che calcola il massimo tra due argomenti.</p>
</div>
<div class="paragraph">
<p>Considera che \(\max(a, b, c) = \max(\max(a, b), c)\).</p>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Esercizio A-1.1.18</div>
<div class="content">
<div class="paragraph">
<p>Si scriva una funzione <code>somma_fino_a</code> con un argomento <code>n</code>
che somma tutti i numeri naturali compresi tra 1 e <code>n</code>.</p>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Esercizio A-1.1.19</div>
<div class="content">
<div class="paragraph">
<p>Si scriva una funzione che somma tutti i termini del tipo
\(2^{-n}, n \in \mathbb{N}\) arrrestandosi quando il prossimo addendo
è inferiore a \(10^{-16}\).</p>
</div>
<div class="paragraph">
<p>Il valore da trovare approssima \(1 + \frac{1}{2} + \frac{1}{4} + \frac{1}{8} + \frac{1}{16} + \cdots\)</p>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Esercizio A-1.1.20</div>
<div class="content">
<div class="paragraph">
<p>Scrivere una funzione <code>pi</code> che calcola il quadruplo della
sua funzione definita internamente <code>pi_quarti</code>.</p>
</div>
<div class="paragraph">
<p><code>pi_quarti</code> calcola la somma a segni alterni dei reciproci
dei numeri naturali dispari partendo da \(+1\),
ossia</p>
</div>
<div class="paragraph">
<p>\(1 - \frac{1}{3} + \frac{1}{5} - \frac{1}{7} + \frac{1}{9} - \cdots\)</p>
</div>
<div class="paragraph">
<p>Come criterio di arresto considera che la distanza tra il
valore già calcolato e il prossimo valore non deve essere
maggiore di \(10^{-6}\).</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="s_funzioni_e_processi"><a class="anchor" href="#s_funzioni_e_processi"></a>1.2. Le funzioni e i processi da esse generati</h3>
<div class="paragraph">
<p>Nel primo paragrafo abbiamo considerato gli elementi della programmazione: abbiamo usato operazioni aritmetiche primitive, abbiamo combinato queste operazioni e abbiamo astratto queste operazioni composite dichiarandole come funzioni composte. Ma ciò non è abbastanza per permetterci di dire che sappiamo programmare. La nostra situazione è analoga a quella di colui il quale ha imparato le regole con si muovono i pezzi negli scacchi ma non sa nulla di aperture, tattiche o strategie tipiche. Come il giocatore di scacchi alle prime armi non è ancora a conoscenza degli schemi comuni e non di sa quali mosse valga la pena fare, così a noi manca la conoscenza di quali funzioni meritano di essere dichiarate. Ci manca l&#8217;esperienza per prevedere le conseguenze del fare una mossa (eseguire una funzione).</p>
</div>
<div class="paragraph">
<p>La capacità di visualizzare le conseguenze delle azioni in esame è cruciale per diventare un programmatore esperto, così come lo è in qualsiasi attività creativa e progettuale.
Nella programmazione stiamo pianificando il corso delle azioni che un processo intraprende mediante un programma. Per diventare esperti, dobbiamo imparare a visualizzare i processi generati da vari tipi di funzioni.
Solo dopo aver sviluppato una tale abilità possiamo imparare a costruire in modo affidabile programmi che presentano il comportamento desiderato.</p>
</div>
<div class="paragraph">
<p>Una funzione è un modello per l'<em>evoluzione locale</em> di un processo computazionale.
Specifica come ogni fase del processo è costruita sulla fase precedente.
Vorremmo essere in grado di fare dichiarazioni sul <em>comportamento complessivo</em> o globale di un processo la cui evoluzione locale è stata specificata da una funzione.
Questo è, in generale, molto difficile ma possiamo almeno provare a descrivere alcuni schemi tipici dell&#8217;evoluzione del processo.</p>
</div>
<div class="paragraph">
<p>In questa sezione esamineremo alcune forme comuni di processi generati da semplici funzioni.
Indagheremo anche le velocità con cui questi processi consumano le risorse computazionali di tempo e spazio.
Le funzioni che considereremo sono molto semplici.</p>
</div>
<div class="sect3">
<h4 id="sp_ricorsione_iterazione"><a class="anchor" href="#sp_ricorsione_iterazione"></a>1.2.1. Ricorsione e iterazione lineari</h4>
<div class="paragraph">
<p>Iniziamo considerando la funzione fattoriale, definita da</p>
</div>
<div class="paragraph">
<p>\(n \cdot (n-1) \cdot (n-2) \cdots 3 \cdot 2 \cdot 1\)</p>
</div>
<div class="paragraph">
<p>Esistono molti modi per calcolare il fattoriale. Un modo è utilizzare l&#8217;osservazione che \(n!\) è uguale a \(n \cdot (n-1)!\) per qualsiasi numero intero positivo \(n\):</p>
</div>
<div class="stemblock">
<div class="content">
\[n! = n\cdot \left[ (n-1) \cdot (n-2) \cdots 3 \cdot 2 \cdot 1 \right] = n \cdot (n-1)!\]
</div>
</div>
<div class="paragraph">
<p>Pertanto, possiamo calcolare \(n!\) calcolando \((n-1)!\) e moltiplicando il risultato di \(n\). Se aggiungiamo la clausola che \(1!\) è uguale a \(1\), questa osservazione si traduce direttamente nella funzione:</p>
</div>
<div class="listingblock">
<div class="title">Elenco 4. Definizione della funzione fattoriale</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function fattoriale (n) {
	return n === 1
			? 1
			: n * fattoriale (n - 1);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usando il modello di sostituzione del <a href="#sp_modello_sostituzione">paragrafo 1.1.5</a> si ottiene il processo illustrato nella <a href="#fig1_3">Figura 3</a>.</p>
</div>
<div id="fig1_3" class="imageblock">
<div class="content">
<img src="https://sicp.comp.nus.edu.sg/chapters/img_javascript/ch1-Z-G-7.svg" alt="ch1 Z G 7">
</div>
<div class="title">Figura 3. Un processo ricorsivo lineare per calcolare 6!</div>
</div>
<div class="paragraph">
<p>Possiamo assumere un diverso punto di vista per il calcolo del fattoriale.
Potremmo descrivere una regola per il calcolo di \(n!\)
specificando che prima moltiplichiamo 1 per 2, poi moltiplichiamo il
risultato per 3, poi per 4 e così via fino a raggiungere \(n\).
Più formalmente, manteniamo un prodotto parziale, insieme a un <em>contatore</em>
che conta da 1 a \(n\).
Possiamo descrivere il calcolo dicendo che il contatore e il prodotto cambiano simultaneamente da un passaggio all&#8217;altro in base alla regola</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{eqnarray*}
  \mathrm{prodotto}  &amp; \leftarrow &amp; \mathrm{contatore} \cdot \mathrm{prodotto} \\
  \mathrm{contatore} &amp; \leftarrow &amp; \mathrm{contatore} + 1
\end{eqnarray*}\]
</div>
</div>
<div class="paragraph">
<p>e che \(n!\) è il valore del prodotto quando il contatore supera \(n\).</p>
</div>
<div class="paragraph">
<p>Ancora una volta, possiamo riscrivere la nostra descrizione come funzione per calcolare la dichiarazione della funzione interna:</p>
</div>
<div class="listingblock">
<div class="title">Elenco 5. Definizione della funzione fattoriale come processo iterativo lineare</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function fattoriale (n) {
    function iter (prodotto, contatore) {
        return contatore &gt; n
               ? prodotto
               : iter(contatore * prodotto,
                      contatore + 1);
   }
   return iter(1, 1);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Come sopra, possiamo usare il modello di sostuzione per visualizzare il processo di calcolo di \(6!\) come mostrato in <a href="#fig1_4">Figura 4</a>.</p>
</div>
<div id="fig1_4" class="imageblock">
<div class="content">
<img src="https://sicp.comp.nus.edu.sg/chapters/img_javascript/ch1-Z-G-10.svg" alt="ch1 Z G 10">
</div>
<div class="title">Figura 4. Un processo iterativo lineare per calcolare il fattoriale di 6</div>
</div>
<div class="paragraph">
<p>Confronta i due processi. Da un punto di vista, non sembrano così diversi. Entrambi calcolano la stessa funzione matematica sullo stesso dominio e ciascuno richiede un numero di passaggi proporzionale a \(n\) per calcolare \(n!\). In effetti, entrambi i processi eseguono anche la stessa sequenza di moltiplicazioni, ottenendo la stessa sequenza di prodotti parziali. D&#8217;altra parte, quando consideriamo le forme dei due processi, scopriamo che si evolvono in modo abbastanza diverso.</p>
</div>
<div class="paragraph">
<p>Considera il primo processo. Il modello di sostituzione rivela una forma con un&#8217;espansione seguita da una contrazione, indicata dalla freccia nella <a href="#fig1_3">Figura 3</a>. L&#8217;espansione avviene quando il processo crea una catena di <strong>operazioni differite</strong> (in questo caso, una catena di moltiplicazioni). La contrazione si verifica quando le operazioni vengono effettivamente eseguite. Questo tipo di processo, caratterizzato da una catena di operazioni differite, è chiamato <strong>processo ricorsivo</strong>. L&#8217;esecuzione di questo processo richiede che l&#8217;interprete tenga traccia delle operazioni da eseguire in seguito. Nel calcolo di \(n!\), la lunghezza della catena di moltiplicazioni differite, e quindi la quantità di informazioni necessarie per tenerne traccia, cresce linearmente con \(n\) (è proporzionale a \(n\)), proprio come il numero di passi. Tale processo è chiamato processo ricorsivo lineare.</p>
</div>
<div class="paragraph">
<p>Al contrario, il secondo processo né cresce né si restringe. Ad ogni passaggio, tutto ciò di cui abbiamo bisogno per tenere traccia, per ogni \(n\), sono i valori correnti dei nomi <em>prodotto</em>, contatore<em> e </em>contatore_max__. Questo è un <strong>processo iterativo</strong>. In generale, un processo iterativo è quello il cui stato può essere riassunto dai valori di un numero fisso di nomi di stato, insieme a una regola fissa che descrive come i valori dei nomi di stato dovrebbero essere aggiornati mentre il processo si sposta da stato a stato e un controllo finale (facoltativo) che specifica le condizioni alle quali il processo dovrebbe terminare. Nel calcolo di \(n!\), Il numero di passaggi richiesti cresce linearmente con \(n\). Tale processo è chiamato <strong>processo iterativo lineare</strong>.</p>
</div>
<div class="paragraph">
<p>Il contrasto tra i due processi può essere visto in un altro modo. Nel caso iterativo, i valori dei nomi degli stati forniscono una descrizione completa dello stato del processo in qualsiasi momento. Se interrompessimo il calcolo tra i passaggi, tutto ciò che dovremmo fare per riprendere il calcolo è fornire all&#8217;interprete i valori dei tre nomi di stato. Questo non accade  con il processo ricorsivo. In questo caso ci sono alcune informazioni nascoste aggiuntive, gestite dall&#8217;interprete e non contenute nei nomi degli stati, che indicano dove si trova il processo della catena di operazioni differite. Più lunga è la catena, più informazioni devono essere mantenute.</p>
</div>
<div class="paragraph">
<p>Nel confrontare iterazione e ricorsione, dobbiamo stare attenti a non confondere la nozione di processo ricorsivo con la nozione di <strong>funzione ricorsiva</strong>. Quando descriviamo una funzione come ricorsiva, ci riferiamo al fatto sintattico che la dichiarazione di funzione si riferisce (direttamente o indirettamente) alla funzione stessa. Ma quando descriviamo un <strong>processo</strong> come seguendo un modello che è, diciamo, <strong>linearmente ricorsivo</strong>, stiamo parlando di come il processo si evolve, non della sintassi di come una funzione è scritta. Può sembrare inquietante il fatto che usiamo una funzione ricorsiva per generare un processo iterativo. Tuttavia, il processo è davvero iterativo: il suo stato viene catturato completamente dai suoi tre nomi di stato e un interprete deve tenere traccia di soli tre nomi per eseguire il processo.</p>
</div>
<div class="paragraph">
<p>Un motivo per cui la distinzione tra processo e funzione può essere fonte di confusione è che la maggior parte delle implementazioni di linguaggi comuni (tra cui Ada, Pascal e C) sono progettate in modo tale che l&#8217;interpretazione di qualsiasi funzione ricorsiva consuma una quantità di memoria che cresce con il numero di chiamate di funzione, anche quando il processo descritto è, in linea di principio, iterativo. Di conseguenza, questi linguaggi possono descrivere i processi iterativi solo ricorrendo a costrutti iterativi per scopi speciali come <code>do</code>, <code>repeat</code>, <code>until</code>, <code>for</code> e <code>while</code>.</p>
</div>
<div class="paragraph">
<p>Se un interprete esegue un processo iterativo in uno spazio costante, anche se il processo iterativo è descritto da una funzione ricorsiva si dice che implementa la ricorsione in coda. Con un&#8217;implementazione ricorsiva in coda, l&#8217;iterazione può essere espressa usando il normale meccanismo di chiamata di funzione, in modo che speciali costrutti di iterazione siano utili solo come zucchero sintattico.</p>
</div>
<div class="exampleblock">
<div class="title">Esercizio 1.9.Riconoscere i processi iterativi e ricorsivi</div>
<div class="content">
<div class="paragraph">
<p>Le due funzioni seguenti definiscono entramber un metodo per sommare due
numeri naturali nei temini della funzione <code>inc</code>, che incrementa il suo
argomento di 1, e della funzione <code>dec</code>, che decrementa il suo argomento di 1.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function piu(a, b) {  <i class="conum" data-value="1"></i><b>(1)</b>
    return a === 0 ? b : inc(piu(dec(a), b));
}
function piu(a, b) {  <i class="conum" data-value="2"></i><b>(2)</b>
    return a === 0 ? b : piu(dec(a), inc(b));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usando il modello di sostituzione, illustra il processo generato dalle due funzioni  valutando <code>piu (4, 5);</code>. Questi processi sono iterativi o ricorsivi?</p>
</div>
</div>
</div>
<details>
<summary class="title">Click per vedere le soluzioni dell&#8217;esercizio</summary>
<div class="content">
<div class="paragraph">
<p>Il processo generato dalla prima funzione è recursivo.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">piu(4, 5)
4 === 0 ? 5 : inc(piu(dec(4), 5))
inc(piu(dec(4), 5))
...
inc(piu(3, 5))
...
inc(inc(piu(2, 5)))
...
inc(inc(inc(piu(1, 5))))
...
inc(inc(inc(inc(piu(0, 5)))))
inc(inc(inc(inc( 0 === 0 ? 5 : inc(piu(dec(0), 5))))))
inc(inc(inc(inc( 5 ))))
inc(inc(inc( 6 )))
inc(inc( 7 ))
inc( 8 )
9</code></pre>
</div>
</div>
<div class="paragraph">
<p>Il processo generato dalla seconda funzione è iterativo.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">piu(4, 5)
4 === 0 ? 5 : piu(dec(4), inc(5))
piu(dec(4), inc(5))
...
piu(3, 6)
...
piu(2, 7)
...
piu(1, 8)
...
piu(0, 9)
0 === 0 ? 9 : piu(dec(0), inc(9))
9</code></pre>
</div>
</div>
</div>
</details>
<div class="exampleblock">
<div class="title">Esercizio 1.10. La funzione (matematica) di Ackermann</div>
<div class="content">
<div class="paragraph">
<p>La funzione seguente calcola una funzione matematica chiamata
funzione di Ackermann.</p>
</div>
<div class="listingblock">
<div class="title">Elenco 6. Funzione di Ackermann</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function A(x,y) {
    return y === 0
           ? 0
           : x === 0
             ? 2 * y
             : y === 1
               ? 2
               : A(x - 1, A(x, y - 1));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Come vengono valutate le seguenti espressioni?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">A(1, 10);
A(2, 4);
A(3, 3);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Considera le seguenti funzioni, in cui <code>A</code> è la funzione definita sopra:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function f(n) {
    return A(0, n);
}
function g(n) {
    return A(1, n);
}
function h(n) {
    return A(2, n);
}
function k(n) {
   return 5 * n * n;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Fornisci una breve definizione matematica delle funzioni <code>f</code>, <code>g</code> e <code>h</code>
calcolate su argomenti interi <strong>positivi</strong> \(n\).
Ad esempio, \(k(n)\) calcola \(5n^2\).</p>
</div>
</div>
</div>
<details>
<summary class="title">Click per vedere le soluzioni dell&#8217;esercizio</summary>
<div class="content">
<div class="stemblock">
<div class="content">
\[A (x, y) = \begin{cases}
    0  &amp; \text {se } y = 0 \\
    2y &amp; \text {se } x = 0 \\
    2  &amp; \text {se } y = 1 \\
    A(x - 1, A(x, y - 1) &amp; \text{altrimenti}
\end{cases}\]
</div>
</div>
<div class="paragraph">
<p>La funzione \(f(n)\) calcola \(2 \cdot n\),
e deriva direttamente dalla valutazione della seconda regola.</p>
</div>
<div class="paragraph">
<p>La funzione \(g(n)\) calcola \(2^n\), come si ricava
considerando che \(g (1) = A (1, 1) = 2\) per la terza regola,
e che \(g (n) = A (1, n) = A \left(0, A (1, n - 1)\right) = f ( g (n -1)) = 2 \cdot g(n-1) = 2 \cdot 2 \cdot g (n - 2) = \underbrace{2 \cdot 2 \cdots  \cdot g (1)}_{n \ \text{volte}}\).</p>
</div>
<div class="paragraph">
<p>La funzione \(h(n)\) calcola \(2^{2^{\cdot^{\cdot^{\cdot^2}}}}\) dove il numero di 2 nella catena di elevamento a potenza è \(n\). Tale operazione algebrica si chiama tetrazione. Si ricava considerando che
\(h (1) = A (2, 1) = 2\) e che</p>
</div>
<div class="stemblock">
<div class="content">
\[h (n) = A (2, n) = A (1, A (2, n - 1)) = g ( h (n - 1)) = 2^{h(n -1)} = \underbrace{2^{2^{{\mathinner{
  \kern1mu\raise1pt{.}
  \kern2mu\raise4pt{.}
  \kern2mu\raise7pt{\Rule{0pt}{7pt}{0pt}.}
  \kern1mu
}}^{h(1)}}}}_{n\ \text{volte}}\]
</div>
</div>
</div>
</details>
</div>
<div class="sect3">
<h4 id="sp_ricorsione_ad_albero"><a class="anchor" href="#sp_ricorsione_ad_albero"></a>1.2.2. Ricorsione ad albero</h4>
<div class="paragraph">
<p>Un altro schema di calcolo comune è chiamato ricorsione ad albero. Ad esempio, considera di calcolare la sequenza dei numeri di Fibonacci, in cui ogni numero è la somma dei due precedenti:</p>
</div>
<div class="paragraph">
<p>\(0, 1, 1, 2, 3, 5, 8, 13, 21, \ldots\)</p>
</div>
<div class="paragraph">
<p>Un numero di Fibonacci, in generale, può essere definito dalla regola:</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{eqnarray*}
          \textrm{Fib}(n) &amp; = &amp; \left\{ \begin{array}{ll}
          0   &amp;  \mbox{se } n=0\\
          1   &amp; \mbox{se } n=1\\
          \textrm{Fib}(n-1)+\textrm{Fib}(n-2) &amp; \mbox{altrimenti}
          \end{array}
          \right.
\end{eqnarray*}\]
</div>
</div>
<div class="paragraph">
<p>Possiamo tradurre immediatamente questa definizione in una funzione ricorsiva per il calcolo dei numeri di Fibonacci:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function fib(n) {
    return n === 0
           ? 0
           : n === 1
             ? 1
             : fib(n - 1) + fib(n - 2);
}</code></pre>
</div>
</div>
<div id="fig1_5" class="paragraph">
<div class="title">Il processo ricorsivo ad albero generato nel calcolo di <code>fib (5)</code></div>
<p><span class="image"><img src="https://sicp.comp.nus.edu.sg/chapters/img_javascript/ch1-Z-G-13.svg" alt="ch1 Z G 13"></span></p>
</div>
<div class="paragraph">
<p>Considera lo schema di evoluzione di questo calcolo. Per calcolare <code>fib (5)</code>, calcoliamo <code>fib (4)</code> e <code>fib (3)</code>. Per calcolare <code>fib (4)</code>, calcoliamo <code>fib (3)</code> e <code>fib (2)</code>. In generale, il processo evoluto assomiglia ad un albero, come mostrato nella <a href="#fig1_5">Il processo ricorsivo ad albero generato nel calcolo di <code>fib (5)</code></a>. Si noti che i rami si dividono in due ad ogni livello (tranne che in basso); ciò riflette il fatto che la funzione <code>fib</code> si richiama due volte ogni volta che viene invocata.</p>
</div>
<div class="paragraph">
<p>Questa definizione della funzione è il prototipo della ricorsione ad albero, e quindi è istruttiva, ma questo è un modo terribile di calcolare i numeri di Fibonacci in quanto esegue un calcolo in modo ridondante. Si noti nella <a href="#fig1_5">Il processo ricorsivo ad albero generato nel calcolo di <code>fib (5)</code></a> che l&#8217;intero calcolo di <code>fib (3)</code>, quasi metà del lavoro, è duplicato. In effetti, non è difficile dimostrare che il numero di volte in cui la funzione calcolerà <code>fib (1)</code> o <code>fib (0)</code> (il loro numero è il numero di foglie dell&#8217;albero illustrato in figura) è precisamente \(\textrm{Fib} (n + 1)\). Per avere un&#8217;idea di quanto questo sia oneroso, si può dimostrare che il valore di \(\textrm{Fib} (n)\) cresce esponenzialmente con \(n\). Più precisamente, \(\textrm{Fib} (n)\) è il numero intero più vicino a \(\phi^{n} /\sqrt{5}\), dove</p>
</div>
<div class="paragraph">
<p>\(\phi=(1+\sqrt{5})/2\approx 1.6180\)</p>
</div>
<div class="paragraph">
<p>è la <em>sezione aurea</em>, che soffisfa l&#8217;equazione</p>
</div>
<div class="paragraph">
<p>\(\phi^{2} =\phi + 1\)</p>
</div>
<div class="paragraph">
<p>Pertanto, il processo utilizza una serie di passaggi il cui numero cresce in modo esponenziale con il valore dell&#8217;argomento. D&#8217;altra parte, lo spazio richiesto cresce solo in modo lineare con l&#8217;argomento, perché dobbiamo tenere traccia solo di quali nodi sono più in alto nell&#8217;albero in qualsiasi punto del calcolo. In generale, il numero di passaggi richiesti da un processo ricorsivo ad albero sarà proporzionale al numero di nodi nella struttura, mentre lo spazio richiesto sarà proporzionale alla profondità massima della struttura.</p>
</div>
<div class="paragraph">
<p>Possiamo anche formulare un processo iterativo per calcolare i numeri di Fibonacci. L&#8217;idea è di utilizzare una coppia di numeri interi \(a\) e \(b\), inizializzati su \(\textrm{Fib} (1) = 1\) e \(\textrm{Fib} (0) = 0\), e di applicare ripetutamente le trasformazioni simultanee</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{eqnarray*}
  a &amp; \leftarrow &amp; a+b \\ \nonumber
  b &amp; \leftarrow &amp; a \nonumber
\end{eqnarray*}\]
</div>
</div>
<div class="paragraph">
<p>Non è difficile dimostrare che, dopo aver applicato questa trasformazione \(n\) volte, \(a\) e \(b\) saranno uguali, rispettivamente, a \(\textrm{Fib} (n + 1)\) e \(\textrm{Fib} (n)\). Quindi, possiamo calcolare i numeri di Fibonacci in modo iterativo usando la funzione</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function fib(n) {
    return fib_iter(1, 0, n);
}
function fib_iter(a, b, count) {
    return count === 0
           ? b
           : fib_iter(a + b, a, count - 1);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Questo secondo metodo per calcolare \(\textrm{Fib} (n)\) è un&#8217;iterazione lineare. La differenza nel numero di passaggi richiesti dai due metodi - uno lineare in \(n\), uno in rapida crescita come \(\textrm{Fib} (n)\) stesso - è enorme, anche per argomenti relativamente piccoli.</p>
</div>
<div class="paragraph">
<p>Non si deve concludere da ciò che i processi ricorsivi ad albero siano inutili. Quando consideriamo i processi che operano su dati strutturati gerarchicamente piuttosto che su numeri, scopriremo che la ricorsione dell&#8217;albero è uno strumento naturale e potente. Ma anche nelle operazioni numeriche, i processi ricorsivi ad albero possono essere utili per aiutarci a comprendere e progettare i programmi. Ad esempio, sebbene la prima funzione <code>fib</code> sia molto meno efficiente della seconda, è più semplice, essendo poco più di una traduzione in JavaScript della definizione della sequenza di Fibonacci. Per formulare l&#8217;algoritmo iterativo è necessario notare che il calcolo potrebbe essere trasformato in iterazione con tre variabili di stato.</p>
</div>
<div class="sect4">
<h5 id="_esempio_contare_il_numero_di_cambi"><a class="anchor" href="#_esempio_contare_il_numero_di_cambi"></a>Esempio: Contare il numero di cambi</h5>
<div class="paragraph">
<p>Basta poco ingegno per elaborare l&#8217;algoritmo iterativo di Fibonacci. Al contrario, considera il seguente problema: in quanti modi diversi possiamo cambiare 1 euro con le monete da 50, 20, 10, 2 e un centesimo? Più in generale, possiamo scrivere una funzione per calcolare il numero di modi per cambiare una determinata quantità di denaro?</p>
</div>
<div class="paragraph">
<p>Questo problema ha una soluzione semplice come funzione ricorsiva. Supponiamo di pensare ai tipi di monete disponibili disposti in un certo ordine. Vale la seguente relazione:</p>
</div>
<div class="paragraph">
<p>Il numero di modi per cambiare l&#8217;ammontare \(a\) usando \(n\) tipi di monete è uguale</p>
</div>
<div class="ulist">
<ul>
<li>
<p>il numero di modi per cambiare l&#8217;ammontare \(a\) usando tutto tranne il primo tipo di moneta, più</p>
</li>
<li>
<p>il numero di modi per cambiare ammontare \(a - d\)  usando tutti gli \(n\) tipi di monete, dove \(d\) è il valore del primo tipo di moneta.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Per capire perché questo è vero, osserva che i modi per realizzare il cambio possono essere divisi in due gruppi: quelli che non usano nessuna delle monete del primo tipo di moneta e quelli che lo fanno. Pertanto, il numero totale di modi per cambiare un determinato importo è uguale al numero di modi per cambiare l&#8217;importo senza utilizzare il primo tipo di moneta, più il numero di modi per fare il cambio supponendo che utilizziamo il primo tipo di moneta. Ma quest&#8217;ultimo numero è uguale al numero di modi per effettuare il cambio dell&#8217;importo che rimane dopo aver usato una moneta del primo tipo.</p>
</div>
<div class="paragraph">
<p>Possiamo, pertanto, ricondurre in modo ricorsivo il problema di cambiare un determinato importo in problemi di cambio di importi minori o che usano meno tipi di monete. Considera attentamente questa regola di riduzione e convinciti che possiamo usarla per descrivere un algoritmo se specifichiamo i seguenti casi degeneri:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Se \(a\) è esattamente 0, dovremmo considerarlo come 1 modo per fare il cambio.</p>
</li>
<li>
<p>Se \(a\) è minore di 0, dovremmo considerarlo come 0 modi per apportare modifiche.</p>
</li>
<li>
<p>Se \(0\) è 0, dovremmo considerarlo come 0 modi per apportare modifiche.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Possiamo facilmente tradurre questa descrizione in una funzione ricorsiva:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function conta_cambi(importo) {
    return cc(importo, 5);
}
function cc(importo, num_tagli) {
    return importo === 0
           ? 1
           : importo &lt; 0 ||
             num_tagli === 0
             ? 0
             : cc(importo, num_tagli - 1)
               +
               cc(importo - primo_valore_nominale(
                               num_tagli),
                  num_tagli);
}
function primo_valore_nominale (num_tagli) {
    return num_tagli === 1 ? 1 :
           num_tagli === 2 ? 5 :
           num_tagli === 3 ? 10 :
           num_tagli === 4 ? 25 :
           num_tagli === 5 ? 50 : 0;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>La funzione <code>primo_valore_nominale</code> prende come input il numero di tipi di monete disponibili e restituisce il valore del primo tipo. Qui stiamo pensando alle monete come disposte in ordine dal più grande al più piccolo, ma qualsiasi ordine funziona. Ora possiamo rispondere alla nostra domanda originale sul cambio di un dollaro:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">conta_cambi(100);</code></pre>
</div>
</div>
<div class="paragraph">
<p>La funzione <code>conta_cambi</code> genera un processo ricorsivo ad albero con ridondanze simili a quelle della nostra prima implementazione di <code>fib</code>. (Ci vorrà un po' di tempo per calcolare quel 292). D&#8217;altra parte, non è ovvio come progettare un algoritmo migliore per calcolare il risultato e lasciamo questo problema come una sfida.</p>
</div>
<div class="exampleblock">
<div class="title">Esercizio 1.11. Saper scrivere funzioni che generano processi ricorsivi ad albero e iterativi</div>
<div class="content">
<div class="paragraph">
<p>Una funzione \(f\) è definita dalle regole secondo le quali \(f(n) = n\) se \(n &lt; 3\) e
\(f(n)= {f(n-1)} + 2 \cdot f(n-2) + 3 \cdot f(n-3)\) se \(n \ge 3\).</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Scrivi una funzione JavaScript che  calcola \(f\) per mezzo di un processo ricorsivo.</p>
</li>
<li>
<p>Scrivi una funzione JavaScript che  calcola \(f\) per mezzo di un processo iterativo.</p>
</li>
</ol>
</div>
</div>
</div>
<details>
<summary class="title">Click per vedere le soluzioni dell&#8217;esercizio</summary>
<div class="content">
<div class="paragraph">
<p>La soluzione ricorsiva è una semplice traduzione dal formalismo matematico a quello del JavaScript.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function f (n) {
    return n &lt; 3
           ? n
           : f (n - 1) +
	     2 * f (n - 2) +
	     3 * f (n - 3);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>La versione iterativa richiede una funzione ausiliaria e qualche ragionamento.
Per calcolare la funzione con argomento il numero 3, devono essere definite \(f (2)) = 2\), \(f (1) = 1\) e \(f (0) = 0\); più in generale, per calcolare il valore \(n\), avremo bisogno di \(f (n - 1), f (n - 2)\) e \(f (n - 3)\). Identificheremo nel codice JavaScript tali valori con i nomi <code>fn1</code>, <code>fn2</code> e <code>fn3</code>. Il numero di valutazioni dell&#8217;espressione composta per il calcolo del valore <code>fn1</code> è pari al valore dell&#8217;argomento meno 2, ad esempio se l&#8217;argomento è 3 si deve effettuare solo il calcolo di \(2 + 2\cdot 1 + 3\cdot 0 = 4\). Possiamo usare un contatore che ci indichi quante altre valutazioni mancano per la fine del calcolo.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function f (n) {
    function f_iter (fn1, fn2, fn3, contatore) {
        return contatore === 0
            ? fn1
            : f_iter (fn1 + 2 * fn2 + 3 * fn3, fn1, fn2, contatore - 1);
    }
    return n &lt; 3
           ? n
           : f_iter(2, 1, 0, n - 2);
}</code></pre>
</div>
</div>
</div>
</details>
<div class="exampleblock">
<div class="title">Esercizio 1.12. Ricavare una definizione induttiva</div>
<div class="content">
<div class="paragraph">
<p>La seguente disposizione di numeri è chiamata triangolo di Tartaglia
(triangolo di Pascal nella versione originale del testo).</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{array}{rrrrrrrrr}
    &amp;   &amp;   &amp;   &amp; 1 &amp;   &amp;   &amp;   &amp;     \\
    &amp;   &amp;   &amp;1  &amp;   &amp;1  &amp;   &amp;   &amp;     \\
    &amp;   &amp;1  &amp;   &amp; 2 &amp;   &amp;1  &amp;   &amp;     \\
    &amp;1  &amp;   &amp;3  &amp;   &amp;3  &amp;   &amp;1  &amp;     \\
 1  &amp;   &amp; 4 &amp;   &amp; 6 &amp;   &amp; 4 &amp;   &amp; 1   \\
    &amp;   &amp;   &amp;   &amp; \ldots &amp; &amp; &amp; &amp;
\end{array}\]
</div>
</div>
<div class="paragraph">
<p>I numeri sui lati del triangolo sono tutti 1 e ogni numero
dentro il triangolo è la somma dei due numeri che lo sovrastano.
Gli elementi del triangolo di Tartaglia sono detti <em>coefficienti binomiali</em>
in quanto la riga \(n\)-esima è formata dai coefficienti dei termini dell&#8217;espansione di \((x+y)^n\).</p>
</div>
<div class="paragraph">
<p>Scrivi una funzione JavaScript che calcoli gli elementi del triangolo di Tartaglia per mezzo di un processo ricorsivo. Considera due argomenti, la riga e la posizione all&#8217;interno della riga.</p>
</div>
</div>
</div>
<details>
<summary class="title">Click per vedere le soluzioni dell&#8217;esercizio</summary>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function triangolo_tartaglia(riga, indice) {
    return indice &gt; riga
           ? false
           : indice === 1 || indice === riga
             ? 1
             : triangolo_tartaglia(riga - 1, indice - 1)
	       +
	       triangolo_tartaglia(riga - 1, indice);
}</code></pre>
</div>
</div>
</div>
</details>
<div class="exampleblock">
<div class="title">Esercizio 1.13. Fornire una dimostrazione <strong>(DIFFICILE)</strong></div>
<div class="content">
<div class="paragraph">
<p>Dimostra che \(\textrm{Fib}(n)\) è l&#8217;intero più vicino a \(\phi^n/\sqrt{5}\), dove \(\phi= (1+\sqrt{5})/2\).</p>
</div>
<div class="paragraph">
<p>Suggerimento: sia \(\psi= (1-\sqrt{5})/2\). Usa l&#8217;induzione e la definizione della successione dei numeri di Fibonacci per dimostrare che \(\textrm{Fib}(n)=(\phi^n -\psi^n)/\sqrt{5}\).</p>
</div>
</div>
</div>
<details>
<summary class="title">Click per vedere le soluzioni dell&#8217;esercizio</summary>
<div class="content">
<div class="paragraph">
<p>Si veda <a href="https://codology.net/post/sicp-solution-exercise-1-13/" class="bare">https://codology.net/post/sicp-solution-exercise-1-13/</a></p>
</div>
</div>
</details>
</div>
</div>
<div class="sect3">
<h4 id="sp_tassi_di_crescita"><a class="anchor" href="#sp_tassi_di_crescita"></a>1.2.3. Tassi di crescita</h4>
<div class="paragraph">
<p>Gli esempi precedenti mostrano che i processi possono differire notevolmente nelle velocità con cui consumano risorse computazionali.
Un modo per descrivere questa differenza è usare la nozione di <strong>tasso di crescita</strong> per ottenere una misura grossolana delle risorse richieste da un processo man mano che gli input diventano più grandi.</p>
</div>
<div class="paragraph">
<p>Sia \(n\) sia un parametro che misura la <em>dimensione</em> del problema, e sia \(R( n)\) la quantità di risorse che il processo richiede per un problema di dimensione \(n\).
Nei nostri esempi precedenti abbiamo preso \(n\) uguale al numero per il quale una determinata funzione deve essere calcolata, ma ci sono altre possibilità.
Ad esempio, se il nostro obiettivo è calcolare un&#8217;approssimazione alla radice quadrata di un numero, potremmo scegliere che \(n\) è il numero di cifre richieste per l&#8217;accuratezza.
In generale ci sono una serie di proprietà del problema rispetto alle quali sarà desiderabile analizzare un determinato processo.
Allo stesso modo, \(R ( n)\) potrebbe misurare il numero di registri di memoria utilizzati, il numero di operazioni elementari della macchina eseguite e così via.
Nei computer che eseguono solo un numero fisso di operazioni alla volta, il tempo richiesto sarà proporzionale al numero di operazioni elementari della macchina eseguite.</p>
</div>
<div class="paragraph">
<p>Diciamo che \(R(n)\) ha un tasso di crescita \(\Theta(f(n))\), che scriviamo con la notazione \(R(n)=\Theta(f(n))\) (si legge <em>teta di \(f(n)\)</em>, se ci sono due costanti positive \(k_1\) e \(k_2\) che non dipendono da \(n\) tali che
\(k_1f(n) \leq R(n) \leq k_2f(n)\)
per ogni valore di \(n\) sufficientemente grande.  (In altri termini, per \(n\) grande, il valore \(R(n)\) è compreso tra \(k_1f(n)\) e \(k_2f(n)\).)</p>
</div>
<div class="paragraph">
<p>Ad esempio, il numero di passaggi del processo ricorsivo lineare per il calcolo fattoriale descritto nel <a href="#sp_ricorsione_iterazione">paragrafo 1.2.1</a> aumenta proporzionalmente all&#8217;input \(n\).
Pertanto, i passaggi richiesti per questo processo crescono come \(\Theta (n)\).
Abbiamo anche visto che lo spazio richiesto cresce come \(\Theta (n)\).
Nel processo iterativo per il calcolo del fattoriale, il numero di passaggi è ancora \(\Theta (n)\) ma lo spazio è \(\Theta (1)\)&#8201;&#8212;&#8201;cioè costante.<sup class="footnote">[<a id="_footnoteref_7" class="footnote" href="#_footnotedef_7" title="View footnote.">7</a>]</sup>
Il calcolo dei numeri di Fibonacci mediante il processo ricorsivo ad albero richiede \(\Theta (\phi^n)\) passi e spazio
\(\Theta (n)\), dove \(\phi\) è il rapporto aureo descritto nel <a href="#sp_ricorsione_ad_albero">paragrafo 1.2.2</a>.</p>
</div>
<div class="paragraph">
<p>Il tasso di crescita fornisce soltanto una rozza descrizione del comportamento di un processo.
Ad esempio, un processo che richiede \(n^2\) passi, un altro uno che ne richiede \(1000n^2\) e un terzo che ne richiede \(3n^2+10n+17\) hanno tutti il tasso di crescit \(\Theta(n^2)\).
D&#8217;altra parte, il tasso di crescita fornisce un&#8217;indicazione utile sul cosa attendere dal comportamento del processo al variare della dimensione del problema.
Per un processo lineare, \(\Theta(n)\), al raddippiare della dimensione dell&#8217;istanza avremo approssimativamente raddoppiato la quantità di risorse utilizzate.
Per un processo esponenziale, ogni incremento unitario della dimensione moltiplicherà l&#8217;utilizzo delle risorse per un fattore costante.
Nel prosieguo del paragrafo <a href="#s_funzioni_e_processi">paragrafo 1.2</a>
esamineremo due algoritmi il cui tasso di crescita è logaritmico, ossia tale che al raddoppio della dimensione del problema la richiesta delle risorse aumenta di una quantità costante.</p>
</div>
<div class="exampleblock">
<div class="title">Esercizio 1.14. Calcolare il tasso di crescita della funzione <code>conta_cambi</code></div>
<div class="content">
<div class="paragraph">
<p>Disegna l&#8217;albero che illustra il processo generato dalla funzione <code>conta_cambi</code> dell&#8217;esempio nel  <a href="#sp_ricorsione_ad_albero">paragrafo 1.2.2</a> per cambiare 11 centesimi di dollaro.
Quali sono i tassi di crescita dello spazio (memoria) e del numero di passi (tempo) usati da questo processo al variare dell&#8217;importo da cambiare?</p>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Esercizio 1.15. Calcolare il tasso di crescita di una funzione per il calcolo del seno</div>
<div class="content">
<div class="paragraph">
<p>Il seno di un angolo (specificato in radianti) può essere calcolato tramite l&#8217;approssimazione \(\mathrm{sen} x\approx x\) se \(x\) è sufficientemente piccolo, e l&#8217;identità trigonometrica \(\mathrm{sen} x=3\mathrm{sen} {\frac{x}{3}}-4\mathrm{sen}^3{\frac{x}{3}}\) per ridurre il valore dell&#8217;argomento di \(\mathrm{sen}\).
(Per gli scopi di questo esercizio un angolo è considerato <em>sufficientemente piccolo</em> quando il suo valore assoluto non è maggiore di 0,1 radianti.)
Queste idee sono racchiuse nelle funzioni seguenti:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function cubo(x) {
    return x * x * x;
}
function p(x) {
    return 3 * x - 4 * cubo(x);
}
function seno(angolo) {
    return !(valore_assoluto(angolo) &gt; 0.1)
           ? angolo
           : p(seno(angolo / 3.0));
}</code></pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Nella valutazione di <code>seno (12.15)</code> quante volte si applica la funzione <code>p</code>?</p>
</li>
<li>
<p>Quali sono i tassi di crescita dello spazio e del numero di passi (in funzione di \(a\)) impiegati dal processo generato dalla funzione <code>seno</code> quando si valuta  <code>seno (a)</code>?</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sp_elevamento_a_potenza"><a class="anchor" href="#sp_elevamento_a_potenza"></a>1.2.4. Elevamento a potenza</h4>
<div class="paragraph">
<p>Considera il problema di calcolare una potenza di un dato numero.
Vorremmo una funzione che presi come argomenti una base \(b\) e un esponente intero positivo \(n\) calcoli \(b^n\).
Un modo per farlo è tramite la definizione ricorsiva</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{aligned}
      b^{n} &amp;=&amp; b\cdot b^{n-1}\\
      b^{0} &amp;=&amp;1
\end{aligned}\]
</div>
</div>
<div class="paragraph">
<p>che si traduce facilmente nella funzione</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function potenza (b, n) {
    return n === 0 ? 1 : b * potenza (b, n - 1);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Questo è un processo ricorsivo lineare, che richiede \(\Theta (n)\) passi e \(\Theta (n)\) spazio.
Proprio come per il fattoriale, possiamo facilmente riformularlo per generare un processo iterativo lineare equivalente:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function potenza (b,n) {
    return potenza_iter (b, n, 1);
 }

function potenza_iter (b, contatore, prodotto) {
    return contatore === 0 ?
        prodotto :
        potenza_iter(b, contatore - 1, b * prodotto);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Questa versione richiede \(\Theta(n)\) passi e
\(\Theta(1)\) spazio.</p>
</div>
<div class="paragraph">
<p>Siamo in grado di calcolare le potenze in meno passaggi utilizzando degli elevamenti al quadrato uno dopo l&#8217;altro, in successione.
Per esempio, invece di calcolare \(b^8\) come
\(b\cdot(b\cdot(b\cdot(b\cdot(b\cdot(b\cdot(b\cdot b))))))\)
possiamo calcolarlo usando tre moltiplicazioni:</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{aligned}
      b^{2} &amp;=&amp; b\cdot b\\
      b^{4} &amp;=&amp; b^{2}\cdot b^{2}\\
      b^{8} &amp;=&amp; b^{4}\cdot b^{4}
\end{aligned}\]
</div>
</div>
<div class="paragraph">
<p>Questo metodo funziona bene per gli esponenti che sono potenze del 2.
Possiamo sfruttare i ripetuti elevamenti al quadrato anche nel calcolo degli elevamenti a qualsia potenza se utilizziamo la regola</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{array}{ll}
    b^{n} =(b^{n/2})^{2}  &amp; \mbox{se } n \mbox{ pari}\\
    b^{n} =b\cdot b^{n-1} &amp; \mbox{se } n &amp; \mbox{ dispari}\\
\end{array}\]
</div>
</div>
<div class="paragraph">
<p>Si può esprimere questo metodo con la funzione:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function potenza_veloce(b, n) {
    return n === 0
           ? 1
           : pari(n)
             ? quadrato(potenza_veloce(b, n / 2))
             : b * potenza_veloce(b, n - 1);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>dove il predicato per verificare se un numero intero è pari è definito in termini dell&#8217;operatore <code>%</code>, che calcola il resto della divisione tra numeri interi:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function pari(n) {
    return n % 2 === 0;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Il processo che si origina da <code>potenza_veloce</code> cresce logaritmicamente rispetto a \(n\) sia nello spazio che nel numero di passi.
Per vederlo, osserva come calcolare \(b^{2n}\) usando <code>potenza_veloce</code> richiede una sola moltiplicazione in più rispetto al calcolare \(b^n\).
Il valore dell&#8217;esponente che possiamo calcolare (la dimensione del problema) pertanto approssimativamente raddoppia con ogni nuova moltiplicazione.
Il numero di moltiplicazioni necessarie per un esponente \(n\) cresce tanto velocemente quanto il logaritmo in base 2 di \(n\).</p>
</div>
<div class="paragraph">
<p>Il processo ha un tasso di crescita \(\Theta(\log n)\). Più precisamente, il numero di moltiplicazioni richieste è 1 in meno rispetto al logaritmo in base 2 di \(n\) (numero di dimezzamenti dell&#8217;esponente, ndr), più il numero di uni nella rappresentazione binaria di \(n\) (numero di decrementi unitari dell&#8217;esponente, ndr). Questo totale è sempre minore del doppio del logaritmo in base 2 di \(n\). Le costanti arbitrarie \(k_1\) e \(k_2\) nella definizione di notazione del tasso di crescita implicano che, per un processo logaritmico, la base a cui sono presi i logaritmi non sia rilevante, quindi tutti questi processi sono descritti come \(\Theta (\log n)\).</p>
</div>
<div class="paragraph">
<p>La differenza tra i tassi di crescita \(\Theta(\log n)\) e \(\Theta(n)\) diventa sconvolgente al crescere di \(n\).
Per esempio, <code>potenza_veloce</code> nel caso di \(n=1000\) richiede soltanto 15 moltiplicazioni.<sup class="footnote">[<a id="_footnoteref_8" class="footnote" href="#_footnotedef_8" title="View footnote.">8</a>]</sup>
È anche possibile usare l&#8217;idea delle quadrature successive per escogitare un algoritmo iterativo che calcola le potenze con un numero logaritmico di passi (vedi esercizio <a href="#es_iter_expon_pro">Esercizio 1.16. Elevamento a potenza, processo iterativo in tempo logaritmico.</a>), sebbene, come spesso accade con gli algoritmi iterativi, questo non è scritto in modo così diretto come l&#8217;algoritmo ricorsivo.<sup class="footnote">[<a id="_footnoteref_9" class="footnote" href="#_footnotedef_9" title="View footnote.">9</a>]</sup></p>
</div>
<div id="es_iter_expon_pro" class="exampleblock">
<div class="title">Esercizio 1.16. Elevamento a potenza, processo iterativo in tempo logaritmico.</div>
<div class="content">
<div class="paragraph">
<p>Progettare una funzione per l&#8217;elevamento a potenza utilizzando le quadrature successive che sviluppa un processo iterativo con un numero di passi logaritmici rispetto all&#8217;esponente, come <code>potenza_veloce</code>.
(Suggerimento: usando il fatto che \((b^{n/2})^2 =(b^2)^{n/2}\), mantieni, insieme all&#8217;esponente \(n\) e alla base \(b\), una variabile di stato aggiuntiva \(a\), e definisci la trasformazione di stato di modo che il prodotto \(a \cdot b^n\) resti invariato tra uno stato e l&#8217;altro.
All&#8217;inizio del processo \(a\) vale 1, e il valore dell&#8217;applicazione della funzione è dato dal valore di \(a\) alla fine del processo.
In generale, la tecnica di definire una quantità invariante che resta la stessa da uno stato all&#8217;altro è un modo potente di pensare al progetto degli algoritmi iterativi.)</p>
</div>
</div>
</div>
<div id="es_add_expon" class="exampleblock">
<div class="title">Esercizio 1.17. Svolgere la ricorsione</div>
<div class="content">
<div class="paragraph">
<p>Gli algoritmi di elevamento a potenza in questo paragrafo si basano sull&#8217;elevamento mediante moltiplicazioni ripetute.
In modo simile, è possibile eseguire la moltiplicazione dei numeri interi mediante addizioni ripetute.
La seguente funzione di moltiplicazione (in cui si presume che il nostro linguaggio possa solo addizionare, non moltiplicare) è analoga alla funzione <code>potenza</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function per (a, b) {
    return b === 0
           ? 0
           : a + per (a, b - 1);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Questo algoritmo richiede una serie di passaggi lineari in <code>b</code>.
Supponiamo ora di includere, insieme all&#8217;addizione, le operazioni <code>raddoppia</code>, che raddoppia un intero, e <code>dimezza</code>, che divide un intero (pari) per 2.
Usando questi, progetta una funzione di moltiplicazione analoga a <code>potenza_veloce</code> che utilizza un numero logaritmico di passi.</p>
</div>
</div>
</div>
<div id="es_it_pro_mult_int" class="exampleblock">
<div class="title">Esercizio 1.18. Metodo del contadino russo</div>
<div class="content">
<div class="paragraph">
<p>Utilizzando i risultati degli esercizi <a href="#es_iter_expon_pro">Esercizio 1.16. Elevamento a potenza, processo iterativo in tempo logaritmico.</a> e <a href="#es_add_expon">Esercizio 1.17. Svolgere la ricorsione</a>, progetta una funzione che generi un processo iterativo per la moltiplicazione di due numeri interi in termini di addizione, raddoppio e dimezzamento che utilizza un numero logaritmico di passaggi.
<sup class="footnote">[<a id="_footnoteref_10" class="footnote" href="#_footnotedef_10" title="View footnote.">10</a>]</sup></p>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Esercizio 1.19. Numeri di Fibonacci come applicazione alla n-esima potenza</div>
<div class="content">
<div class="paragraph">
<p>Esiste un algoritmo intelligente per calcolare i numeri di Fibonacci in un numero logaritmico di passaggi.
Ricorda la trasformazione delle variabili di stato \(a\) e \(b\) nel processo <code>fib_iter</code> del paragrafo <a href="#sp_ricorsione_ad_albero">paragrafo 1.2.2</a>:
\(a \leftarrow a + b\) e \(b \leftarrow a\).
Chiama questa trasformazione \(T\), e osserva che applicando \(T\) per \(n\) volte, iniziando con 1 e 0, produce la coppia \(\textrm{Fib} (n + 1)\) e \(\textrm{Fib} (n)\).
In altre parole, i numeri di Fibonacci sono prodotti applicando \(T^n\), la \(n\)-esima potenza della trasformazione \(T\), a partire dalla coppia \((1, 0)\).
Ora considera \(T\) come il caso speciale di \(p = 0\) e \(q = 1\) in una famiglia di trasformazioni \(T_{pq}\), dove \(T_{pq}\) trasforma la coppia \((a, b)\) secondo \(a\leftarrow bq+aq+ap\) e \(b\leftarrow bp+aq\).
Mostra che se applichiamo una tale trasformazione \(T_{pq}\) due volte, l&#8217;effetto è lo stesso dell&#8217;uso di una singola trasformazione
\(T_{p'q'}\) della stessa forma e calcola \(p'\) e \(q'\) in termini di \(p\) e \(q\).
Questo ci dà un modo esplicito per quadrare queste trasformazioni, e quindi possiamo calcolare \(T^n\) usando le quadratura successive, come nella funzione <code>potenza_veloce</code>.
Metti tutto insieme per completare la seguente funzione, che viene eseguita in un numero logaritmico di passaggi:<sup class="footnote">[<a id="_footnoteref_11" class="footnote" href="#_footnotedef_11" title="View footnote.">11</a>]</sup></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function fib(n) {
    return fib_iter(1, 0, 0, 1, n);
}
function fib_iter(a, b, p, q, contatore) {
    return count === 0
           ? b
           : pari(contatore)
             ? fib_iter(a,
                        b,
                        ⟨??⟩,           // calcola p'
                        ⟨??⟩,           // calcola q'
                        contatore / 2)
             : fib_iter(b * q + a * q + a * p,
                        b * p + a * q,
                        p,
                        q,
                        contatore - 1);
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:gcd"><a class="anchor" href="#sec:gcd"></a>1.2.5. Massimo Comun Divisore</h4>
<div class="paragraph">
<p>Il massimo comune divisore (MCD) di due interi \(a\) e \(b\) è definito come il numero intero più grande che divide sia \(a\) che \(b\) senza resto.
Ad esempio, il MCD di 16 e 28 è 4. Nel capitolo 2, quando indaghiamo su come implementare l&#8217;aritmetica dei numeri razionali, dovremo essere in grado di calcolare i MCD per ridurre i numeri razionali ai minimi termini.
(Per ridurre un numero razionale ai minimi termini, dobbiamo dividere sia il numeratore che il denominatore per il loro MCD.
Ad esempio, 16/28 si riduce a 4/7.)
Un modo per trovare il MCD di due numeri interi consiste nel fattorizzarli e nel ricercare i fattori comuni, ma esiste un famoso algoritmo che è molto più efficiente.</p>
</div>
<div class="paragraph">
<p>L&#8217;idea dell&#8217;algoritmo si basa sull&#8217;osservazione che, se \(r\) è il resto della divisione di \(a\) per \(b\), allora i divisori comuni di \(a\) e \(b\) sono esattamente gli stessi dei divisori comuni di \(b\) e \(r\). Quindi, possiamo usare l&#8217;equazione \(\textrm {MCD} (a, b) = \textrm {MCD} (b, r)\) per ridurre successivamente il problema del calcolo di un MCD al problema del calcolo del MCD di coppie di numeri interi sempre più piccoli.</p>
</div>
<div class="paragraph">
<p>Per esempio,</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{aligned}
      \textrm{MCD}(206,40) &amp; = &amp; \textrm{MCD}(40,6) \\
      &amp; = &amp; \textrm{MCD}(6,4) \\
      &amp; = &amp; \textrm{MCD}(4,2) \\
      &amp; = &amp; \textrm{MCD}(2,0) \\
      &amp; = &amp; 2
      \end{aligned}\]
</div>
</div>
<div class="paragraph">
<p>riduce \(\textrm{MCD}(206, 40)\) a \(\textrm{MCD}(2, 0)\), che è 2.
È possibile mostrare che iniziare con due numeri interi positivi ed eseguire riduzioni ripetute alla fine produrrà sempre una coppia in cui il secondo numero è 0.
In tale caso il MCD è l&#8217;altro numero nella coppia.
Questo metodo per calcolare il MCD è noto come <em>Algoritmo di Euclide</em>.<sup class="footnote">[<a id="_footnoteref_12" class="footnote" href="#_footnotedef_12" title="View footnote.">12</a>]</sup></p>
</div>
<div class="paragraph">
<p>È facile esprimere l&#8217;algoritmo di Euclide come una funzione:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function mcd(a, b) {
    return b === 0 ? a : mcd(b, a % b);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Questo genera un processo iterativo, il cui numero di passi cresce come il logaritmo dei numeri coinvolti.</p>
</div>
<div class="paragraph">
<p>Il fatto che il numero di passaggi richiesti dall&#8217;algoritmo di Euclide abbia una crescita logaritmica ha una relazione interessante con i numeri di Fibonacci:</p>
</div>
<div class="paragraph">
<p><strong>Teorema di Lamé:</strong> Se l&#8217;algoritmo di Euclide richiede \(k\) passi per calcolare il MCD di una coppia, il numero più piccolo nella coppia deve essere maggiore o uguale al \(k\)-esimo numero di Fibonacci.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Dimostrazione del Teorema di Lamé</div>
<div class="paragraph">
<p>Questo teorema fu dimostrato nel 1845 da Gabriel Lamé, un matematico e ingegnere francese noto principalmente per i suoi contributi alla fisica matematica. Per dimostrare il teorema, consideriamo le coppie \((a_k, b_k)\), dove \(a_k \geq b_k\), per cui l&#8217;algoritmo di Euclide termina in \(k\) passi. La prova è basata sull&#8217;affermazione che, se \((a_ {k + 1}, \ b_{k + 1}) \rightarrow (a_ {k}, \ b_ {k}) \rightarrow (a_{k-1},\ b_{k-1})\) sono tre coppie successive nel processo di riduzione, quindi dobbiamo avere \(b_{k + 1} \geq b_{k} + b_{k-1}\). Per verificare l&#8217;affermazione, si consideri che un passo di riduzione è definito applicando la trasformazione \(a_{k-1} = b_{k}\), \(b_{k-1} = \ \textrm{ resto} \ \textrm{ di } a_{k} \ \textrm{ diviso} \ \textrm{ per } \ b_{k}\). La seconda equazione significa che \(a_{k} = qb_{k} + b_{k-1}\) per un numero intero positivo \(q\). E poiché \(q\) deve essere almeno 1, abbiamo \(a_{k} = qb_{k} + b_{k-1} \geq b_{k} + b_{k-1}\). Ma nel passaggio di riduzione precedente abbiamo \(b_{k + 1} = a_{k}\). Pertanto, \(b_{k + 1} = a_{k} \geq b_{k} + b_{k-1}\). Ciò verifica la proposizione. Ora possiamo dimostrare il teorema per induzione su \(k\), il numero di passaggi che l&#8217;algoritmo richiede per terminare. Il risultato è vero per \(k = 1\), poiché ciò richiede semplicemente che \(b\) sia grande almeno quanto \(\text{Fib} (1) = 1\). Ora, supponi che il risultato sia vero per tutti i numeri interi minori o uguali a \(k\) e prova il risultato per \(k + 1\). Siano \((a_{k + 1}, \ b_{k + 1}) \rightarrow (a_{k}, \ b_{k}) \rightarrow (a_{k-1}, \ b_{k- 1}) $\) le coppie successive nel processo di riduzione. Dalle nostre ipotesi di induzione, abbiamo \(b_{k-1} \geq {\textrm {Fib}} (k-1)\) e \(b_{k} \geq {\textrm {Fib} } (k)\). Quindi, applicando l&#8217;affermazione che abbiamo appena dimostrato insieme alla definizione dei numeri di Fibonacci si ottiene \(b_{k + 1} \geq b_{k} + b_{k-1} \geq {\textrm {Fib}} ( k) + {\textrm {Fib}} (k-1) = {\textrm {Fib}} (k + 1)\), che completa la dimostrazione del Teorema di Lamé.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Possiamo usare questo teorema per ottenere una stima del tasso di crescita per l&#8217;algoritmo di Euclide. Sia \(n\) il più piccolo dei due input per la funzione. Se il processo richiede \(k\) passaggi, allora dobbiamo avere \(n\geq {\textrm{Fib}} (k)\approx\phi^k/\sqrt{5}\). Pertanto il numero di passi \(k\) cresce al crescere del logaritmo (alla base \(\phi\)) di \(n\). Quindi, l&#8217;ordine di crescita è \(\Theta (\log n)\).</p>
</div>
<div id="es_mcd" class="exampleblock">
<div class="title">Esercizio 1.20. Massimo comun divisore.</div>
<div class="content">
<div class="paragraph">
<p>Il processo che una funzione genera dipende dalle regole usate dall&#8217;interprete.
Come esempio, si consideri la funzione iterativa <code>mcd</code> descritta sopra.
Supponiamo di dover interpretare questa funzione utilizzando la valutazione nell&#8217;ordine normale, come discusso nel <a href="#sp_modello_sostituzione">paragrafo 1.1.5</a>.
(La regola di valutazione dell&#8217;ordine normale per le espressioni condizionali è descritta nell&#8217;esercizio <a href="#es_test-ordine-normale-vs-ordine-appl">Esercizio 1.5. Riflettere sulle conseguenze dell&#8217;ordine di valutazione</a>).
Usando il metodo di sostituzione (per ordine normale), illustra il processo generato nella valutazione di <code>mcd (206, 40)</code> e indica le operazioni del calcolo del resto che vengono effettivamente eseguite.
Quante operazioni <em>resto</em> sono effettivamente eseguite nella valutazione in ordine normale di <code>mcd (206, 40)</code>? Nella valutazione dell&#8217;ordine applicativo?</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sp_test_di_primalita"><a class="anchor" href="#sp_test_di_primalita"></a>1.2.6. Esempio: Test di primalità</h4>
<div class="paragraph">
<p>Questo paragrafo descrive due metodi per controllare la primalità di un numero intero \(n\), uno con tasso di crescita \(\Theta (\sqrt{n})\) e un altro <em>probabilistico</em> con tasso di crescita \(\Theta (\log n)\). Gli esercizi alla fine di questa sezione suggeriscono progetti di programmazione basati su questi algoritmi.</p>
</div>
<div class="sect4">
<h5 id="ricerca_divisori"><a class="anchor" href="#ricerca_divisori"></a>La ricerca dei divisori</h5>
<div class="paragraph">
<p>Sin dai tempi antichi, i matematici sono stati affascinati dai problemi riguardanti i numeri primi e molte persone hanno lavorato al problema di determinare i modi per verificare se i numeri sono primi. Un modo per verificare se un numero è primo è trovare i divisori del numero. Il seguente programma trova il divisore intero più piccolo (maggiore di 1) di un dato numero \(n\). Lo fa in modo semplice, testando \(n\) per la divisibilità per interi successivi che iniziano con 2.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function divisore_minimo(n) {
    return cerca_divisore(n, 2);
}
function cerca_divisore(n, divisore_prova) {
     return quadrato(divisore_prova) &gt; n
            ? n
            : divide(divisore_prova, n)
              ? divisore_prova
              : cerca_divisore(n, divisore_prova + 1);
}
function divide(a, b) {
    return b % a === 0;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Possiamo verificare se un numero è primo come segue: \(n\) è primo se e solo se \(n\) è il suo divisore più piccolo.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function primo(n) {
    return n === divisore_minimo(n);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Il test finale per <code>cerca_divisore</code> si basa sul fatto che se \(n\) non è primo, deve avere un divisore minore o uguale a \(\sqrt{n}\).<sup class="footnote">[<a id="_footnoteref_13" class="footnote" href="#_footnotedef_13" title="View footnote.">13</a>]</sup> Ciò significa che l&#8217;algoritmo necessita solo di divisori di test tra 1 e \(\sqrt{n}\). Di conseguenza, il numero di passaggi necessari per identificare \(n\) come primo avrà l&#8217;ordine di crescita \(\Theta (\sqrt{n})\).</p>
</div>
</div>
<div class="sect4">
<h5 id="the-fermat-test"><a class="anchor" href="#the-fermat-test"></a>Il test di Fermat</h5>
<div class="paragraph">
<p>Il test di primalità con tasso di crescita \(\Theta(\log n)\) si basa su un risultato della teoria dei numeri noto come Piccolo teorema di Fermat.<sup class="footnote">[<a id="_footnoteref_14" class="footnote" href="#_footnotedef_14" title="View footnote.">14</a>]</sup></p>
</div>
<div class="paragraph">
<p><strong>Piccolo teorema di Fermat:</strong> Se \(n\) è un numero primo e \(a\) è un qualsiasi numero intero positivo inferiore a \(n\), allora \(a\) elevato alla \(n\)-esima potenza è congruente a \(a\) modulo \(n\).</p>
</div>
<div class="paragraph">
<p>(Si dice che due numeri siano <em>congruenti modulo</em> \(n\) se entrambi hanno lo stesso resto quando divisi per \(n\). Il resto di un numero \(a\) quando diviso per \(n\) è anche indicato come <em>il resto di</em> \(a\) <em>modulo</em> \(n\), o semplicemente come \(a\) <em>modulo</em> \(n\).)</p>
</div>
<div class="paragraph">
<p>Se \(n\) non è primo, allora, in generale, la maggior parte dei numeri \(a &lt; n\) non soddisferà la relazione di cui sopra. Questo porta al seguente algoritmo per testare la primalità: dato un numero \(n\), scegli un numero casuale \(a &lt; n\) e calcola il resto di \(a^n\) modulo \(n\). Se il risultato non è uguale a \(a\), \(n\) non è certamente primo. Se è \(a\), allora è probabile che \(n\) sia primo. Ora scegli un altro numero casuale \(a\) e testalo con lo stesso metodo. Se anche questo soddisfa l&#8217;equazione, allora possiamo essere ancora più sicuri che \(n\) sia primo. Provando sempre più valori di \(a\), possiamo aumentare la nostra fiducia nel risultato. Questo algoritmo è noto come test di Fermat.</p>
</div>
<div class="paragraph">
<p>Per realizzare il test di Fermat, abbiamo bisogno di una funzione che calcoli l&#8217;elevamento a potenza di un numero modulo un altro numero:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function potenza_modulo(base, esponente, m) {
    return esponente === 0
           ? 1
           : pari(esponente)
             ? quadrato(potenza_modulo(base, esponente / 2, m)) % m
             : (base * potenza_modulo(base, esponente - 1, m)) % m;

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Questo è molto simile alla funzione <code>potenza_veloce</code> della sezione <a href="#sp_elevamento_a_potenza">paragrafo 1.2.4</a>. Utilizza i quadrati successivi, in modo che il numero di passi cresca logaritmicamente con l&#8217;esponente.<sup class="footnote">[<a id="_footnoteref_15" class="footnote" href="#_footnotedef_15" title="View footnote.">15</a>]</sup></p>
</div>
<div class="paragraph">
<p>Il test di Fermat viene eseguito scegliendo a caso un numero \(a\) compreso tra 1 e \(n-1\) incluso e controllando se il resto modulo \(n\) della \(n\)-esima potenza di \(a\) è uguale a \(a\). Il numero casuale \(a\) viene scelto utilizzando la funzione <code>random</code>, che assumiamo sia inclusa come primitiva in JavaScript. La funzione <code>random</code> restituisce un numero intero non negativo minore del suo intero input. Quindi, per ottenere un numero casuale compreso tra 1 e \(n-1\), chiamiamo <code>random</code> con un input di \(n-1\) e aggiungiamo 1 al risultato:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function test_fermat(n) {
    function prova(a) {
        return potenza_modulo(a, n, n) === a;
    }
    return prova(1 + random(n - 1));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>La seguente funzione esegue il test un determinato numero di volte, come specificato da un parametro. Il suo valore è vero se il test riesce ogni volta e falso in caso contrario.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function primo_veloce(n, num_volte) {
    return num_volte === 0
        ? true
        : test_fermat(n)
            ? primo_veloce(n, num_volte - 1)
            : false;
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sp_metodi_probabilistici"><a class="anchor" href="#sp_metodi_probabilistici"></a>Metodi probabilistici</h5>
<div class="paragraph">
<p>Il test di Fermat è molto diverso dagli algoritmi più familiari, i quali calcolano una risposta che è garantita essere corretta. In questo caso, la risposta ottenuta è solo probabilmente corretta. Più precisamente, se \(n\) fallisce il test di Fermat, possiamo essere certi che \(n\) non è primo. Ma il fatto che \(n\) superi il test, sebbene sia un&#8217;indicazione estremamente forte, non è ancora una garanzia che \(n\) sia primo. Quello che vorremmo dire è che per qualsiasi numero \(n\), se eseguiamo il test abbastanza volte e risulta che \(n\) supera sempre il test, allora la probabilità di errore nel nostro test di primalità può essere resa piccola a piacere.</p>
</div>
<div class="paragraph">
<p>Purtroppo questa affermazione non è del tutto corretta. Esistono numeri che ingannano il test di Fermat: numeri \(n\) che non sono primi e tuttavia hanno la proprietà che \(a^n\) è congruente a \(a\) modulo \(n\) per tutti i numeri interi \(a &lt; n\). Tali numeri sono estremamente rari, quindi il test di Fermat è abbastanza affidabile nella pratica.<sup class="footnote">[<a id="_footnoteref_16" class="footnote" href="#_footnotedef_16" title="View footnote.">16</a>]</sup></p>
</div>
<div class="paragraph">
<p>Ci sono varianti del test di Fermat che non possono essere ingannate. In questi test, come con il metodo Fermat, si verifica la primalità di un intero \(n\) scegliendo un numero a caso \(a &lt; n\) e verificando alcune condizioni che dipendono da \(n\) e \(a\). (Vedere l&#8217;esercizio [es: miller-rabin] per un esempio di tale test.) D&#8217;altra parte, in contrasto con il test di Fermat, si può dimostrare che, per qualsiasi \(n\), la condizione non vale per la maggior parte degli interi \(a &lt; n\) a meno che \(n\) non sia primo. La probabilità che \(n\) superi il test per una scelta casuale di \(a\), sono maggiori di quelle che \(n\) sia primo. Se \(n\) supera il test per due scelte casuali di \(a\), le probabilità che \(n\) sia primo sono maggiori di 3 su 4. Eseguendo il test con valori sempre più valori di \(a\) scelti a caso possiamo rendere la probabilità di errore piccola a piacere.</p>
</div>
<div class="paragraph">
<p>L&#8217;esistenza di test per i quali si può dimostrare che la possibilità di errore diventa arbitrariamente piccola ha suscitato interesse per algoritmi di questo tipo, che sono diventati noti come <em>algoritmi probabilistici</em>. C&#8217;è una grande attività di ricerca in quest&#8217;area e gli algoritmi probabilistici sono stati applicati con successo in molti campi.<sup class="footnote">[<a id="_footnoteref_17" class="footnote" href="#_footnotedef_17" title="View footnote.">17</a>]</sup></p>
</div>
<div id="ex:use-smallest-divisor" class="exampleblock">
<div class="title">Esercizio 1.21. Applicazione di <code>divisore_minimo</code></div>
<div class="content">
<div class="paragraph">
<p>Usa la funzione <code>divisore_minimo</code> per trovare il divisore più piccolo di ciascuno dei seguenti numeri: 199, 1999, 19999.</p>
</div>
</div>
</div>
<div id="ex:search-for-primes" class="exampleblock">
<div class="title">Esercizio 1.22. Fare esperienza della complessità di ricerca dei numeri primi grandi</div>
<div class="content">
<div class="paragraph">
<p>Assumiamo che una funzione primitiva <code>get_time</code> senza argomenti ogni volta che viene chiamata restituisca il numero di millisecondi trascorsi dalla mezzanotte di giovedì 1 gennaio 1970. <sup class="footnote">[<a id="_footnoteref_18" class="footnote" href="#_footnotedef_18" title="View footnote.">18</a>]</sup> La seguente funzione <code>test_primalita_temporizzata</code>, quando chiamata con un numero intero \(n\), stampa \(n\) e controlla se \(n\) sia primo. Se \(n\) è primo, la funzione stampa tre asterischi.<sup class="footnote">[<a id="_footnoteref_19" class="footnote" href="#_footnotedef_19" title="View footnote.">19</a>]</sup> seguita dal tempo impiegato per eseguire il test.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function test_primalita_cronometrato(n) {
    display(n);
    return inizia_test_primalita(n, get_time());
}
function inizia_test_primalita(n, tempo_inizio) {
    return primo(n)
           ? stampa_primo(get_time() - tempo_inizio)
           : false;
}
function stampa_primo(tempo_trascorso) {
    display(" *** ");
    return display(tempo_trascorso);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usando questa funzione, scrivi una funzione <code>cerca_primi</code> che controlla la primalità degli interi dispari consecutivi in ​​un intervallo specificato. Usa la tua funzione per trovare i tre numeri primi più piccoli maggiori di 1000; maggiori di 10.000; maggiori di 100.000; maggiori di 1.000.000. Prendi nota del tempo necessario per testare ogni primo. Poiché l&#8217;algoritmo di test ha tasso di crescita \(\Theta (\sqrt{n})\), dovresti aspettarti che il test per i numeri primi intorno a 10.000 dovrebbe richiedere circa \(\sqrt{10}\) volte il tempo di verifica dei numeri primi intorno a 1000. I dati sui tempi lo confermano? In che misura i dati per 100.000 e 1.000.000 confermano la previsione \(\sqrt{n}\)? Il tuo risultato è compatibile con l&#8217;idea che i programmi sulla tua macchina vengano eseguiti nel tempo proporzionale al numero di passaggi necessari per il calcolo?</p>
</div>
</div>
</div>
<div id="ex:better-smallest-divisor" class="exampleblock">
<div class="title">Esercizio 1.23.</div>
<div class="content">
<div class="paragraph">
<p>La funzione <code>divisore_minimo</code> mostrata all&#8217;inizio di questo paragrafo fa molti test inutili: dopo aver verificato se il numero è divisibile per 2 non ha senso controllare se è divisibile per numeri pari più grandi. Questo suggerisce che i valori usati per <code>divisore_prova</code> non dovrebbero essere 2, 3, 4, 5, 6,&#8230;&#8203; ma piuttosto 2, 3, 5, 7, 9,&#8230;&#8203; . Per implementare questa modifica, dichiara una funzione <code>prossimo</code> che restituisce 3 se il suo input è uguale a 2 e altrimenti restituisce il suo input più 2. Modifica la funzione <code>divisore_minimo</code> per utilizzare <code>prossimo</code> invece di <code>divisore_prova + 1</code> . Con <code>test_primalita_cronometrato</code> che incorpora questa versione modificata di` divisore_minimo`, esegui il test per ciascuno dei 12 numeri primi trovati nel <a href="#ex:search-for-primes">Esercizio 1.22. Fare esperienza della complessità di ricerca dei numeri primi grandi</a>. Poiché questa modifica dimezza il numero di passaggi del test, dovresti aspettarti che venga eseguito circa il doppio più velocemente. Questa aspettativa è confermata? In caso negativo, qual è il rapporto osservato tra le velocità dei due algoritmi e come spieghi il fatto che è diverso da 2?</p>
</div>
</div>
</div>
<div id="ex:mod-timed-prime-test" class="exampleblock">
<div class="title">Esercizio 1.24.</div>
<div class="content">
<div class="paragraph">
<p>Modifica la funzione <code>test_primalita_cronometrato</code> dell&#8217;esercizio <a href="#ex:search-for-primes">Esercizio 1.22. Fare esperienza della complessità di ricerca dei numeri primi grandi</a> per usare <code>primo_veloce</code> (il metodo Fermat), e prova ciascuno dei 12 numeri primi trovati in quell&#8217;esercizio. Dato che il test di Fermat ha tasso di crescita \(\Theta (\log n)\), quale rapporto tra i tempi necessari per testare numeri primi vicini a 1.000.000 e quelli per testare numeri primi vicini a 1000 ti aspetteresti? I tuoi dati lo confermano? Puoi spiegare eventuali discrepanze che trovi?</p>
</div>
</div>
</div>
<div id="ex:Alyssas-expmod" class="exampleblock">
<div class="title">Esercizio 1.25.</div>
<div class="content">
<div class="paragraph">
<p>Alyssa P. Hacker si lamenta del fatto che abbiamo lavorato molto per scrivere <code>expmod</code>. Dopotutto, dice, poiché sappiamo già come calcolare gli esponenziali, avremmo potuto semplicemente scrivere</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function potenza_modulo(base, esponente, m) {
    return potenza_veloce(base, esponente) % m;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ha ragione? Questa funzione servirebbe anche per il nostro test veloce per numeri primi? Spiegare.</p>
</div>
</div>
</div>
<div id="ex:louis-fast-prime" class="exampleblock">
<div class="title">Esercizio 1.26.</div>
<div class="content">
<div class="paragraph">
<p>Louis Reasoner ha grandi difficoltà a fare esercizio <a href="#ex:mod-timed-prime-test">Esercizio 1.24.</a>. Il suo test <code>primo_veloce</code> sembra essere più lento del test <code>primo</code>. Louis chiama la sua amica Eva Lu Ator per farsi aiutare. Quando esaminano il codice di Louis, scoprono che ha riscritto la funzione <code>potenza_modulo</code> per utilizzare una moltiplicazione esplicita, piuttosto che chiamare <code>quadrato</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function potenza_modulo(base, esponente, m) {
    return esponente === 0
           ? 1
           : pari(esponente)
             ? potenza_modulo(base, esponente / 2, m)
               * potenza_modulo(base, esponente / 2, m)
               % m
             : base
               * potenza_modulo(base, esponente - 1, m)
               % m;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Non vedo che differenza potrebbe fare,</em> dice Louis. <em>Io la vedo.</em> dice Eva. <em>Scrivendo la funzione in questo modo, hai trasformato il processo \(\Theta (\log n)\) in un processo \(\Theta (n)\).</em> Spiega.</p>
</div>
</div>
</div>
<div id="ex:unlabeled25" class="exampleblock">
<div class="title">Esercizio 1.27.</div>
<div class="content">
<div class="paragraph">
<p>Dimostra che i numeri di Carmichael
ingannano davvero il test di Fermat. Cioè, scrivi una funzione che accetta un intero \(n\) e verifica se \(a^n\) è congruente a \(a\) modulo \(n\) per ogni \(a&lt;n\), e prova la tua funzione sui numeri Carmichael dati.</p>
</div>
</div>
</div>
<div id="ex:miller-rabin" class="exampleblock">
<div class="title">Esercizio 1.28</div>
<div class="content">
<div class="paragraph">
<p>Una variante del test di Fermat che non può essere ingannata è chiamata <em>test di Miller-Rabin</em> (Miller 1976; Rabin 1980). Questo inizia da una forma alternativa del Piccolo teorema di Fermat, che afferma che se \(n\) è un numero primo e \(a\) è un qualsiasi numero intero positivo inferiore a \(n\), allora \(a\) elevato alla \((n-1)\)-esima potenza è congruente a 1 modulo \(n\). Per verificare la primalità di un numero \(n\) con il test di Miller-Rabin, scegliamo un numero casuale \(a &lt; n\) e eleviamo \(a\) alla \((n-1)\)-esima potenza modulo \(n\) utilizzando la funzione <code>potenza_modulo</code>. Tuttavia, ogni volta che eseguiamo il passaggio di quadratura in <code>potenza_modulo</code>, controlliamo se abbiamo scoperto una <em> radice quadrata non convenzionale di 1 modulo \(n\) </em>ovvero un numero diverso da 1 o \(n-1 \) il cui quadrato è uguale a 1 modulo \(n\). È possibile dimostrare che se esiste una radice quadrata non banale di 1, \(n\) non è primo. È anche possibile dimostrare che se \(n\) è un numero dispari che non è primo, allora, per almeno la metà dei numeri \(a &lt;n\), il calcolo \(a^{n-1}\) in questo modo rivelerà una radice quadrata non banale di 1 modulo \(n\). (Questo è il motivo per cui il test di Miller-Rabin non può essere ingannato.) Modifica la funzione <code>potenza_modulo</code> per segnalare se scopre una radice quadrata non banale di 1, e usala per implementare il test di Miller-Rabin con una funzione analoga a <code>test_fermat</code> . Controlla la tua funzione testando vari numeri primi e non primi noti. Suggerimento: un modo conveniente per avere una segnalazione è far restirire 0 da <code>esponente_modulo</code>.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sec:higher-order-procedures"><a class="anchor" href="#sec:higher-order-procedures"></a>1.3. Formulare astrazioni con funzioni di ordine superiore</h3>
<div class="paragraph">
<p>Abbiamo visto che le funzioni sono, in effetti, astrazioni che descrivono operazioni composte su numeri indipendenti dai numeri particolari. Ad esempio, quando dichiariamo</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function cubo(x) {
    return x * x * x;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>non stiamo parlando del cubo di un numero particolare, ma piuttosto di un metodo per ottenere il cubo di un numero qualsiasi. Ovviamente potremmo andare d&#8217;accordo senza mai dichiarare questa funzione, scrivendo sempre espressioni come</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">3 * 3 * 3;
x * x * x;
y * y * y;</code></pre>
</div>
</div>
<div class="paragraph">
<p>e non menzionare mai esplicitamente "cubo". Questo ci porterebbe in un grave svantaggio, costringendoci a lavorare sempre al livello delle operazioni particolari che sono primitive nel linguaggio (moltiplicazione, in questo caso) piuttosto che in termini di operazioni di livello superiore. I nostri programmi sarebbero in grado di calcolare i cubi, ma il nostro linguaggio non avrebbe la capacità di esprimere il concetto di cubo. Una delle cose che dovremmo chiedere a un potente linguaggio di programmazione è la capacità di costruire astrazioni assegnando nomi a schemi comuni e quindi di lavorare direttamente in termini di astrazioni. Le funzioni forniscono questa capacità. Questo è il motivo per cui tutti i linguaggi di programmazione tranne i più primitivi includono meccanismi per la dichiarazione di funzioni.</p>
</div>
<div class="paragraph">
<p>Tuttavia, anche nell&#8217;elaborazione numerica saremo fortemente limitati nella nostra capacità di creare astrazioni se siamo limitati a funzioni i cui parametri devono essere numeri. Spesso lo stesso schema di programmazione verrà utilizzato con un numero di funzioni diverse. Per esprimere tali modelli come concetti, avremo bisogno di costruire funzioni che possono accettare funzioni come argomenti o restituire funzioni come valori. Le funzioni che manipolano le funzioni sono chiamate <em>funzioni di ordine superiore</em>.</p>
</div>
<div class="paragraph">
<p>Questo paragrafo mostra come le funzioni di ordine superiore possono fungere da potenti meccanismi di astrazione, aumentando enormemente la potenza espressiva del nostro linguaggio.</p>
</div>
<div class="sect3">
<h4 id="sec:procedures-as-parameters"><a class="anchor" href="#sec:procedures-as-parameters"></a>1.3.1. Funzioni come Parametri</h4>
<div class="paragraph">
<p>Considera le seguenti tre funzioni. La prima calcola la somma degli interi da <em>a</em> a <em>b</em>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function somma_interi(a, b) {
    return a &gt; b
           ? 0
           : a + somma_interi(a + 1, b);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>La seconda calcola la somma dei cubi degli interi nell&#8217;intervallo dato:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function somma_cubi(a, b) {
    return a &gt; b
           ? 0
           : cubo(a) + somma_cubi(a + 1, b);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>La terza calcola la somma di una sequenza di termini nella serie</p>
</div>
<div class="stemblock">
<div class="content">
\[\frac{1}{1\cdot3}+\frac{1}{5\cdot7}+\frac{1}{9\cdot11}+\cdots\]
</div>
</div>
<div class="paragraph">
<p>che converge a \(\pi / 8\) (molto lentamente):<sup class="footnote">[<a id="_footnoteref_20" class="footnote" href="#_footnotedef_20" title="View footnote.">20</a>]</sup></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function somma_pi(a, b) {
    return a &gt; b
           ? 0
           : 1.0 / (a * (a + 2)) +
             somma_pi(a + 4, b);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Queste tre funzioni condividono chiaramente un modello sottostante comune. Sono per la maggior parte identiche, differiscono solo per il nome della funzione, la funzione di <em>a</em> usata per calcolare il termine da aggiungere e la funzione che fornisce il valore successivo di <em>a</em>. Potremmo generare ciascuna delle funzioni riempiendo gli slot nello stesso modello:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function $nome$(a, b) {
    return a &gt; b
           ? 0
           : $termine$(a) + $nome$($prossimo$(a), b);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>La presenza di un modello così comune è una forte evidenza che esiste un&#8217;astrazione utile in attesa di essere portata in superficie. In effetti, molto tempo fa i matematici identificarono l&#8217;astrazione e inventarono la <em>notazione sigma</em>, ad esempio</p>
</div>
<div class="stemblock">
<div class="content">
\[{\sum_{n=a}^{b}\ f(n)=f(a)+\cdots+f(b)\,}\]
</div>
</div>
<div class="paragraph">
<p>per esprimere questo concetto. Il potere della notazione sigma è che consente ai matematici di trattare il concetto di sommatoria stesso piuttosto che solo con somme particolari, ad esempio per formulare risultati generali su somme che sono indipendenti dalla particolare serie che viene sommata.</p>
</div>
<div class="paragraph">
<p>Allo stesso modo, come progettisti di programmi, vorremmo che il nostro linguaggio fosse abbastanza potente da poter scrivere una funzione che esprima il concetto di sommatoria stesso piuttosto che solo funzioni che calcolano somme particolari. Possiamo farlo prontamente nel nostro linguaggio funzionale prendendo il modello comune mostrato sopra e trasformando gli "slot" in parametri:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function somma(termine, a, prossimo, b) {
    return a &gt; b
           ? 0
           : termine(a) + somma(termine, prossimo(a), prossimo, b);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Si noti che "somma" prende come argomenti i limiti inferiore e superiore "a" e "b" insieme alle funzioni "termine" e "prossimo". Possiamo usare "somma" proprio come faremmo con qualsiasi funzione. Ad esempio, possiamo usarla (insieme a una funzione <code>inc</code> che incrementa il suo argomento di 1) per definire <code>somma_cubi</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function inc(n) {
    return n + 1;
}
function somma_cubi(a, b) {
    return somma(cubo, a, inc, b);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usando questa funzione, possiamo calcolare la somma dei cubi degli interi da 1 a 10:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">somma_cubi(1, 10);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Con l&#8217;aiuto di una funzione <em>identità</em> per calcolare il termine, possiamo definire <code>somma_interi</code> in termini di <code>somma</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function identita(x) {
    return x;
}

function somma_interi(a, b) {
    return somma(identita, a, inc, b);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Quindi possiamo sommare gli interi da 1 a 10:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">somma_interi(1, 10);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Possiamo anche dichiarare <code>somma_pi</code> nello stesso modo:<sup class="footnote">[<a id="_footnoteref_21" class="footnote" href="#_footnotedef_21" title="View footnote.">21</a>]</sup></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function somma_pi(a, b) {
    function pi_termine(x) {
        return 1.0 / (x * (x + 2));
    }
    function pi_prossimo(x) {
        return x + 4;
    }
    return somma(pi_termine, a, pi_prossimo, b);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usando queste funzioni, possiamo calcolare un&#8217;approssimazione di latexmath: [\pi]:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">8 * somma_pi(1, 1000);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Una volta che abbiamo "somma", possiamo usarla come elemento costitutivo nella formulazione di ulteriori concetti. Ad esempio, l&#8217;integrale definito di una funzione \(f\) tra i limiti \(a\) e \(b\) può essere approssimato numericamente utilizzando la formula</p>
</div>
<div class="stemblock">
<div class="content">
\[\int_{a}^{b}f =
      \left[ f\left( a+\frac{dx}{2} \right) + f \left(a+dx+\frac{dx}{2}
      \right) + f \left( a+2dx+\frac{dx}{2} \right)+\cdots
      \right] dx\]
</div>
</div>
<div class="paragraph">
<p>per piccoli valori di \(dx\).</p>
</div>
<div class="paragraph">
<p>Possiamo esprimerlo direttamente come una funzione:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function integrale(f, a, b, dx) {
    function aggiungi_dx(x) {
        return x + dx;
    }
    return somma(f, a + dx / 2, add_dx, b) * dx;
}

integrale(cubo, 0, 1, 0.01);</code></pre>
</div>
</div>
<div class="paragraph">
<p>(Il valore esatto dell&#8217;integrale di "cubo" compreso tra 0 e 1 è 1/4.)</p>
</div>
<div id="ex:simpsons-rule" class="exampleblock">
<div class="title">Esercizio 1.29. Regola di Cavalieri-Simpson</div>
<div class="content">
<div class="paragraph">
<p>La regola di Cavalieri-Simpson è un metodo di integrazione numerica (quadratura) più accurato rispetto al metodo illustrato sopra. Usando la regola di Cavalieri-Simpson, l&#8217;integrale di una funzione \(f\) tra \(a\) e \(b\) viene approssimato come</p>
</div>
<div class="stemblock">
<div class="content">
\[\frac{h}{3} [y_0 + 4y_1 + 2y_2 + 4y_3 + 2y_4 + \cdots + 2y_{n-2} +4y_{n-1}+y_n ]\]
</div>
</div>
<div class="paragraph">
<p>dove \(h = (b-a) / n\), per un qualche numero intero pari \(n\) e \(y_k = f (a + kh)\). (Aumentando \(n\) aumenta l&#8217;accuratezza dell&#8217;approssimazione.) Dichiara una funzione che accetta come argomenti \(f\), \(a\), \(b\) e \(n\) e restituisce il valore dell&#8217;integrale, calcolato utilizzando la regola di Cavalieri-Simpson. Usa la tua funzione per integrare "cubo" tra 0 e 1 (con \(n = 100\) e \(n = 1000\)) e confronta i risultati con quelli della funzione "integrale" mostrata sopra.</p>
</div>
</div>
</div>
<div id="ex:unlabeled17" class="exampleblock">
<div class="title">Esercizio 1.30. Somma come processo iterativo</div>
<div class="content">
<div class="paragraph">
<p>La funzione <code>somma</code> soprascritta genera una ricorsione lineare. La funzione può essere riscritta in modo che la somma venga eseguita in modo iterativo. Mostra come farlo compilando le espressioni mancanti nella seguente dichiarazione:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function somma(termine, a, prossimo, b) {
    function iter(a, risultato) {
        return &lt; ?? &gt;
               ? &lt; ?? &gt;
               : iter(&lt; ?? &gt;, &lt; ?? &gt;);
    }
    return iter(&lt; ?? &gt;, &lt; ?? &gt;);
}</code></pre>
</div>
</div>
</div>
</div>
<div id="es_prodotto" class="exampleblock">
<div class="title">Esercizio 1.31. Prodotto dei valori di una funzione in un intervallo</div>
<div class="content">
<div class="olist arabic">
<ol class="arabic">
<li>
<p>La funzione <code>somma</code> è solo la più semplice di un vasto numero di astrazioni simili che possono essere gestite come funzioni di ordine superiore. <sup class="footnote">[<a id="_footnoteref_22" class="footnote" href="#_footnotedef_22" title="View footnote.">22</a>]</sup> Scrivete una funzione analoga chiamata "prodotto" che restituisca il prodotto dei valori di una funzione in punti di un dato intervallo. Mostrate come definire "fattoriale" in termini di "prodotto". Usa anche <code>prodotto</code> per calcolare approssimazioni di \(\pi\) usando la formula <sup class="footnote">[<a id="_footnoteref_23" class="footnote" href="#_footnotedef_23" title="View footnote.">23</a>]</sup></p>
<div class="openblock">
<div class="content">
<div class="stemblock">
<div class="content">
\[\frac{\pi}{4}=\frac{2\cdot 4\cdot 4\cdot 6\cdot 6\cdot 8\cdots}{3\cdot3\cdot 5\cdot 5\cdot 7\cdot 7\cdots}\]
</div>
</div>
</div>
</div>
</li>
<li>
<p>Se la tua funzione <code>prodotto</code> genera un processo ricorsivo, scrivine uno che generi un processo iterativo. Se genera un processo iterativo, scrivine uno che generi un processo ricorsivo.</p>
</li>
</ol>
</div>
</div>
</div>
<div id="es_accumula" class="exampleblock">
<div class="title">Esercizio 1.32. Accumula</div>
<div class="content">
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Mostra che <code>somma</code> e` prodotto` (<a href="#es_prodotto">Esercizio 1.31. Prodotto dei valori di una funzione in un intervallo</a>) sono entrambi casi speciali di una nozione ancora più generale chiamata <code>accumula</code> che combina una collezione di termini, utilizzando alcune funzioni generali di accumulazione:</p>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">accumula(operatore, elemento_neutro, termine, a, prossimo, b);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>La funzione <code>accumula</code> prende come argomenti le stesse specifiche di termine e intervallo di <code>somma</code> e <code>prodotto</code>, insieme a una funzione <code>operatore</code> (di due argomenti) che specifica come il termine corrente deve essere combinato con l&#8217;accumulazione dei termini precedenti e un <code>elemento_neutro</code> che specifica quale valore di base usare quando i termini si esauriscono. Scrivi <code>accumula</code> e mostra come <code>somma</code> e <code>prodotto</code> possono essere entrambi dichiarati come semplici chiamate ad <code>accumula</code>.</p>
</div>
</li>
<li>
<p>Se la tua funzione <code>accumula</code> genera un processo ricorsivo, scrivine uno che generi un processo iterativo. Se genera un processo iterativo, scrivine uno che generi un processo ricorsivo.</p>
</li>
</ol>
</div>
</div>
</div>
<div id="es_filtra_accumula" class="exampleblock">
<div class="title">Esercizio 1.33. Accumula i valori filtrati</div>
<div class="content">
<div class="paragraph">
<p>È possibile ottenere una versione ancora più generale di <code>accumula</code> (<a href="#es_accumula">Esercizio 1.32. Accumula</a>) introducendo la nozione di un <em>filtro</em> sui termini da combinare. Cioè, combina solo i termini derivati ​​dai valori nell&#8217;intervallo che soddisfano una condizione specificata. L&#8217;astrazione risultante <code>accumula_se</code> accetta gli stessi argomenti di accumula, insieme a un predicato aggiuntivo di un argomento che specifica il filtro. Scrivi "accumula_se" come funzione. Mostra come esprimere quanto segue usando <code>accumula_se</code>:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>la somma dei quadrati dei numeri primi nell&#8217;intervallo da \(a\) a \(b\) (assumendo che tu abbia un predicato <code>primo</code> già scritto)</p>
</li>
<li>
<p>il prodotto di tutti i numeri interi positivi inferiori a \(n\) che sono relativamente primi rispetto a \(n\) (ovvero, tutti gli interi positivi \(i&lt;n\) tali che \(\textrm{MCD} (i, n) = 1\)).</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:lambda"><a class="anchor" href="#sec:lambda"></a>1.3.2. Costruire le funzioni utilizzando le espressioni Lambda</h4>
<div class="paragraph">
<p>Nell&#8217;usare <code>somma</code> come nel <a href="#sec:procedures-as-parameters">paragrafo 1.3.1</a>, sembra terribilmente imbarazzante dover dichiarare funzioni banali come <code>pi_termine</code> e <code>pi_prossimo</code> soltanto perché così possiamo usarle come argomenti per la nostra funzione di ordine superiore. Piuttosto che dichiarare <code>pi_prossimo</code> e <code>pi_termine</code>, sarebbe più conveniente avere un modo per specificare direttamente "la funzione che restituisce il suo input incrementato di 4" e "la funzione che restituisce il reciproco del suo input per il suo input più 2". Possiamo farlo introducendo <em>espressioni lambda</em> come forma sintattica per la creazione di funzioni. Usando le espressioni lambda, possiamo descrivere ciò che vogliamo come</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">x =&gt; x + 4;</code></pre>
</div>
</div>
<div class="paragraph">
<p>e</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">x =&gt; 1.0 / (x * (x + 2));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Quindi la nostra funzione <code>somma_pi</code> può essere espressa senza dichiarare alcuna funzione ausiliaria come</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function somma_pi(a, b) {
    return somma(x =&gt; 1.0 / (x * (x + 2)),
               a,
               x =&gt; x + 4,
               b);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usando ancora un&#8217;espressione lambda, possiamo scrivere la funzione <code>integrale</code> senza dover dichiarare la funzione ausiliaria <code>aggiungi_dx</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function integrale(f, a, b, dx) {
    return somma(f,
               a + dx / 2.0,
               x =&gt; x + dx,
               b)
           *
           dx;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In generale, le espressioni lambda vengono utilizzate per creare funzioni allo stesso modo delle dichiarazioni di funzione, tranne per il fatto che non viene specificato alcun nome per la funzione e la parola chiave return e le parentesi graffe vengono omesse.<sup class="footnote">[<a id="_footnoteref_24" class="footnote" href="#_footnotedef_24" title="View footnote.">24</a>]</sup></p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Forma della dichiarazione di una espressione lambda</div>
<div class="paragraph">
<p><strong>(</strong> <em>parametri</em> <strong>) &#8658; </strong> <em>espressione</em></p>
</div>
</div>
</div>
<div class="paragraph">
<p>La funzione risultante è una funzione tanto quanto quella creata utilizzando un&#8217;istruzione di dichiarazione di funzione. L&#8217;unica differenza è che non è stato associato ad alcun nome nell&#8217;ambiente. Noi consideriamo</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function piu4(x) {
    return x + 4;
}</code></pre>
</div>
</div>
<div id="foot:function-decl-vs-lambda" class="paragraph">
<p>essere equivalente a <sup class="footnote">[<a id="_footnoteref_25" class="footnote" href="#_footnotedef_25" title="View footnote.">25</a>]</sup></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">const piu4 = x =&gt; x + 4;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Possiamo leggere un&#8217;espressione lambda come segue:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">//                         x       =&gt;             x     +   4
//                         ^       ^              ^     ^   ^
//                         |       |              |     |   |
// la funzione di argomento x che restituisce il valore piu' 4</code></pre>
</div>
</div>
<div class="paragraph">
<p>Come qualsiasi espressione che ha una funzione come valore, un&#8217;espressione lambda può essere utilizzata come espressione di funzione in un&#8217;applicazione come</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">((x, y, z) =&gt; x + y + quadrato(z))(1, 2, 3);</code></pre>
</div>
</div>
<div class="paragraph">
<p>o, più in generale, in qualsiasi contesto in cui normalmente useremmo un nome di funzione.<sup class="footnote">[<a id="_footnoteref_26" class="footnote" href="#_footnotedef_26" title="View footnote.">26</a>]</sup> Notare che "&#8658;" ha una precedenza inferiore rispetto all&#8217;applicazione della funzione e quindi le parentesi attorno all&#8217;espressione lambda in questo esempio sono necessarie.</p>
</div>
<div class="sect4">
<h5 id="using-const-to-create-local-names"><a class="anchor" href="#using-const-to-create-local-names"></a>Uso di <code>const</code> per creare nomi locali</h5>
<div class="paragraph">
<p>Un altro utilizzo delle espressioni lambda è nella creazione di nomi locali. Spesso abbiamo bisogno di nomi locali nelle nostre funzioni diversi da quelli che sono stati associati come parametri. Ad esempio, supponiamo di voler calcolare la funzione \(f(x,y)=x(1+xy)^2 y(1-y)(1+xy)(1-y\)]</p>
</div>
<div class="paragraph">
<p>che potremmo anche esprimere come</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{aligned}
      a &amp;=&amp; 1+xy\\
      b &amp;=&amp; 1-y\\
      f(x,y) &amp;=&amp; xa^2 +yb +ab
\end{aligned}\]
</div>
</div>
<div class="paragraph">
<p>Nello scrivere una funzione per calcolare \(f\), vorremmo includere come nomi locali non solo \(x\) e \(y\) ma anche i nomi di quantità intermedie come \(a\) e \(b\). Un modo per ottenere ciò è utilizzare una funzione ausiliaria per associare i nomi locali:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function f(x, y) {
    function f_ausiliaria(a, b) {
        return x * quadrato(a) +
               y * b +
               a * b;
    }
    return f_ausiliaria(1 + x * y,
                    1 - y);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Potremmo usare un&#8217;espressione lambda per specificare una funzione anonima per associare i nostri nomi locali. Il corpo di <code>f</code> diventa quindi una singola chiamata a quella funzione:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function f(x,y) {
    return ( (a, b) =&gt; x * quadrato(a) +
                      y * b +
                      a * b
           )(1 + x * y, 1 - y);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Un modo più conveniente per dichiarare i nomi locali consiste nell&#8217;usare dichiarazioni di costanti all&#8217;interno del corpo della funzione. Usando "const", la funzione "f" può essere scritta come</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function f(x, y) {
    const a = 1 + x * y;
    const b = 1 - y;
    return x * quadrato(a) +
           y * b +
           a * b;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>I nomi dichiarati con <code>const</code> all&#8217;interno di un blocco hanno come visibilità il corpo del blocco immediatamente circostante.</p>
</div>
</div>
<div class="sect4">
<h5 id="conditional-statements"><a class="anchor" href="#conditional-statements"></a>Istruzioni condizionali</h5>
<div class="paragraph">
<p>Abbiamo visto che spesso è utile dichiarare nomi locali alle dichiarazioni di funzione. Quando le funzioni diventano grandi, dovremmo mantenere la visibilità dei nomi la più ristretta possibile. Considera ad esempio "potenza_modulo" in <a href="#ex:louis-fast-prime">Esercizio 1.26.</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function potenza_modulo(base, esponente, m) {
    return esponente === 0
           ? 1
           : pari(esponente)
             ? potenza_modulo(base, esponente / 2, m)
               * potenza_modulo(base, esponente / 2, m)
               % m
             : base
               * potenza_modulo(base, esponente - 1, m)
               % m;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Questa funzione è inutilmente inefficiente, perché contiene due chiamate identiche:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">potenza_modulo(base, esponente / 2, m)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Anche se questo può essere facilmente risolto in questo esempio usando la funzione <code>quadrato</code>, non è così facile in generale. Senza usare "quadrato", saremmo tentati di introdurre un nome locale per l&#8217;espressione come segue:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function potenza_modulo(base, esponente, m) {
    const da_quadrare = potenza_modulo(base, esponente / 2, m);
    return esponente === 0
           ? 1
           : pari(esponente)
             ? da_quadrare
               * da_quadrare
               % m
             : base
               * potenza_modulo(base, esponente - 1, m)
               % m;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ciò renderebbe la funzione non solo inefficiente, ma addirittura non terminante! Il problema è che la dichiarazione della costante appare al di fuori dell&#8217;espressione condizionale, il che significa che viene eseguita anche quando viene soddisfatto il caso base <code>esponente === 0</code>. Per evitare questa situazione, il linguaggio fornisce le <em>istruzione condizionali</em> e permette che le istruzioni <code>return</code> appaiano in rami diversi dell&#8217;istruzione condizionale. Utilizzando un&#8217;istruzione condizionale, la funzione <code>potenza_modulo</code> può essere scritta come segue:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function potenza_modulo(base, esponente, m) {
    if (esponente === 0) {
        return 1;
    } else {
        if (pari(esponente)) {
            const da_quadrare = potenza_modulo(base, esponente / 2, m);
            return da_quadrare * da_quadrare % m;
        } else {
            return base * potenza_modulo(base, esponente - 1, m) % m;
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>La forma generale di un&#8217;istruzione condizionale è</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Forma generale di un&#8217;istruzione condizionale</div>
<div class="paragraph">
<p><strong>if (</strong><em>predicato</em><strong>) {</strong> <em>conseguente</em> <strong>} else {</strong> <em>alternativa</em> <strong>}</strong></p>
</div>
</div>
</div>
<div class="paragraph">
<p>e, come le espressioni condizionali, la loro valutazione prima valuta il <em>predicato</em>. Se restituisce true, l&#8217;interprete valuta le istruzioni <em>conseguente</em> e se restituisce false, l&#8217;interprete valuta le istruzioni <em>alternativa</em>. Si noti che tutte le dichiarazioni di costanti che appaiono in una delle parti sono locali rispetto a quella parte, perché entrambe sono racchiuse tra parentesi graffe e quindi formano il proprio blocco.</p>
</div>
<div class="exampleblock">
<div class="title">Esercizio 1.34. Applicazione di una funzione a se stessa</div>
<div class="content">
<div class="paragraph">
<p>Supponiamo di dichiarare</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function f(g) {
   return g(2);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Poi abbiamo</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">f(quadrato);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">f(z =&gt; z * (z + 1));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Cosa succede se chiediamo (perversamente) all&#8217;interprete di valutare l&#8217;applicazione <code>f (f)</code>? Spiegarlo.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:proc-general-methods"><a class="anchor" href="#sec:proc-general-methods"></a>1.3.3. Funzioni come metodi generali</h4>
<div class="paragraph">
<p>Abbiamo introdotto le funzioni composte nel <a href="#sp_funzioni_composte">paragrafo 1.1.4</a> come meccanismo per astrarre modelli di operazioni numeriche in modo da renderle indipendenti dai numeri particolari coinvolti. Con le funzioni di ordine superiore, come la funzione <code>integrale</code> del <a href="#sec:procedures-as-parameters">paragrafo 1.3.1</a>, abbiamo iniziato a vedere un tipo più potente di astrazione: funzioni usate per esprimere metodi generali di calcolo, indipendentemente dalle funzioni particolari coinvolte. In questo paragrafo discuteremo due esempi più elaborati - dei metodi generali per trovare zeri e punti fissi di funzioni - e mostreremo come questi metodi possono essere espressi direttamente come funzioni.</p>
</div>
<div class="sect4">
<h5 id="finding-roots-of-equations-by-the-half-interval-method"><a class="anchor" href="#finding-roots-of-equations-by-the-half-interval-method"></a>Trovare le radici delle equazioni con il metodo della bisezione</h5>
<div class="paragraph">
<p>Il <em>metodo di bisezione</em> è una tecnica semplice ma potente per trovare le radici di un&#8217;equazione \(f (x) = 0\), dove \(f\) è una funzione continua. L&#8217;idea è che, se ci vengono dati due punti \(a\) e \(b\) tali che \(f (a) &lt; 0 &lt; f (b)\), allora \(f\) deve avere almeno uno zero tra \(a\) e \(b\). Per individuare uno zero, sia \(x\) la media di \(a\) e \(b\) e calcoli \(f (x)\). Se \(f (x)&gt; 0\), \(f\) deve avere uno zero tra \(a\) e \(x\). Se \(f (x) &lt;0\), \(f\) deve avere uno zero tra \(x\) e \(b\). Continuando in questo modo, possiamo identificare intervalli sempre più piccoli su cui \(f\)deve avere uno zero. Quando raggiungiamo un punto in cui l&#8217;intervallo è abbastanza piccolo, il processo si interrompe. Poiché l&#8217;intervallo di incertezza si riduce della metà in ogni fase del processo, il numero di passaggi richiesti cresce come \(\Theta (\log (L / T))\), dove \(L\) è la lunghezza dell&#8217;intervallo originale e \(T\) è la tolleranza all&#8217;errore (ovvero, la dimensione dell&#8217;intervallo che considereremo <em>abbastanza piccola</em>). Ecco una funzione che implementa questa strategia:<sup class="footnote">[<a id="_footnoteref_27" class="footnote" href="#_footnotedef_27" title="View footnote.">27</a>]</sup></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function cerca(f, punto_negativo, punto_positivo) {
    const punto_medio = valor_medio(punto_negativo,punto_positivo);
    if (abbastanza_vicino(punto_negativo, punto_positivo)) {
        return punto_medio;
    } else {
        const valore_da_confrontare = f(punto_medio);
        if (positivo(valore_da_confrontare)) {
            return cerca(f, punto_negativo, punto_medio);
        } else if (negativo(valore_da_confrontare)) {
            return cerca(f, punto_medio, punto_positivo);
        } else {
            return punto_medio;
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Assumiamo di avere inizialmente la funzione \(f\) insieme ai punti in cui i suoi valori sono negativi e positivi. Calcoliamo prima il punto medio dei due punti dati. Successivamente controlliamo per vedere se l&#8217;intervallo dato è abbastanza piccolo e, in tal caso, restituiamo semplicemente il punto medio come risposta. Altrimenti, calcoliamo come valore di test il valore di \(f\) nel punto medio. Se il valore del test è positivo, continuiamo il processo con un nuovo intervallo che va dal punto negativo originale al punto medio. Se il valore del test è negativo, continuiamo con l&#8217;intervallo dal punto medio al punto positivo. Infine, c&#8217;è la possibilità che il valore del test sia 0, nel qual caso il punto_medio è esso stesso la radice che stiamo cercando. Per verificare se i punti estremi sono <em>abbastanza vicini</em> possiamo usare una funzione simile a quella usata nel <a href="#sec:sqrt">paragrafo 1.1.7</a> per calcolare le radici quadrate: <sup class="footnote">[<a id="_footnoteref_28" class="footnote" href="#_footnotedef_28" title="View footnote.">28</a>]</sup></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function abbastanza_vicino(x,y) {
    return valore_assoluto(x - y) &lt; 0.001;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>La funzione <code>cerca</code> è scomoda da usare direttamente, perché possiamo accidentalmente assegnarle punti in cui i valori di \(f\) non hanno il segno richiesto, nel qual caso otteniamo una risposta sbagliata. Invece useremo <code>cerca</code> tramite la seguente funzione, che controlla quale dei punti estremi ha un valore di funzione negativo e quale ha un valore positivo, e chiama la funzione <code>cerca</code> di conseguenza. Se la funzione ha lo stesso segno sui due punti dati, il metodo di bisezione non può essere utilizzato, nel qual caso la funzione segnala un errore. <sup class="footnote">[<a id="_footnoteref_29" class="footnote" href="#_footnotedef_29" title="View footnote.">29</a>]</sup></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function metodo_bisezione(f, a, b) {
    const valore_in_a = f(a);
    const valore_in_b = f(b);
    return negativo(valore_in_a) &amp;&amp; positivo(valore_in_b)
           ? cerca(f, a, b)
           : negativo(valore_in_b) &amp;&amp; positivo(valore_in_a)
             ? cerca(f, b, a)
             : errore("i valori non sono di segno opposto");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>L&#8217;esempio seguente utilizza il metodo di bisezione per approssimare \(\pi\) come radice tra 2 e 4 di \(\sin \, x = 0\):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">metodo_bisezione(Math.sin, 2.0, 4.0);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ecco un altro esempio, utilizzando il metodo di bisezione per cercare una radice dell&#8217;equazione \(x^3 - 2x - 3 = 0\) tra 1 e 2:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">metodo_bisezione(
  x =&gt; x * x * x - 2 * x - 3,
  1.0,
  2.0);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="finding-fixed-points-of-functions"><a class="anchor" href="#finding-fixed-points-of-functions"></a>Trovare i punti fissi delle funzioni</h5>
<div class="paragraph">
<p>Un numero \(x\) è chiamato <em>punto fisso</em> di una funzione \(f\) if \(x\) soddisfa l&#8217;equazione \(f (x) = x\). Per alcune funzioni \(f\) possiamo individuare un punto fisso iniziando con un valore iniziale e applicando \(f\) ripetutamente, \(f (x), f (f (x)) , f (f (f (x))), \ldots\) fino a quando il valore non cambia più di molto. Usando questa idea, possiamo ideare una funzione <code>punto_fisso</code> che prende come input una funzione e una stima iniziale e produce un&#8217;approssimazione di un punto fisso della funzione. Applichiamo la funzione ripetutamente fino a trovare due valori successivi la cui differenza è inferiore a una certa tolleranza prescritta:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">const tolleranza = 0.00001;
function punto_fisso(f, stima_iniziale) {
    function abbastanza_vicino(x, y) {
        return valore_assoluto(x - y) &lt; tolleranza;
    }
    function prova_con(stima) {
        const prossimo = f(stima);
        return abbastanza_vicino(stima, prossimo)
               ? prossimo
               : prova_con(prossimo);
    }
    return prova_con(stima_iniziale);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ad esempio, possiamo usare questo metodo per approssimare il punto fisso della funzione coseno, iniziando con 1 come approssimazione iniziale:<sup class="footnote">[<a id="_footnoteref_30" class="footnote" href="#_footnotedef_30" title="View footnote.">30</a>]</sup></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">punto_fisso(math_cos, 1.0);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Allo stesso modo, possiamo trovare una soluzione all&#8217;equazione \(y = \sin y + \cos y\):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">punto_fisso(
    y =&gt; math_sin(y) + math_cos(y),
    1.0);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Il processo a virgola fissa ricorda il processo che abbiamo usato per trovare le radici quadrate nel <a href="#sec:sqrt">paragrafo 1.1.7</a>. Entrambi si basano sull&#8217;idea di migliorare ripetutamente un&#8217;ipotesi finché il risultato non soddisfa un criterio. In effetti, possiamo facilmente formulare il calcolo della radice quadrata come una ricerca di un punto fisso. Il calcolo della radice quadrata di un numero \(x\) richiede di trovare un \(y\) tale che \(y^2 = x\). Mettendo questa equazione nella forma equivalente \(y = x / y\), riconosciamo che stiamo cercando un punto fisso della nota funzione: <sup class="footnote">[<a id="_footnoteref_31" class="footnote" href="#_footnotedef_31" title="View footnote.">31</a>]</sup> \(y \mapsto x / y\), e possiamo quindi provare a calcolare le radici quadrate come</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function radice_quadrata() {
    return punto_fisso(y =&gt; x / y, 1.0);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sfortunatamente, questa ricerca del punto fisso non converge. Considera una prima stima \(y_1\). La prossima stima è \(y_2 = x / y_1\) e la successiva è \(y_3 = x / y_2 = x / (x / y_1) = y_1\). Ciò si traduce in un ciclo infinito in cui le due stime \(y_1\) e \(y_2\) si ripetono più e più volte, oscillando intorno alla soluzione.</p>
</div>
<div class="paragraph">
<p>Un modo per controllare tali oscillazioni è impedire che le ipotesi cambino così tanto. Poiché la risposta è sempre tra la nostra stima \(y\) e \(x / y\), possiamo fare una nuova stima che non sia così lontana da \(y\) come \(x / y\) calcolando la media di \(y\) con \(x / y\), in modo che la prossima stima dopo \(y\) sia \(\frac{1}{2} (y + x / y)\) invece di \(x / y\). Il processo per fare una tale sequenza di valori è semplicemente il processo di ricerca di un punto fisso di \(y \ mapsto \frac{1}{2} (y + x / y)\):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function radice_quadrata() {
    return punto_fisso(
               y =&gt; valor_medio(y, x / y),
               1.0);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>(Nota che \(y = \frac{1}{2} (y + x / y)\) è una semplice trasformazione dell&#8217;equazione \(y = x / y\); per derivarlo, aggiungi \(y\) su entrambi i lati dell&#8217;equazione e dividi per 2.)</p>
</div>
<div class="paragraph">
<p>Con questa modifica, la funzione per l&#8217;estrazione della radice quadrata funziona. Infatti, se sveliamo le definizioni, possiamo vedere che la sequenza di approssimazioni alla radice quadrata generata qui è esattamente la stessa di quella generata dalla nostra funzione radice quadrata originale del <a href="#sec:sqrt">paragrafo 1.1.7</a>. Questo approccio di calcolare la media di approssimazioni successive a una soluzione, una tecnica che chiamiamo <em>smorzamento tramite media</em>, spesso aiuta la convergenza delle ricerche dei punti fissi.</p>
</div>
<div class="exampleblock">
<div class="title">Esercizio 1.35. Calcolo della sezione aurea</div>
<div class="content">
<div class="paragraph">
<p>Mostra che la sezione aurea \(\phi\) (<a href="#sp_ricorsione_ad_albero">paragrafo 1.2.2</a>) è un punto fisso della trasformazione \(x \mapsto 1 + 1 / x\), e usa questo fatto per calcolare \(\phi\) tramite la funzione <code>punto_fisso</code>.</p>
</div>
</div>
</div>
<div id="ex:log-fixed-point" class="exampleblock">
<div class="title">Esercizio 1.36.</div>
<div class="content">
<div class="paragraph">
<p>Modifica <code>punto_fisso</code> in modo che stampi la sequenza di approssimazioni che genera, utilizzando la funzione primitiva <code>display</code> mostrata nel <a href="#ex:search-for-primes">Esercizio 1.22. Fare esperienza della complessità di ricerca dei numeri primi grandi</a>. Quindi trova una soluzione a \(x^x = 1000\) trovando un punto fisso di \(x \mapsto \log (1000) / \log (x)\). (Usa la funzione primitiva <code>math_log</code> che calcola i logaritmi naturali.) Confronta il numero di passi che questo richiede con e senza lo <em>smorzamento mediante media</em>. (Nota che non puoi iniziare <code>punto_fisso</code> con un&#8217;ipotesi di 1, poiché ciò causerebbe la divisione per \(\log (1) = 0\).)</p>
</div>
</div>
</div>
<div id="ex:continued-fractions" class="exampleblock">
<div class="title">Esercizio 1.37. Frazioni continue</div>
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Una <em>frazione continua</em> infinita è un&#8217;espressione della forma</p>
<div class="openblock">
<div class="content">
<div class="stemblock">
<div class="content">
\[ f={\dfrac{N_1}{D_1+
          \dfrac{N_2}{D_2+
          \dfrac{N_3}{D_3+\cdots }}}}\]
</div>
</div>
<div class="paragraph">
<p>Ad esempio, si può mostrare che l&#8217;espansione continua infinita della frazione con \(N_i\) e \(D_i\) tutti uguali a 1 produce \(1 / \phi\), dove \(\phi\)  è la sezione aurea (descritta nel <a href="#sp_ricorsione_ad_albero">paragrafo 1.2.2</a>]). Un modo per approssimare una frazione continua infinita è troncare l&#8217;espansione dopo un dato numero di termini. Una frazione continua finita troncata al \(k\)-esimo termine, che chiamero <em>\(k\)-termine</em> ha la forma:</p>
</div>
<div class="stemblock">
<div class="content">
\[{\dfrac{N_1}{D_1 +
          \dfrac{N_2}{\ddots +
          \dfrac{N_K}{D_K}}}}\]
</div>
</div>
<div class="paragraph">
<p>Supponiamo che <code>n</code> e <code>d</code> siano funzioni di un argomento (il termine indice \(i\)) che restituiscono \(N_i\) e \(D_i\) dei termini della frazione continua. Dichiara una funzione <code>fraz_cont</code> tale che la valutazione di `fraz_cont (n, d, k)`calcola il valore di latexmath: [$ k $] - termine finito frazione continua. Controlla la tua funzione approssimando \(1 / \phi\) usando</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">fraz_cont(i =&gt; 1.0,
          i =&gt; 1.0,
          k);</code></pre>
</div>
</div>
<div class="paragraph">
<p>per valori successivi di <code>k</code>. Quanto grande devi fare <code>k</code> per ottenere un&#8217;approssimazione che sia accurata fino a 4 cifre decimali?</p>
</div>
</div>
</div>
</li>
<li>
<p>Se la tua funzione <code>fraz_cont</code> genera un processo ricorsivo, scrivine uno che generi un processo iterativo. Se genera un processo iterativo, scrivine uno che generi un processo ricorsivo.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Esercizio 1.38.</div>
<div class="content">
<div class="paragraph">
<p>Nel 1737, il matematico svizzero Leonhard Euler (Eulero) pubblicò un libro di memorie <em>De Fractionibus Continuis</em>, che includeva una espansione in frazione continua di \(e-2\), dove \(e\) è la base dei logaritmi naturali. In questa frazione, \(N_i\) sono tutti 1 e \(D_i\) sono successivamente 1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8, &#8230;&#8203; . Scrivi un programma, basato sull&#8217;espansione di Eulero, che utilizzi la tua funzione <code>fraz_cont</code> dell&#8217;esercizio <a href="#ex:continued-fractions">Esercizio 1.37. Frazioni continue</a> per approssimare \(e\).</p>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Esercizio 1.39. Approssimare \(e\)</div>
<div class="content">
<div class="paragraph">
<p>Una rappresentazione in frazione continua della funzione tangente fu pubblicata nel 1770 dal matematico tedesco J.H. Lambert:</p>
</div>
<div class="stemblock">
<div class="content">
\[\tan x={\dfrac{x}{1-
      \dfrac{x^2}{3-
      \dfrac{x^2}{5-
      \dfrac{x^2}{ \ddots }}}}}\]
</div>
</div>
<div class="paragraph">
<p>dove \(x\) è espresso in radianti. Dichiarare una funzione <code>tan_cf (x, k)</code> che calcola un&#8217;approssimazione alla funzione tangente basata sulla formula di Lambert. Come in <a href="#ex:continued-fractions">Esercizio 1.37. Frazioni continue</a>, <code>k</code> specifica il numero di termini da calcolare.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:proc-returned-values"><a class="anchor" href="#sec:proc-returned-values"></a>1.3.4. Funzioni come valori restituiti</h4>
<div class="paragraph">
<p>Gli esempi precedenti dimostrano come la capacità di passare funzioni come argomenti accresca in modo significativo la potenza espressiva del nostro linguaggio di programmazione. Possiamo ottenere un potere espressivo ancora maggiore creando funzioni i cui valori restituiti sono essi stessi funzioni.</p>
</div>
<div class="paragraph">
<p>Possiamo illustrare questa idea guardando di nuovo l&#8217;esempio del punto fisso descritto alla fine del <a href="#sec:proc-general-methods">paragrafo 1.3.3</a>. Abbiamo formulato una nuova versione della funzione per il calcolo della radice quadrata come ricerca in punto fisso, partendo dall&#8217;osservazione che \(\sqrt{x}\) è un punto fisso della funzione \(y \mapsto x / y\). Quindi abbiamo utilizzato lo smorzamento tramite media per far convergere le approssimazioni. Lo smorzamento tramite media è di per sé un&#8217;utile tecnica generale. Vale a dire, data una funzione \(f\), consideriamo la funzione il cui valore in \(x\) è uguale alla media di \(x\) e \(f (x)\).</p>
</div>
<div class="paragraph">
<p>Possiamo esprimere l&#8217;idea di smorzamento medio mediante la seguente funzione:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function smorazmento(f) {
    return x =&gt; valor_medio(x, f(x));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>La funzione <code>smorazmento</code> è una funzione che prende come argomento una funzione <code>f</code> e restituisce come valore una funzione (prodotta dall&#8217;espressione lambda) che, quando applicata a un numero <code>x</code>, produce la media di <code>x</code> e <code>f (x)</code>. Ad esempio, l&#8217;applicazione di <code>smorzamento</code> alla funzione <code>quadrato</code> produce una funzione il cui valore per un certo numero \(x\) è la media di \(x\) e \(x^2\). L&#8217;applicazione di questa funzione risultante per 10 restituisce la media di 10 e 100 ossia 55: <sup class="footnote">[<a id="_footnoteref_32" class="footnote" href="#_footnotedef_32" title="View footnote.">32</a>]</sup></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">smorzameto(quadrato)(10);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usando <code>smorzamento</code>, possiamo riformulare la funzione radice quadrata come segue:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function radice_quadrata(x) {
    return punto_fisso(smorzamento(y =&gt; x / y),
                       1.0);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Si noti come questa formulazione rende esplicite le tre idee nel metodo: la ricerca di un punto fisso, lo smorzamento tramite media e la funzione \(y \mapsto x / y\). È istruttivo confrontare questa formulazione del metodo della radice quadrata con la versione originale fornita nel <a href="#sec:sqrt">paragrafo 1.1.7</a>. Tieni presente che queste funzioni esprimono lo stesso processo e nota quanto più chiara l&#8217;idea diventa quando esprimiamo il processo in termini di queste astrazioni. In generale, ci sono molti modi per formulare un processo come una funzione. I programmatori esperti sanno come scegliere formulazioni di processo particolarmente perspicaci e dove elementi utili del processo sono esposti come entità separate che possono essere riutilizzate in altre applicazioni. Come semplice esempio di riutilizzo, si noti che la radice cubica di \(x\) è un punto fisso della funzione \(y \mapsto x / y^2 \), quindi possiamo immediatamente generalizzare la nostra funzione radice quadrata a quella che estrae radici cubiche: <sup class="footnote">[<a id="_footnoteref_33" class="footnote" href="#_footnotedef_33" title="View footnote.">33</a>]</sup></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function radice_cubica(x) {
    return punto_fisso(smorzamento(y =&gt; x / quadrato(y)),
                       1.0);
}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="newtons-method"><a class="anchor" href="#newtons-method"></a>Metodo di Newton</h5>
<div class="paragraph">
<p>Quando abbiamo introdotto per la prima volta la funzione radice quadrata, nel <a href="#sec:sqrt">paragrafo 1.1.7</a>, abbiamo detto che questo era un caso speciale del metodo di <em>Newton</em>. Se \(x \mapsto g (x)\) è una funzione derivabile, allora una soluzione dell&#8217;equazione \(g (x) = 0\) è un punto fisso della funzione \(x \mapsto f (x)\) dove</p>
</div>
<div class="stemblock">
<div class="content">
\[f (x) = x - \frac {g (x)} {Dg (x)}\]
</div>
</div>
<div class="paragraph">
<p>e \(Dg (x)\) è il derivata di \(g\) valutata in \(x\). Il metodo di Newton è l&#8217;uso del metodo del punto fisso che abbiamo visto sopra per approssimare una soluzione dell&#8217;equazione trovando un punto fisso della funzione \(f\) <sup class="footnote">[<a id="_footnoteref_34" class="footnote" href="#_footnotedef_34" title="View footnote.">34</a>]</sup> Per molte funzioni \(g\) e per stime iniziali sufficientemente buone per \(x\), il metodo di Newton converge molto rapidamente a una soluzione di \(g (x) = 0\). <sup class="footnote">[<a id="_footnoteref_35" class="footnote" href="#_footnotedef_35" title="View footnote.">35</a>]</sup></p>
</div>
<div class="paragraph">
<p>Per implementare il metodo di Newton come una funzione, dobbiamo prima esprimere l&#8217;idea di derivata. Nota che la <em>derivata</em>, come lo smorzamento tramite media, è qualcosa che trasforma una funzione in un&#8217;altra funzione. Ad esempio, la derivata della funzione \(x \mapsto x^3\) è la funzione \(x \mapsto 3x^2\). In generale, se \(g\) è una funzione e \(dx\) è un numero piccolo, allora la derivata \(Dg\) di \(g\) è la funzione il cui valore in qualsiasi numero \(x\) è dato (nel limite di un piccolo \(dx\)) da</p>
</div>
<div class="stemblock">
<div class="content">
\[Dg (x) = \frac {g (x + dx) - g (x )} {dx}\]
</div>
</div>
<div class="paragraph">
<p>Quindi, possiamo esprimere l&#8217;idea di derivata (prendendo \(dx\) come, diciamo, 0,00001) come funzione</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function derivata(g) {
    return x =&gt; (g(x + dx) - g(x)) / dx;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>insieme alla dichiarazione</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">const dx = 0.00001;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Come <code>smorzamento</code>,` derivata` è una funzione che accetta una funzione come argomento e restituisce una funzione come valore. Ad esempio, per approssimare la derivata di \(x \mapsto x^3\) in 5 (il cui valore esatto è 75) possiamo valutare</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function cubo(x) { return x * x * x; }

derivata(cubo)(5);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Con l&#8217;aiuto della <code>derivata</code>, possiamo esprimere il metodo di Newton come un processo di punto fisso:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function trasformata_newton(g) {
   return x =&gt; x - g(x) / derivata(g)(x);
}
function metodo_newton(g, stima) {
   return punto_fisso(trasformata_newton(g), stima);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>La funzione <code>trasformata_newton</code> esprime la formula all&#8217;inizio di questa sezione, e <code>metodo_newton</code> è facilmente definita in termini di ciò. Prende come argomenti una funzione che calcola la funzione per la quale vogliamo trovare uno zero, insieme a una stima iniziale. Ad esempio, per trovare la radice quadrata di \(x\), possiamo usare il metodo di Newton per trovare uno zero della funzione \(y \mapsto y^2-x\) iniziando con una stima iniziale di 1.<sup class="footnote">[<a id="_footnoteref_36" class="footnote" href="#_footnotedef_36" title="View footnote.">36</a>]</sup> Questo fornisce ancora un&#8217;altra forma della funzione radice quadrata:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function radice_quadrata(x) {
    return metodo_newton(y =&gt; quadrato(y) - x,
                          1.0);
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="abstractions-and-first-class-functions"><a class="anchor" href="#abstractions-and-first-class-functions"></a>Astrazioni e funzioni di prima classe</h5>
<div class="paragraph">
<p>Abbiamo visto due modi per esprimere il calcolo della radice quadrata come istanza di un metodo più generale, una volta come ricerca di un punto fisso e una volta utilizzando il metodo di Newton. Poiché il metodo di Newton era esso stesso espresso come un processo di punto fisso, abbiamo effettivamente visto due modi per calcolare le radici quadrate come punti fissi. Ogni metodo inizia con una funzione e trova un punto fisso di un qualche trasformazione della funzione. Possiamo esprimere questa idea generale stessa come una funzione:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function punto_fisso_di_trasformata(g, trasformata, stima) {
    return punto_fisso(transformata(g), stima);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Questa funzione molto generale prende come argomenti una funzione <code>g</code> che calcola qualche funzione, una funzione che trasforma <code>g</code> e una stima iniziale. Il risultato restituito è un punto fisso della funzione trasformata.</p>
</div>
<div class="paragraph">
<p>Usando questa astrazione, possiamo riscrivere il primo modo di calcolare la radice quadrata di questo paragrafo (dove cerchiamo un punto fisso della versione smorzata di \(y \mapsto x / y\)) come istanza di questo metodo generale:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function radice_quadrata(x) {
    return punto_fisso_di_trasformata(
               y =&gt; x / y,
               smorzamento,
               1.0);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Allo stesso modo, possiamo esprimere il secondo metodo per il calcolo della radice quadrata di questo paragrafo (un&#8217;istanza del metodo di Newton che trova un punto fisso della trasformata di Newton di \(y \mapsto y^2-x\)) come</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">function radice_quadrata(x) {
    return punto_fisso_di_trasformata(
               y =&gt; square(y) - x,
               trasformata_newton,
               1.0);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Abbiamo iniziato il <a href="#sec:higher-order-procedures">paragrafo 1.3</a> osservando che le funzioni composte sono un meccanismo di astrazione cruciale, perché ci permettono di esprimere metodi generali di calcolo come elementi espliciti nel nostro linguaggio di programmazione. Ora abbiamo visto come le funzioni di ordine superiore ci permettono di manipolare questi metodi generali per creare ulteriori astrazioni.</p>
</div>
<div class="paragraph">
<p>Come programmatori, dovremmo essere attenti alle opportunità di identificare le astrazioni sottostanti nei nostri programmi e di costruire su di esse e generalizzarle per creare astrazioni più potenti. Questo non vuol dire che si debba sempre scrivere programmi nel modo più astratto possibile; i programmatori esperti sanno scegliere il livello di astrazione appropriato al loro compito. Ma è importante essere in grado di pensare in termini di queste astrazioni, in modo da essere pronti ad applicarle in nuovi contesti. Il significato delle funzioni di ordine superiore è che ci consentono di rappresentare queste astrazioni esplicitamente come elementi nel nostro linguaggio di programmazione, in modo che possano essere gestite proprio come gli altri elementi computazionali.</p>
</div>
<div class="paragraph">
<p>In generale, i linguaggi di programmazione impongono restrizioni sui modi in cui gli elementi computazionali possono essere manipolati. Si dice che gli elementi con il minor numero di restrizioni abbiano uno <em>status</em>. Alcuni dei <em>diritti e privilegi</em> degli elementi di prima classe sono:<sup class="footnote">[<a id="_footnoteref_37" class="footnote" href="#_footnotedef_37" title="View footnote.">37</a>]</sup></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Possono essere indicati utilizzando nomi.</p>
</li>
<li>
<p>Possono essere passati come argomenti alle funzioni.</p>
</li>
<li>
<p>Possono essere restituiti come risultati di funzioni.</p>
</li>
<li>
<p>Possono essere inclusi nelle strutture dati.<sup class="footnote">[<a id="_footnoteref_38" class="footnote" href="#_footnotedef_38" title="View footnote.">38</a>]</sup></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>JavaScript, a differenza di altri linguaggi di programmazione comuni, assegna alle funzioni uno status di prima classe completo. Ciò pone sfide per un&#8217;implementazione efficiente, ma il guadagno risultante in potenza espressiva è enorme.<sup class="footnote">[<a id="_footnoteref_39" class="footnote" href="#_footnotedef_39" title="View footnote.">39</a>]</sup></p>
</div>
<div id="ex:unlabeled26" class="exampleblock">
<div class="title">Esercizio 1.40.</div>
<div class="content">
<div class="paragraph">
<p>Dichiara una funzione <code>cubica</code> che può essere usata insieme alla funzione <code>metodo_newton</code> nelle espressioni della forma</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">metodo_newton(cubica(a, b, c), 1);</code></pre>
</div>
</div>
<div class="paragraph">
<p>per approssimare gli zeri di \(x^3 + ax^2 + bx + c\).</p>
</div>
</div>
</div>
<div id="ex:unlabeled27" class="exampleblock">
<div class="title">Esercizio 1.41.</div>
<div class="content">
<div class="paragraph">
<p>Dichiara una funzione <code>applica_due_volte</code> che accetta una funzione di un argomento come argomento e restituisce una funzione che applica due volte la funzione originale. Ad esempio, se <code>inc</code> è una funzione che aggiunge 1 al suo argomento, allora <code>applica_due_volte(inc)</code> dovrebbe essere una funzione che aggiunge 2. Quale valore viene restituito da</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">applica_due_volte(applica_due_volte(applica_due_volte))(inc)(5);</code></pre>
</div>
</div>
</div>
</div>
<div id="ex:compose" class="exampleblock">
<div class="title">Esercizio 1.42. Componi</div>
<div class="content">
<div class="paragraph">
<p>Siano \(f\) e \(g\) due funzioni di un argomento. La <em>composizione</em> \(f\) dopo \(g\) è definita come la funzione \(x \mapsto f (g (x))\). Dichiarare una funzione <code>componi</code> che implementa la composizione. Ad esempio, se <code>inc</code> è una funzione che aggiunge 1 al suo argomento,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">componi(quadrato, inc)(6);</code></pre>
</div>
</div>
<div class="paragraph">
<p>restituisce 49.</p>
</div>
</div>
</div>
<div id="ex:repeated" class="exampleblock">
<div class="title">Esercizio 1.43.</div>
<div class="content">
<div class="paragraph">
<p>Se \(f\) è una funzione numerica e \(n\) è un numero intero positivo, allora possiamo formare la \(n\)-esima ripetizione dell&#8217;applicazione di \(f\), che è definita come la funzione il cui valore in \(x\) è \(f (f (\ldots (f (x)) \ldots))\). Ad esempio, se \(f\) è la funzione \(x \mapsto x + 1\), allora la \(n\) esima ripetizione dell&#8217;applicazione di \(f\) è la funzione \(x \mapsto x + n\). Se \(f\) è l&#8217;operazione di elevamento al quadratato di un numero, allora la \(n\)-esima ripetizione dell&#8217;applicazione di \(f\) è la funzione che eleva il suo argomento alla \(2^n\)-esima potenza. Scrivi una funzione che prenda come input una funzione che calcola \(f\) e un intero positivo \(n\) e che restituisca la funzione che calcola l'\(n\)-esima ripetizione dell&#8217;applicazione di \(f\). La tua funzione dovrebbe essere in grado di essere utilizzata come segue:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">ripeti_applicazione(quadrato, 2)(5);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Suggerimento: potresti trovare conveniente usare <code>componi</code> dall&#8217;esercizio <a href="#ex:compose">Esercizio 1.42. Componi</a>.</p>
</div>
</div>
</div>
<div id="ex:smooth" class="exampleblock">
<div class="title">Esercizio 1.44.</div>
<div class="content">
<div class="paragraph">
<p>L&#8217;idea di <em>lisciamento</em> (o <em>perequazione</em>) di una funzione è un concetto importante nell&#8217;elaborazione del segnale. Se \(f\) è una funzione e \(dx\) è un numero piccolo, la versione lisciata di \(f\) è la funzione il cui valore in un punto \(x\) è il valor medio di \(f (x-dx)\), \(f (x)\) e \(f (x + dx)\). Scrivete una funzione <code>liscia</code> che prenda come input una funzione che calcola \(f\) e restituisca una funzione che calcoli il lisciamento di \(f\). A volte è utile lisciare ripetutamente una funzione (cioè lisciare la funzione lisciata, e così via) per ottenere la funzione lisciata \(n\) volte. Mostra come generare la funzione per lisciare \(n\) volte una data funzione usando <code>liscia</code> e <code>ripeti_applicazione</code> dall&#8217;esercizio <a href="#ex:repeated">Esercizio 1.43.</a>.</p>
</div>
</div>
</div>
<div id="ex:nth-roots" class="exampleblock">
<div class="title">Esercizio 1.45.</div>
<div class="content">
<div class="paragraph">
<p>Abbiamo visto nel <a href="#sec:proc-general-methods">paragrafo 1.3.3</a> che il tentativo di calcolare le radici quadrate trovando ingenuamente un punto fisso di \(y \mapsto x / y\) non converge e che questo può essere risolto con lo smorzamento. Lo stesso metodo funziona per trovare le radici dei cubi come punti fissi dello smorzamento di  \(y \mapsto x / y ^ 2\). Sfortunatamente, il processo non funziona per le radici quarte: un singolo smorzamento non è sufficiente per fare convergere una ricerca di un punto fisso di \(y \mapsto x / y ^ 3\). D&#8217;altra parte, se facciamo la media dello smorzamento due volte (cioè, usiamo lo smorzamento dello smorzamento di \(y \mapsto x / y ^ 3\)) la ricerca del punto fisso converge. Fai alcuni esperimenti per determinare il numero di smorzamenti necessari per calcolare le \(n\)-esime radici come ricerca di un punto fisso basato sullo smorzamento ripetuto di \(y \mapsto x / y^{n-1}\). Usalo per implementare una semplice funzione per calcolare le radici \(n\)-esime radici usando <code>punto_fisso</code>, <code>smorzamento</code> e la funzione <code>ripeti_applicazione</code> dell&#8217;esercizio <a href="#ex:repeated">Esercizio 1.43.</a>. Supponi che tutte le operazioni aritmetiche di cui hai bisogno siano disponibili come primitive.</p>
</div>
</div>
</div>
<div id="ex:unlabeled28" class="exampleblock">
<div class="title">Esercizio 1.46.</div>
<div class="content">
<div class="paragraph">
<p>Molti dei metodi numerici descritti in questo capitolo sono esempi di una strategia computazionale estremamente generale nota come <em>miglioramento iterativo</em>. Il miglioramento iterativo dice che, per calcolare qualcosa, iniziamo con una stima iniziale della soluzione, testiamo se la stima è abbastanza buona, e se non lo è miglioriamo la stima e continuiamo il processo utilizzando la stima migliorata come nuova stima. Scrivi una funzione <code>migliora_iterativo</code> che accetta due funzioni come argomenti: un metodo per dire se una stima è abbastanza buona e un metodo per migliorare la stima. La funzione <code>migliora_iterativo</code> dovrebbe restituire come valore una funzione che accetta una stima come argomento e continua a migliorare la stima finché non è abbastanza buona. Riscrivi la funzione <code>radice_quadrata</code> del <a href="#sec:sqrt">paragrafo 1.1.7</a> e la funzione <code>punto_fisso</code> del <a href="#sec:proc-general-methods">paragrafo 1.3.3</a> in termini di <code>migliora_iterativo</code>.</p>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnotedef_1">
<a href="#_footnoteref_1">1</a>. Un espressione è tutto ciò che produce un valore.
</div>
<div class="footnote" id="_footnotedef_2">
<a href="#_footnoteref_2">2</a>. Il costrutto di astrazione permette di dare un nome agli oggetti computazionali e permette di manipolarli come fossero oggetti primitivi. Ci permette, anche, di dimenticarci dei dettagli, come sarà evidente nel prosieguo.
</div>
<div class="footnote" id="_footnotedef_3">
<a href="#_footnoteref_3">3</a>. Il concetto di ambiente è fondamentale sia per compredere come funziona un interprete, sia per realizzarne uno.
</div>
<div class="footnote" id="_footnotedef_4">
<a href="#_footnoteref_4">4</a>. Una stringa indica una sequenza di caratteri
</div>
<div class="footnote" id="_footnotedef_5">
<a href="#_footnoteref_5">5</a>. Si osservi che ci sono due operazioni distinte: si crea la funzione e quindi le si dà un nome. È, infatti, molto utile separare i due concetti sia per creare funzioni senza doverle nominare sia per dare nomi a funzioni che sono state create.
</div>
<div class="footnote" id="_footnotedef_6">
<a href="#_footnoteref_6">6</a>. In generale, il corpo di una funzione può contenere una sequenza di istruzioni. Nel caso, l&#8217;interprete valuta un&#8217;istruzione per volota della sequenza finché un&#8217;istruzione di restituzione del controllo non determina il valore dell&#8217;applicazione della funzione agli argomenti.
</div>
<div class="footnote" id="_footnotedef_7">
<a href="#_footnoteref_7">7</a>. Queste affermazioni mascherano una grande semplificazione eccessiva. Ad esempio, se contiamo i passi del processo come operazioni della macchina, assumiamo che il numero di operazioni della macchina necessarie per eseguire, diciamo, una moltiplicazione sia indipendente dalla dimensione dei numeri da moltiplicare, il che è falso se i numeri sono sufficientemente grande. Osservazioni simili valgono per le stime dello spazio. Come la progettazione e la descrizione di un processo, l&#8217;analisi di un processo può essere effettuata a vari livelli di astrazione.
</div>
<div class="footnote" id="_footnotedef_8">
<a href="#_footnoteref_8">8</a>. Sembra sorprendente che qualcuno possa preoccuparsi di elevare un numero alla millesima potenza. Si veda <a href="#sp_test_di_primalita">paragrafo 1.2.6</a>.
</div>
<div class="footnote" id="_footnotedef_9">
<a href="#_footnoteref_9">9</a>. Questo algoritmo iterativo è antico. Appare nel <em>Chandah-sutra</em> di Áchárya, scritto prima del 200 a.C. Vedere Knuth 1981, sezione 4.6.3, per una discussione e un&#8217;analisi completa di questo e altri metodi di elevamento a potenza.
</div>
<div class="footnote" id="_footnotedef_10">
<a href="#_footnoteref_10">10</a>. Questo algoritmo, che a volte è noto come il <em>metodo del contadino russo</em>''__ per la moltiplicazione, è antico. Esempi del suo utilizzo si trovano nel papiro Rhind, uno dei due più antichi documenti matematici esistenti, scritto intorno al 1700 a.C. (e copiato da un documento ancora più antico) da uno scriba egiziano di nome A&#8217;h-mose.
</div>
<div class="footnote" id="_footnotedef_11">
<a href="#_footnoteref_11">11</a>. Questo esercizio ci è stato suggerito da Joe Stoy, sulla base di un esempio in Kaldewaij 1990.
</div>
<div class="footnote" id="_footnotedef_12">
<a href="#_footnoteref_12">12</a>. L'<em>Algoritmo di Euclide</em> è così chiamato perché appare negli <em>Elementi</em> di Euclide (Libro 7, circa 300 a.C. Secondo Knuth (1973), può essere considerato il più antico algoritmo non banale conosciuto. L&#8217;antico metodo egiziano di moltiplicazione (esercizio ??) è sicuramente più antico, ma, come spiega Knuth, l&#8217;algoritmo di Euclide è il più antico noto per essere stato presentato come un algoritmo generale, piuttosto che come un serie di esempi illustrativi.
</div>
<div class="footnote" id="_footnotedef_13">
<a href="#_footnoteref_13">13</a>. Se \(d\) è un divisore di \(n\), lo è anche \(n / d\). Ma \(d\) e \(n / d\) non possono essere entrambi maggiori di \(\sqrt{n}\).
</div>
<div class="footnote" id="_footnotedef_14">
<a href="#_footnoteref_14">14</a>. Pierre de Fermat (1601–1665) è considerato il fondatore della moderna teoria dei numeri. Ottenne molti importanti risultati di teoria dei numeri, ma di solito annunciava solo i risultati, senza fornire le sue dimostrazioni. Il piccolo teorema di Fermat fu enunciato in una lettera che scrisse nel 1640. La prima dimostrazione pubblicata fu data da Eulero nel 1736 (e una dimostrazione identica e precedente fu scoperta nei manoscritti inediti di Leibniz). Il più famoso dei risultati di Fermat, noto come Ultimo teorema di Fermat, fu annotato nel 1637 nella sua copia del libro <em>Aritmetica</em> (del matematico greco del III secolo Diofanto) con l&#8217;osservazione: <em>Ho scoperto una dimostazione davvero notevole, ma questo  margine è troppo piccolo per contenerla.</em> Trovare una dimostrazione dell&#8217;ultimo teorema di Fermat divenne una delle sfide più famose nella teoria dei numeri. Una soluzione completa è stata infine fornita nel 1995 da Andrew Wiles della Princeton University.
</div>
<div class="footnote" id="_footnotedef_15">
<a href="#_footnoteref_15">15</a>. I passi di riduzione nei casi in cui l&#8217;esponente \(e\) è maggiore di 1 si basano sul fatto che, per qualsiasi interi \(x\), \(y\) e \(m\), possiamo trovare il resto di \(x\) per \(y\) modulo \(m\) calcolando separatamente i resti di \(x\) modulo \(m\) e \(y\) modulo \(m\), moltiplicandoli e quindi prendendo il resto del risultato modulo \(m\). Ad esempio, nel caso in cui \(e\) è pari, calcoliamo il resto di \(b^{e / 2}\) modulo \(m\), ne facciamo il quadrato e prendiamo il resto modulo \(m\). Questa tecnica è utile perché significa che possiamo eseguire il nostro calcolo senza dover mai avere a che fare con numeri molto più grandi di \(m\). (Confronta l&#8217;esercizio <a href="#ex:Alyssas-expmod">Esercizio 1.25.</a>.)
</div>
<div class="footnote" id="_footnotedef_16">
<a href="#_footnoteref_16">16</a>. I numeri che ingannano il test di Fermat sono chiamati <em>numeri di Carmichael</em>, e poco si sa su di loro oltre al fatto che sono estremamente rari. Ci sono 255 numeri di Carmichael sotto i 100.000.000. I più piccoli sono 561, 1105, 1729, 2465, 2821 e 6601. Nel testare la primalità di numeri molto grandi scelti a caso, la possibilità di imbattersi in un valore che inganna il test di Fermat è inferiore alla possibilità che la radiazione cosmica farà commettere un errore computer nell&#8217;esecuzione di un algoritmo <em>corretto</em>. Considerare un algoritmo inadeguato per la prima ragione ma non per la seconda illustra bene la differenza tra matematica e ingegneria.
</div>
<div class="footnote" id="_footnotedef_17">
<a href="#_footnoteref_17">17</a>. Una delle applicazioni più sorprendenti dei test probabilistici di primalità è nel campo della crittografia. Sebbene ora sia computazionalmente impossibile fattorizzare un numero arbitrario di 200 cifre, la primalità di tale numero può essere verificata in pochi secondi con il test di Fermat. Questo fatto costituisce la base di una tecnica suggerita da Rivest, Shamir e Adleman (1977) per costruire <em>codici indistruttibili</em>. Il risultato è diventato una tecnica ampiamente utilizzata per migliorare la sicurezza delle comunicazioni elettroniche. Per questo e per i relativi sviluppi, lo studio dei numeri primi, un tempo considerato l&#8217;epitome di un argomento di matematica <em>pura</em> da studiare solo per il piacere di farlo, risulta ora avere importanti applicazioni pratiche alla crittografia, al trasferimento elettronico di fondi e recupero delle informazioni.
</div>
<div class="footnote" id="_footnotedef_18">
<a href="#_footnoteref_18">18</a>. Questa data, 1970-01-01 00:00:00 UTC, è chiamata <em>UNIX epoch</em> e fa parte del specifica delle funzioni che si occupano del tempo nel sistema operativo UNIX&#8482;.
</div>
<div class="footnote" id="_footnotedef_19">
<a href="#_footnoteref_19">19</a>. La funzione primitiva <code>display</code> restituisce il suo argomento, ma lo stampa anche. Qui <em>***</em> è una <em>stringa</em>, una sequenza di caratteri che passiamo come argomento alla funzione <code>display</code>. La sezione &lt;&lt;+ sp_stringhe &gt;&gt;+ introduce le stringhe in modo più approfondito.
</div>
<div class="footnote" id="_footnotedef_20">
<a href="#_footnoteref_20">20</a>. Questa serie, di solito scritta nella forma equivalente \(\frac{\pi}{4} = 1-\frac{1}{3}\frac{1}{5}-\frac{1}{7}\cdots\), è dovuta a Leibniz. Vedremo come utilizzarla come base per alcuni fantasiosi trucchi numerici nella sezione TODO sec:exploiting-streams.
</div>
<div class="footnote" id="_footnotedef_21">
<a href="#_footnoteref_21">21</a>. Nota che abbiamo usato la struttura a blocchi (<a href="#sec:black-box">paragrafo 1.1.8</a>) per incorporare le dichiarazioni di <code>pi_termine</code> e <code>pi_prossimo</code> all&#8217;interno di <code>somma_pi</code>, poiché è improbabile che queste funzioni siano utili per altri scopi. Vedremo come eliminarli del tutto nel <a href="#sec:lambda">paragrafo 1.3.2</a>.
</div>
<div class="footnote" id="_footnotedef_22">
<a href="#_footnoteref_22">22</a>. L&#8217;intento degli esercizi <a href="#es_prodotto">Esercizio 1.31. Prodotto dei valori di una funzione in un intervallo</a>&#8201;&#8212;&#8201;<a href="#es_filtra_accumula">Esercizio 1.33. Accumula i valori filtrati</a> è quello di dimostrare il potere espressivo che si ottiene utilizzando un&#8217;astrazione appropriata per unificare molte operazioni apparentemente diverse. Tuttavia, sebbene l&#8217;accumulazione e il filtraggio siano idee eleganti, a questo punto siamo in qualche modo costretti ad usarle poiché non abbiamo ancora strutture di dati per fornire mezzi di combinazione adeguati per queste astrazioni. Ritorneremo su queste idee nel TODO sec:sequences-traditional-interfaces quando mostreremo come usare le <em>sequenze</em> come interfacce per combinare filtri e accumulatori per costruire astrazioni ancora più potenti. Vedremo qui come questi metodi si rivelino un approccio davvero potente ed elegante alla progettazione di programmi.
</div>
<div class="footnote" id="_footnotedef_23">
<a href="#_footnoteref_23">23</a>. Questa formula fu scoperta dal matematico inglese del XVII secolo John Wallis.
</div>
<div class="footnote" id="_footnotedef_24">
<a href="#_footnoteref_24">24</a>. Se è presente un solo parametro, le parentesi intorno all&#8217;elenco dei parametri possono anche essere omesse. Nel TODO sec:graphics, estenderemo la sintassi delle espressioni lambda per consentire di avere i blocchi come corpo, come nelle dichiarazioni di dichiarazione di funzione.
</div>
<div class="footnote" id="_footnotedef_25">
<a href="#_footnoteref_25">25</a>. In JavaScript ci sono sottili differenze tra le due versioni: le istruzioni di dichiarazione di funzione (<strong>function <em>nome</em></strong>) sono <em>sollevate</em> (<em>hoisted</em>, spostate automaticamente) all&#8217;inizio del blocco circostante, mentre le dichiarazioni di costanti non lo sono, e i nomi dichiarati con le dichiarazioni di funzione (<strong>const <em>nome</em> = ( <em>parametri</em> ) &#8658; <em>espressione</em></strong>) possono essere riassegnata usando l&#8217;assegnazione (vedi TODO sec:assegnazione).
</div>
<div class="footnote" id="_footnotedef_26">
<a href="#_footnoteref_26">26</a>. Sarebbe più chiaro e meno intimidatorio per le persone che apprendono JavaScript se fosse usato un termine più ovvio dell&#8217;espressione lambda, come <em>definizione di funzione</em>. Ma la convenzione è molto ben radicata, non solo per Lisp e Scheme ma anche per JavaScript, Java e altri linguaggi, senza dubbio in parte a causa dell&#8217;influenza delle edizioni Scheme di questo libro. La notazione è adottata dal \(\lambda\)-calcolo, un formalismo matematico introdotto dal logico matematico Alonzo Church (1941). Church ha sviluppato il \(\lambda\)-calcolo per fornire una base rigorosa per lo studio delle nozioni di funzione e applicazione della funzione. Il \(\lambda\)-calcolo è diventato uno strumento di base per le indagini matematiche sulla semantica dei linguaggi di programmazione.
</div>
<div class="footnote" id="_footnotedef_27">
<a href="#_footnoteref_27">27</a>. Nota che estendiamo leggermente la sintassi delle istruzioni condizionali descritte nel <a href="#sec:lambda">paragrafo 1.3.2</a> ammettendo un&#8217;altra istruzione condizionale al posto del blocco che segue "else".
</div>
<div class="footnote" id="_footnotedef_28">
<a href="#_footnoteref_28">28</a>. Abbiamo usato 0.001 come un numero <em>piccolo</em> rappresentativo per indicare una tolleranza per l&#8217;errore accettabile in un calcolo. La tolleranza appropriata per un calcolo reale dipende dal problema da risolvere e dai limiti del computer e dell&#8217;algoritmo. Questa è spesso una considerazione molto raffinata, che richiede l&#8217;aiuto di un analista numerico o di qualche altro tipo di mago.
</div>
<div class="footnote" id="_footnotedef_29">
<a href="#_footnoteref_29">29</a>. Questo può essere ottenuto utilizzando <code>errore</code>, che prende come argomento una stringa che viene stampato come messaggio di errore insieme al numero della riga del programma che ha dato origine alla chiamata di "errore".
</div>
<div class="footnote" id="_footnotedef_30">
<a href="#_footnoteref_30">30</a>. Prova questo durante una lezione noiosa: imposta la tua calcolatrice in modalità radianti e poi premi ripetutamente il \(\cos\) fino ad ottenere il punto fisso.
</div>
<div class="footnote" id="_footnotedef_31">
<a href="#_footnoteref_31">31</a>. \(\mapsto\) è il modo in cui il matematico scrive le espressioni lambda. \(y \mapsto x / y\) significa <code>y &#8658; x / y</code>, cioè la funzione il cui valore in \(y\) è \(x / y\).
</div>
<div class="footnote" id="_footnotedef_32">
<a href="#_footnoteref_32">32</a>. Osserva che questa è una combinazione il cui operatore è esso stesso una combinazione. L&#8217;esercizio <a href="#ex:a-plus-abs-b">Esercizio 1.4. Riconoscere nel nome di funzione la valutazione dell&#8217;espressione</a> ha ​​già dimostrato la capacità di formare tali combinazioni, ma quello era solo un esempio giocattolo. Qui iniziamo a vedere la reale necessità di tali combinazioni, quando si applica una funzione ottenuta come valore restituito da una funzione di ordine superiore.
</div>
<div class="footnote" id="_footnotedef_33">
<a href="#_footnoteref_33">33</a>. Vedere l&#8217;esercizio <a href="#ex:nth-roots">Esercizio 1.45.</a> per un&#8217;ulteriore generalizzazione.
</div>
<div class="footnote" id="_footnotedef_34">
<a href="#_footnoteref_34">34</a>. I libri di calcolo elementare di solito descrivono il metodo di Newton in termini di la sequenza di approssimazioni \(x_ {n + 1} = x_n-g (x_n) / Dg (x_n)\). Avere un linguaggio per parlare dei processi e usare l&#8217;idea dei punti fissi semplifica la descrizione del metodo.
</div>
<div class="footnote" id="_footnotedef_35">
<a href="#_footnoteref_35">35</a>. Il metodo di Newton non converge sempre a una soluzione, ma si può dimostrare che nei casi favorevoli ogni iterazione raddoppia l&#8217;accuratezza del numero di cifre dell&#8217;approssimazione alla soluzione. In questi casi, il metodo di Newton converge molto più rapidamente rispetto al metodo di bisezione.
</div>
<div class="footnote" id="_footnotedef_36">
<a href="#_footnoteref_36">36</a>. Per trovare le radici quadrate, il metodo di Newton converge rapidamente alla soluzione corretta da qualsiasi punto di partenza.
</div>
<div class="footnote" id="_footnotedef_37">
<a href="#_footnoteref_37">37</a>. La nozione di <em>status</em> di prima classe degli elementi del linguaggio di programmazione è dovuta allo scienziato informatico britannico Christopher Strachey (1916-1975).
</div>
<div class="footnote" id="_footnotedef_38">
<a href="#_footnoteref_38">38</a>. Vedremo esempi di questo dopo aver introdotto le strutture dati nel capitolo 2.
</div>
<div class="footnote" id="_footnotedef_39">
<a href="#_footnoteref_39">39</a>. Il costo di implementazione principale delle funzioni di prima classe è che consentire alle funzioni di essere restituite come valori richiede di riservare la memoria per i nomi liberi di una funzione anche mentre la funzione non è in esecuzione. Nell&#8217;implementazione JavaScript che studieremo nella sezione TODOD sec:mc-eval, questi nomi sono memorizzati nell&#8217;ambiente della funzione.
</div>
</div>
<div id="footer">
<div id="footer-text">
Versione 0.1.1<br>
</div>
</div>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/github.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]],
    ignoreClass: "nostem|nolatexmath"
  },
  asciimath2jax: {
    delimiters: [["\\$", "\\$"]],
    ignoreClass: "nostem|noasciimath"
  },
  TeX: { equationNumbers: { autoNumber: "none" } }
})
MathJax.Hub.Register.StartupHook("AsciiMath Jax Ready", function () {
  MathJax.InputJax.AsciiMath.postfilterHooks.Add(function (data, node) {
    if ((node = data.script.parentNode) && (node = node.parentNode) && node.classList.contains('stemblock')) {
      data.math.root.display = "block"
    }
    return data
  })
})
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
</body>
</html>